
/* rfont.c - Raster Font stuff, draws text based on a blit and a font
   in a format that some day may approach Ventura Publisher, but currently
   looks much more like GEM on the ST with some Mac-like mutations.
   Also data for the Aegis Animator font with proportional stuff stripped.
   (This font is just a handy example of the format, unused itself.)

   There are 2 big routines - systext() - for all text rendered by
   menuing system -  and gftext() for text rendered onto user image. */

#include <string.h>
#include "jimk.h"
#include "gemfont.h"

extern UBYTE sixhi_data[];
extern WORD sixhi_ch_ofst[];
extern struct font_hdr sixhi_font;
struct font_hdr *usr_font = &sixhi_font; 

#ifdef USEFUL
char sail_name[] = "SAIL.FNT";

UBYTE sail_data[] = {
	0x00,0xc5, 0x14,0x23, 0xe6,0x04, 0x11,0x00, 
	0x00,0x00, 0x00,0x02, 0x30,0x87, 0x1c,0x13, 
	0xe7,0x3e, 0x71,0xc0, 0x00,0x00, 0x00,0x1c, 
	0x71,0xcf, 0x1c,0xf3, 0xef,0x9c, 0x89,0xc0, 
	0xa2,0x82, 0x28,0x9c, 0xf1,0xcf, 0x1c,0xfa, 
	0x28,0xa2, 0x8a,0x27, 0x9c,0x81, 0xc2,0x00, 
	0x20,0x08, 0x00,0x08, 0x03,0x80, 0x80,0x41, 
	0x10,0x30, 0x00,0x00, 0x00,0x00, 0x00,0x40, 
	0x00,0x00, 0x00,0x00, 0x0c,0x21, 0x80,0x00, 
	0x00,0xc5, 0x3e,0x7b, 0x2a,0x04, 0x20,0x8a, 
	0x88,0x00, 0x00,0x04, 0x49,0x88, 0xa2,0x32, 
	0x08,0x02, 0x8a,0x22, 0x04,0x10, 0x04,0x22, 
	0x8a,0x28, 0xa2,0x8a, 0x08,0x22, 0x88,0x80, 
	0xa4,0x83, 0x6c,0xa2, 0x8a,0x28, 0xa2,0x22, 
	0x28,0xa2, 0x52,0x20, 0x90,0x40, 0x47,0x00, 
	0x21,0xcb, 0x0e,0x69, 0xc4,0x1e, 0xb0,0x00, 
	0x12,0x13, 0x4b,0x1c, 0xb1,0xab, 0x1e,0xfa, 
	0x28,0xa2, 0x8a,0x2f, 0x90,0x20, 0x44,0x00, 
	0x00,0xc5, 0x14,0xa0, 0x44,0x08, 0x40,0x47, 
	0x08,0x00, 0x00,0x04, 0x58,0x80, 0x8c,0x53, 
	0xcf,0x04, 0x72,0x22, 0x04,0x23, 0xe2,0x02, 
	0xbb,0xef, 0x20,0x8b, 0xcf,0x20, 0xf8,0x80, 
	0xa8,0x82, 0xaa,0xa2, 0xf2,0x2f, 0x18,0x22, 
	0x28,0xaa, 0x21,0xc1, 0x10,0x20, 0x4a,0x80, 
	0x10,0x2c, 0x90,0x9a, 0x2f,0x22, 0xc8,0xc3, 
	0x14,0x12, 0xac,0xa2, 0xca,0x6c, 0xa0,0x42, 
	0x28,0xa2, 0x52,0x21, 0x10,0x20, 0x4a,0x80, 
	0x00,0xc0, 0x14,0x70, 0x8a,0x80, 0x40,0x4d, 
	0xbe,0x03, 0xe0,0x08, 0x68,0x87, 0x02,0xf8, 
	0x28,0x84, 0x89,0xe0, 0x00,0x40, 0x01,0x0c, 
	0xba,0x28, 0xa0,0x8a, 0x08,0x26, 0x88,0x80, 
	0xb8,0x82, 0xa9,0xa2, 0x82,0xaa, 0x04,0x22, 
	0x25,0x2a, 0x50,0x82, 0x10,0x20, 0x42,0x00, 
	0x01,0xe8, 0x90,0x8b, 0xe4,0x22, 0x88,0x41, 
	0x18,0x12, 0xa8,0xa2, 0x8a,0x28, 0x1c,0x42, 
	0x25,0x2a, 0x22,0x22, 0x20,0x20, 0x21,0x00, 
	0x00,0x00, 0x3e,0x29, 0x69,0x00, 0x40,0x47, 
	0x08,0x20, 0x02,0x08, 0x48,0x88, 0x22,0x12, 
	0x28,0x88, 0x88,0x22, 0x04,0x23, 0xe2,0x00, 
	0x82,0x28, 0xa2,0x8a, 0x08,0x22, 0x88,0x88, 
	0xa4,0x82, 0x28,0xa2, 0x82,0x69, 0x22,0x22, 
	0x25,0x36, 0x88,0x84, 0x10,0x10, 0x42,0x00, 
	0x02,0x2c, 0x90,0x9a, 0x04,0x1c, 0x88,0x41, 
	0x14,0x12, 0xa8,0xa2, 0xca,0x68, 0x02,0x42, 
	0x65,0x2a, 0x51,0xe4, 0x10,0x20, 0x40,0x00, 
	0x00,0xc0, 0x14,0xf2, 0x6e,0x80, 0x20,0x8a, 
	0x88,0x20, 0x02,0x10, 0x31,0xcf, 0x9c,0x11, 
	0xc7,0x08, 0x71,0xc2, 0x04,0x10, 0x04,0x08, 
	0x72,0x2f, 0x1c,0xf3, 0xe8,0x1c, 0x89,0xc7, 
	0x22,0xfa, 0x28,0x9c, 0x81,0xc8, 0x9c,0x21, 
	0xc2,0x22, 0x88,0x87, 0x90,0x08, 0x42,0x00, 
	0x01,0xab, 0x0e,0x69, 0xc4,0x02, 0x88,0x41, 
	0x12,0x12, 0xa8,0x9c, 0xb1,0xa8, 0x3c,0x31, 
	0xa2,0x14, 0x88,0x2f, 0x90,0x20, 0x40,0x00, 
	0x00,0x00, 0x00,0x20, 0x00,0x00, 0x11,0x00, 
	0x00,0x40, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0x08,0x00, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0x00,0x00, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0x00,0x20, 0x00,0x00, 
	0x00,0x00, 0x00,0x00, 0x1c,0x01, 0xc0,0x3e, 
	0x00,0x00, 0x00,0x00, 0x00,0x3c, 0x00,0x06, 
	0x00,0x00, 0x00,0x00, 0x80,0x20, 0x00,0x00, 
	0x00,0x00, 0x01,0xc0, 0x0c,0x21, 0x80,0x00, 
	};

WORD sail_ch_ofst[] = {
0, 6, 12, 18, 24, 30, 36, 42,
48, 54, 60, 66, 72, 78, 84, 90,
96, 102, 108, 114, 120, 126, 132, 138,
144, 150, 156, 162, 168, 174, 180, 186,
192, 198, 204, 210, 216, 222, 228, 234,
240, 246, 252, 258, 264, 270, 276, 282,
288, 294, 300, 306, 312, 318, 324, 330,
336, 342, 348, 354, 360, 366, 372, 378,
384, 390, 396, 402, 408, 414, 420, 426,
432, 438, 444, 450, 456, 462, 468, 474,
480, 486, 492, 498, 504, 510, 516, 522,
528, 534, 540, 546, 552, 558, 564, 570,
576, 582, 588,
};

struct font_hdr sail_font =
	{
	STPROP, 0, "SAIL.FNT", ' ',127,  
	0,0,0,0,0,	/* *_dist */
	6, 6,  /*widths... */
	0,0,0,0,0,0,	/* through skew_m */
	0, /*flags */
	NULL, /* hz_ofst */
	sail_ch_ofst,
	(WORD *)sail_data,
	72, 7,	/* frm_wdt,frm_hgt */
	NULL,	/* next font */
	};
#endif /* USEFUL */

struct b1block
	{
	WORD width, height;
	WORD sx, sy;
	char *spt;
	WORD snext_line;
	WORD dx, dy;
	char *dpt;
	WORD dnext_line;
	};

intel_swap(pt, count)
register char *pt;
int count;
{
register char swap;

while (--count >= 0)
	{
	swap = pt[1];
	pt[1] = pt[0];
	pt[0] = swap;
	pt += 2;
	}
}


systext(s, x, y, color,tblit,bcolor)
register char *s;
int x, y, color;
Vector tblit;	/* blit vector */
int bcolor;
{
register char c;

to_upper(s);
y+=1;
while ((c = *s++) != 0)
	{
	(*tblit)(6, 6, 6*c, 0, sixhi_data, 
		192, x, y, VGA_SCREEN, 320, color,bcolor);
	x+=6;
	}
}


/* gftext -
	graphics text in any font, no special effects yet at least.
	*/
#ifdef OLDWAY
gftext(screen, f, s, x, y, color, tblit, bcolor)
Vscreen *screen;
register struct font_hdr *f;
register unsigned char *s;
int x, y, color;
Vector tblit;	/* blit vector */
int bcolor;
{
unsigned char hi, lo;
int c;
int sx, sw;
WORD *off, wd, ht, *data;
PLANEPTR p;

p = screen->p;
lo = f->ADE_lo;
hi = f->ADE_hi;
off = f->ch_ofst;
wd = f->frm_wdt;
ht = f->frm_hgt;
data = f->fnt_dta;
while ((c = *s++)!=0)
	{
	if (c > hi)
		c = ' ';
	c -= lo;
	if (c < 0)
		c = 0;
	sx = off[c];
	sw = off[c+1]-sx;
	(*tblit)(sw, ht, sx, 0, data, wd, x, y, p, 
		BPR, color,bcolor);

	x += sw;
	}
}
#endif /* OLDWAY */

typedef union
	{
	  int  theInt;
	  char bytes[2];
	} myInt;

gftext(screen, f, s, x, y, color, tblit, bcolor)
Vscreen *screen;
register struct font_hdr *f;
register unsigned char *s;
int x, y, color;
Vector tblit;	/* blit vector */
int bcolor;
{
unsigned char *ss;
int c, lo, hi;
int sx, imageWid;
WORD *off, wd, ht, *data;
myInt *OWtab, *iPtr;
int missChar;
PLANEPTR p;
int font_type;

p = screen->p;
lo = f->ADE_lo;
hi = f->ADE_hi;
off = f->ch_ofst;
wd = f->frm_wdt;
ht = f->frm_hgt,
data = f->fnt_dta;
OWtab= (myInt *)(f->hz_ofst);
font_type = f->id;

while ((c = *s++)!=0)
	{
	if (c > hi)
		{
		c = ' ';
		}
	c -= lo;
	if (c < 0)
		{
		c = ' ' - lo;
		}
	/* Mac prop font && its a missing char */
	if (font_type == MPROP && (*(OWtab+c)).theInt == -1) 
		{            
		c=hi-lo;                      /* last char is set */
		missChar=1;
		sx = off[c+1];
		imageWid= f->frm_wdt*8 - sx;  /* sort of a kludge */
		}
	else 
		{
		missChar=0;
		sx = off[c];
		imageWid = off[c+1]-sx;
		}
	(*tblit)(imageWid, ht, sx, 0, data, wd, x, y, p, 
		BPR, color,bcolor);
	switch (font_type)
		{
		case STPROP:
			x += imageWid;
			break;
		case MFIXED:
			x += f->wchr_wdt;          
			break;
		case MPROP:
			iPtr=OWtab+c;  
			if (!missChar)
				/* -1 means its a missing character */
				{
				x += (int)((*iPtr).bytes[1]);
				ss=s;
				if ((c=*(ss++)) != 0)
					/* look to next char to determine amt to change x */
					{
					c-= lo;
					iPtr=OWtab+c;
					/* subtract kern Of Next char */
					/* f->rgt_ofst is neg of Mac maxKern value */
					if ((*iPtr).theInt!=-1)
					   x += (int)((*iPtr).bytes[0])+ f->rgt_ofst;  
					}           
			   }
			else /* display the non print char */
				x+=imageWid;
			break;
		}
	}
}

#ifdef SLUFFED
/* get a magnetic copy of system font */
write_sail_font()
{
if (!jexists(sail_name))
	save_font(sail_name, &sail_font);
}
#endif /* SLUFFED */

fchar_width(f,s)
register struct font_hdr *f;
unsigned char *s;
{
int c;
char *offsets;
int width;
int t;

c = *s++;
if (c > f->ADE_hi)
	c = ' ';
c -= f->ADE_lo;
if (c < 0)
	{
	c = ' ' - f->ADE_lo;
	}
switch (f->id)
	{
	case MFIXED:
		return(f->wchr_wdt);
	case STPROP:
		return(f->ch_ofst[c+1] - f->ch_ofst[c]);
	case MPROP:
		offsets = f->hz_ofst+c*2;
		if (offsets[0] == -1 && offsets[1] == -1)	/* missing char */
			{
			t = f->ADE_hi - f->ADE_lo;
			return( f->frm_wdt*8 - f->ch_ofst[t+1]);
			}
		else
			{
			width = offsets[1];
			if ((c = *s++) != 0)
				{
				c -= f->ADE_lo;
				offsets = f->hz_ofst+c*2;
				width += offsets[0] + f->rgt_ofst;
				}
			return(width);
			}
	}
}

long fnstring_width(f, s, n)
struct font_hdr *f;
register unsigned char *s;
int n;
{
long acc = 0;

while (--n >= 0)
	{
	acc += fchar_width(f, s);
	s++;
	}
return(acc);
}

long fstring_width(f, s)
struct font_hdr *f;
unsigned char *s;
{
return(fnstring_width(f, s, strlen(s)));
}



widest_char(f)
struct font_hdr *f;
{
unsigned char buf[2];
int i;
int c;
int widest = 1;
int w;

c = f->ADE_lo;
i = f->ADE_hi - c;
buf[1] = 0;
while (--i >= 0)
	{
	buf[0] = c++;
	w = fchar_width(f, buf);
	if (w > widest)
		widest = w;
	}
return(widest);
}

font_cel_height(f)
struct font_hdr *f;
{
int dy;

dy = f->frm_hgt;
return(dy + ((dy+3)>>2) );
}

