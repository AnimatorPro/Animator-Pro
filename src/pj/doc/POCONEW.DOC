-------------------------------------------------------------------------------
To the Variables and Variable Types section (page 9) add after Screen type:
-------------------------------------------------------------------------------


Flic      Only allowed as Flic *.  Flic handle for Flic
          Playback Library functions.


-------------------------------------------------------------------------------
To the FILES section add at the end:
-------------------------------------------------------------------------------

int errno;

function:   This global variable will contain an Errcode for the last FILE 
            library function that failed.
example:
            if ((f = fopen("filename.txt", "r")) == NULL)
                Qerror(errno, "Couldn't open file");



-------------------------------------------------------------------------------
New Functions for USER INTERFACE LIBRARY: 
-------------------------------------------------------------------------------
    Qedit
    QeditFile
    QmenuWithFlags
    PhysicalWaitClick
    PhysicalPollInput
    PhysicalWaitInput

int Qedit(char *text_buffer, int max_size, int *cursor_position, int *top_line);
        Brings up a simple full screen text editor to view and modify a string 
        in memory.   See also QeditFile().
    parameters:
        char *text_buffer     - Text to edit.  An array of characters that is
                                max_size bytes long.   To start the editor with
                                no text, set text_buffer[0] to zero.  Otherwise
                                put the initial text in text_buffer as a zero
                                terminated string.
        int   max_size        - The size of text_buffer.
        int  *cursor_position - Points to a variable that holds the
                                cursor position in characters from the
                                start of text_buffer.
        int  *top_line        - Points to a variable that indicates the
                                the first line of text visible in the editor.
                                If *top_line is positive it indicates to start
                                the editor with some lines of text already
                                scrolled off the top.
    return value:
        Size of text after edit.
    example:
        {
        int cursor = 0, line = 0;
        char buffer[1024] = "";
            ...
        Qedit(buffer, Array_els(buffer), &cursor, &line);
        }

int QeditFile(char *file_name, int *cursor_position, int *top_line)
        Brings up a simple full screen text editor to view and modify a file. 
        See also Qedit().
    parameters:
        char *file_name     -   Name of file to edit.  Should be an ascii
                                text file.   If file doesn't exist it will
                                be created.
        int  *cursor_position - Points to a variable that holds the
                                cursor position in characters from the
                                start of file.
        int  *top_line        - Points to a variable that indicates the
                                the first line of text visible in the editor.
                                If *top_line is positive it indicates to start
                                the editor with some lines of text already
                                scrolled off the top.
    return value:
        Size of text after edit.
    example:
        {
        int cursor = 0, line = 0;
            ...
        QeditFile("letter.txt", &cursor, &line);
        }

int  QmenuWithFlags(char **choices, int ccount, short *flags, char *header);
     Function:      Puts up a numbered pop-up menu much like the simpler
                    Qmenu(). QmenuWithFlags allows you to display certain 
                    choices as selected (with an asterisk beside them) or 
                    disabled (greyed out).  
     Parameters:    char **choices  The array containing the menus items.
                                    There can be a maximum of ten items.  
                                    The last item in a menu should always be 
                                    "End," "Exit," "Cancel," and so on.
                    int ccount      The number of choices in the menus.
                                    (The number of elements in the array.)
                    short *flags    This array contains a flag for each menu
                                    item.   If bit 0 of the flag is set then
                                    the corresponding menu item will be 
                                    disabled.  If bit 1 of the flag is set then
                                    the corresponding menu item will have an
                                    asterisk by it.  (See example for suggested
                                    symbolic names for bit 0 and bit 1.)  
                                    The order of this array corresponds to the
                                    return value,  not the order of the choices
                                    array.  That is the last choice is 
                                    represented by flags[0],  and the first
                                    by flags[1].
                    char *header    The text that appears in the menu header.
     Return Value:  int [0-9]       Returns the number of the menu item that 
                                    the  user selected.  The first array 
                                    element is 1;  the last array element is 0.
     Example:
     /* This example lets you select the ink from one of three choices:
      * opaque,  glass, and scrape.  It displays an asterisk by the currently
      * selected ink.  It will disable scrape ink if there is no swap screen.
      */
    /* Symbolic names for flag bits. */
    #define QMF_DISABLED (1<<0)     
    #define QMF_ASTERISK (1<<1)
    /* Menu choice text. */
    char *ink_choices[4] = {"Opaque", "Glass", "Scrape", "Cancel"};
    /* Symbolic names for QmenuWithFlags() return values. */
    enum {INK_CANCEL, INK_OPAQUE, INK_GLASS, INK_SCRAPE};
    /* Flags array for showing asterisks and disabled items. */
    short ink_flags[4];
    /* Space to hold name of current ink. */
    char current_ink[16];

    /* Zero out flags so nothing is asterisked or disabled initially. */
    memset(ink_flags, 0, sizeof(ink_flags));
    /* Set an asterisk to appear by currently selected ink. */
    GetInk(current_ink);
    if (stricmp(current_ink, "opaque") == 0)
        ink_flags[INK_OPAQUE] |= QMF_ASTERISK;
    else if (stricmp(current_ink, "glass") == 0)
        ink_flags[INK_GLASS] |= QMF_ASTERISK;
    else if (stricmp(current_ink, "scrape") == 0)
        ink_flags[INK_SCRAPE] |= QMF_ASTERISK;
    /* Disable scrape ink if swap screen doesn't exist. */
    if (!SwapExists())
        ink_flags[INK_SCRAPE] |= QMF_DISABLED;
    /* Put up menu and switch on the result. */
    switch (QmenuWithFlags(ink_choices, 4, ink_flags, "Select an ink"))
        {
        case INK_OPAQUE:
            SetInk("Opaque");
            break;
        case INK_GLASS:
            SetInk("Glass");
            break;
        case INK_SCRAPE:
            SetInk("Scrape");
            break;
        default:
            break;
        }


void PhysicalWaitClick(int *x, int *y, int *left, int *right, int *key);
     Function:      Waits for the user to click the mouse or press a key.
                    (See also WaitClick).   This function returns the x,y
                    coordinates based on the mouse position on the physical
                    screen (see GetPhysicalScreen) as opposed to the logical
                    drawing screen.   If Animator Pro is working on a flic
                    which isn't the same size as the screen this makes a 
                    difference.   This function is useful primarily for 
                    implementing custom panel style dialog boxes.
     Parameters:    int *x         X position of mouse at end of function.
                    int *y         Y position of mouse at end of function.
                    int *left      1 if left mouse button was pressed,
                                   otherwise 0.
                    int *right     1 if right mouse button was pressed,
                                   otherwise 0.
                    int *key       Scan code if key pressed, otherwise 0.
     Return Value:  none

void PhysicalPollInput(int *x, int *y, int *left, int *right, int *key);
     Function:      Polls the current input state and returns immediately.
                    (See also PollInput).   This function returns the x,y
                    coordinates based on the mouse position on the physical
                    screen (see GetPhysicalScreen) as opposed to the logical
                    drawing screen.   If Animator Pro is working on a flic
                    which isn't the same size as the screen this makes a 
                    difference.   This function is useful primarily for 
                    implementing custom panel style dialog boxes.
     Parameters:    int *x         X position of mouse at end of function.
                    int *y         Y position of mouse at end of function.
                    int *left      1 if left mouse button was pressed,
                                   otherwise 0.
                    int *right     1 if right mouse button was pressed,
                                   otherwise 0.
                    int *key       Scan code if key pressed, otherwise 0.
     Return Value:  none

void PhysicalWaitInput(int *x, int *y, int *left, int *right, int *key);
     Function:      Waits for any input - key press, mouse move, or mouse 
                    button. (See also WaitInput).   This function returns the 
                    x,y coordinates based on the mouse position on the physical
                    screen (see GetPhysicalScreen) as opposed to the logical
                    drawing screen.   If Animator Pro is working on a flic
                    which isn't the same size as the screen this makes a 
                    difference.   This function is useful primarily for 
                    implementing custom panel style dialog boxes.
     Parameters:    int *x         X position of mouse at end of function.
                    int *y         Y position of mouse at end of function.
                    int *left      1 if left mouse button was pressed,
                                   otherwise 0.
                    int *right     1 if right mouse button was pressed,
                                   otherwise 0.
                    int *key       Scan code if key pressed, otherwise 0.
     Return Value:  none

-------------------------------------------------------------------------------
New Functions for GRAPHICS LIBRARY: 
-------------------------------------------------------------------------------
    GetBoxBevel
    SetBoxBevel
    SetCluster
    GetCluster
    HLStoRGB
    RGBtoHLS
    ClosestColorInScreen
    SqueezeColors
    FitScreenToColorMap

int     GetBoxBevel(void);
     Function:      Get the size of the diagonal corners of boxes
                    draw with Box() function.
                    See also SetBoxBevel.   Defaults to 0.
     Parameters:    none
     Return Value:  Size of diagonal corners of boxes.

void    SetBoxBevel(int new_bevel);
     Function:      Set the size of the diagonal corners of boxes
                    draw with Box() function.
                    See also GetBoxBevel.   Defaults to 0.
     Parameters:    New size of diagonal corners drawn by Box function.
     Return Value:  none

void     SetCluster(int cluster_size, int *cluster);
     Function:      Set the colors in the current color cluster (which is
                    used to draw gradients among other things).
     Parameters:    int cluster_size - Number of colors in cluster.  Between
                                       1 and 256.
                    int *cluster     - Array of indexes of colors in cluster
     Return Value:  none
     Example:
        void set_cluster_to_range(int start, int end)
        // Function to set cluster include all colors between start and end.
        {
        int cluster[256];   // We won't necessarily use all of this.
        int i, count;

        count = end - start + 1;    // Calculate number of colors in cluster
        for (i=0; i<count; ++i)
            cluster[i] = start + i;
        SetCluster(count, cluster);
        }

ErrCode GetCluster(int *cluster_size, int **cluster);
     Function:      Get the colors in the current color cluster (which is
                    used to draw gradients among other things).
     Parameters:    int *cluster_size - Returns number of colors in cluster.  
                    int **cluster     - Returns array of indexes of colors in 
                                        cluster.  This should be freed when you
                                        are done with it.
     Return Value:  Success (0) or negative error code if out of memory.
     Example:
        void zero_colors_in_cluster()
        // Set all colors in the cluster to 0,0,0
        {
        int *cluster, count;
        int i;

        if (GetCluster(&cluster, &count) >= 0)  // Make sure we get cluster ok.
            {
            for (i=0; i<count; ++i)             // Go through each color 
                {
                SetColorMap(cluster[i], 0,0,0); // and set it to zero.
                }
            free(cluster);                      // Free memory used by cluster.
            }
        }

void    HLStoRGB(int h, int l, int s, int *r, int *g, int *b);
     Function:      Convert hue lightness saturation color representation
                    to RGB.
     Parameters:    int h   - Hue value (position in rainbow) input here.
                              From 0 for red through 255 for violet.
                    int l   - Lightness value (monochrome brightness) input 
                              here.  From 0 for black to 255 for white.
                    int s   - Saturation value (vividness of color) input here.
                              From 0 for a grey to 255 for a bright primary
                              color.
                    int *r  - Red value output.  0-255.
                    int *g  - Green value output.  0-255.
                    int *b  - Blue value output.  0-255.
     Return Value:  none
     Example:       see RGBtoHLS

void    RGBtoHLS(int r, int g, int b, int *h, int *l, int *s);
     Function:      Convert RGB color representation to hue, lightness, 
                    saturation.
     Parameters:    int r   - Red value input here. 0-255.
                    int g   - Green value input here.  0-255.
                    int b   - Green value input here.  0-255.
                    int *h  - Hue value (position in rainbow) output.
                              From 0 for red through 255 for violet.
                    int *l  - Lightness value (monochrome brightness) output. 
                              From 0 for black to 255 for white.
                    int *s  - Saturation value (vividness of color) output.
                              From 0 for a grey to 255 for a bright primary
                              color.
     Return Value:  none
     Example:       
        void lighten_background()
        // Lighten the background color (color 0).
        {
            int r,g,b,h,l,s;

            GetColorMap(0,&r,&g,&b);    // Get current RGB value.
            RGBtoHLS(r,g,b,&h,&l,&s);   // Convert it to HLS.
            l += 64;                    // Make it lighter.
            if (l > 255)                // (But keep it within range 0-255)
                l = 255;
            HLStoRGB(h,l,s,&r,&g,&b);   // Convert it back to RGB
            SetColorMap(0,r,g,b);       // And make change visible.
        }

int     ClosestColorInScreen(Screen *s, int r, int g, int b);
     Function:      Find the closest color in screen's color map to
                    an RGB value.
     Parameters:    Screen *s   - Screen in who's color map we're searching.
                                  Typically this will be GetPicScreen().
                    int r       - Red value of color we're trying to match.
                    int g       - Green value of color we're trying to match.
                    int b       - Blue value of color we're trying to match.
     Return Value:  Index of closest color in screen's color map to the
                    rgb values.
     Example:
        red = ClosestColorInScreen(GetPicScreen(), 255, 0, 0);
        SetColor(red);

ErrCode SqueezeColors(int *source_map, int source_count
, int *dest_map, int dest_count);
    Function:       Reduce the number of colors in a color map.
    Parameters:     int *source_map   - Original unsqueezed color map.
                    int  source_count - Number of colors in source_map.
                    int *dest_map     - Squeezed map will be put here.
                    int  dest_count   - Number of colors you want in 
                                        dest map.
    Return Value:   Success (0) or Err_no_memory (-2).
    Example:
        void make_fit_for_windows()
        // Converts the current color map to only use the first 236 colors.
        // Pictures with 236 colors or less display better under Windows
        // since it reserves 20 colors for it's own use.
        {
        int cmap[256*3];
        int i;

        GetScreenColorMap(GetPicScreen(), cmap);  // Get current color map.
        SqueezeColors(cmap, 256, cmap, 236);      // Squeeze it to 236 colors.
        for (i=236*3; i<256*3; ++i)               // Set rest of color map
            cmap[i] = 0;                          // to black.
                                                  // Then refit screen.
        FitScreenToColorMap(GetPicScreen(), cmap, FALSE);
        }

ErrCode FitScreenToColorMap(Screen *s, int *new_colors, Boolean keep_key);
    Function:       Update the screen's color map with new_colors,  and remap 
                    the pixel values so that the screen looks as much as 
                    possible the same as it ever did. 
    Parameters:     Screen *s          - Screen to update.
                    int    *new_colors - New color map.
                    Boolean keep_key   - If this is TRUE then key-color pixels
                                         will not be changed (even if they
                                         RGB value of the key-color is
                                         changed).
    Return Value:   Success (0) or a negative error code (see errcodes.h)
    Example:
        void monochrome_pic()
        // Convert screen to grey-scale.
        {
        int mono_map[256*3];
        int *pt;
        int i;

        // First create a monochrome color map.
        pt = mono_map;              
        for (i=0; i<256; ++i)       // Go through each color
            {
            *pt++ = i;              // Set r value
            *pt++ = i;              // Set g value
            *pt++ = i;              // Set b value
            }
        FitScreenToColorMap(GetPicScreen(), mono_map, FALSE);
        }

-------------------------------------------------------------------------------
New Functions for TEXT LIBRARY: 
-------------------------------------------------------------------------------
    CanScaleFont
    ScaleFont
    SetFontSpacing
    GetFontSpacing
    SetFontLeading
    GetFontLeading
    WordWrapCountLines

Boolean CanScaleFont(void);
    Function:       See if current font can be scaled.
    Parameters:     none
    Return Value:   TRUE if font can be scaled, FALSE if not.

Errcode ScaleFont(int height)
    Function:       Set the height of a scalable font.
    Parameters:     int height - Distance from highest ascender to lowest 
                                 descender in pixels.
    Return Value:   Success (0) or a negative error code.  See errcodes.h.

void SetFontSpacing(int spacing);
    Function:       Set the "extra" distance between letters of text.
    Parameters:     int spacing - Number of pixels of extra spacing.
    Return Value:   none

int GetFontSpacing(void);
    Function:       Get the "extra" distance between letters of text.
    Parameters:     none
    Return Value:   Number of pixels of extra spacing.

void SetFontLeading(int leading);
    Function:       Set the "extra" distance between lines of text.
    Parameters:     int spacing - Number of extra pixels between lines.
    Return Value:   none

int GetFontLeading(void);
    Function:       Get the "extra" distance between lines of text.
    Parameters:     none
    Return Value:   Number of extra pixels betwen lines.

int    WordWrapCountLines(int width, char *text);
    Function:       Count the number of lines text will be broken into
                    by word wrapping into a box of a certain width.
                    (See alsow WordWrap.)
    Parameters:     int width   - Width of box in pixels.
                    char *text  - Zero terminated string containing text
                                  to word-wrap.

-------------------------------------------------------------------------------
New Function for CEL LIBRARY: 
-------------------------------------------------------------------------------
    CelRelease

void    CelRelease(void);
    Function:   Delete Cel and free up any memory associated with it.
    Parameters: none
    Return Value: none

-------------------------------------------------------------------------------
New Functions for SCREEN LIBRARY:
-------------------------------------------------------------------------------
    GetPhysicalScreen
    SetBox
    MenuText
    MenuTextWidth
    MenuTextHeight
    GetMenuColors

Screen  *GetPhysicalScreen(void);
    Function:   Returns a handle to the full physical screen.  
                You should take care when drawing to this screen to restore
                it when you are done.  This function is useful for people
                implementing their own panel style menus.  See also
                PhysicalWaitInput.
    Parameters: none
    Return Value: Handle to screen.

void    SetBox(Screen *s, int color, int x, int y, int width, int height);
    Function:       Draw a filled rectangle quickly in a solid color.
    Parameters:     Screen *s   - Screen to draw upon.
                    int color   - Color of box.
                    int x       - Left edge of box.
                    int y       - Top edge of box.
                    int width   - Width of box.
                    int height  - Height of box.
    Return Value: none

void   MenuText(Screen *screen, int color, int xoff, int yoff, char *text);
    Function:       Quickly draw text on screen in font used for menus.
    Parameters:     Screen *screen  - Screen to draw upon.
                    int     color   - Color of text.
                    int     xoff    - Upper left position of text.
                    int     yoff    - Upper left position of text.
                    char   *text    - Zero terminated text string to draw.
    Return Value:   none

int    MenuTextWidth(char *text);
    Function:       Calculate the width in pixels of a text string in the
                    menu font.
    Parameter:      char *text      - String to measure.
    Return Value:   Number of pixels wide text would be if drawn via MenuText.

int    MenuTextHeight(void);
    Function:       Find out height (distance from tallest ascender to lowest
                    descender) of menu font.
    Parameter:      none
    Return Value:   Height of menu font.

void   GetMenuColors(int *black, int *grey, int *light, int *bright, int *red);
    Function:       Find out colors currently used to draw menus.
                    (This function needs to be called again whenever the
                    color map changes.)
    Parameters:     int *black  - Returns color used for background of
                                  some unselected buttons.  By default black. 
                    int *grey   - Returns color used for outlines of buttons
                                  and menus as well as the text of buttons that
                                  can't be selected.  By default a (dark) grey.
                    int *light  - Returns color used for background of menus.
                                  By default a light grey.
                    int *bright - Returns color used for background of selected
                                  buttons.  By default bright white.
                    int *red    - Returns color used for text of selected
                                  buttons.  By default bright red.
    Return Value:   none.

-------------------------------------------------------------------------------
New Functions in C STANDARD STRING LIBRARY
-------------------------------------------------------------------------------
    atof
    strpbrk
    strspn
    strcspn
    strtok
    getenv
    strlwr
    strupd
    strerror

double  atof(char *string)
    Function:       Converts a floating point number represented as an ascii
                    string into it's double value.   

    Input:          string  - pointer to the string.
    Return Value:   The floating point number;
    Example:        double billion = atof("1.0e10")

char *strpbrk(char *string, char *breakset)

     Function:      Finds the first character in string which matches any
                    character in the breakset.

     Input:         string                   A pointer to the string to be
                                             scanned.

                    breakset                 A pointer to a string containing
                                             one or more characters to scan for.

     Return Value:  A pointer to the character found in the string, or NULL of
                    none of the characters in the breakset are in the string.







int     strspn(char *string, char *breakset);

     Function:      Finds the length of the initial substring within string that
                    consists entirely of characters from the spanset.

                    The return value is zero if the first character in string is
                    not in spanset, 1 if the first character is in spanset, but
                    the second isn't, and so on.

     Input:         string                   A pointer to the string to be
                                             scanned.

                    spanset                  A pointer to a string containing
                                             one or more characters to scan
                                             past.

     Return Value:  The number of characters at the beginning of string which
                    are in the spanset.


int *strcspn(char *string, char *spanset)

     Function:      Finds the length of the initial substring within string that
                    consists entirely of characters not in the spanset.  This
                    function is the complement of strspn().

     Input:         string                   A pointer to the string to be
                                             scanned.

                    breakset                 A pointer to a string containing
                                             one or more characters that will
                                             stop the scan.

     Return Value:  The number of characters at the beginning of string which
                    are not also in the spanset.






char    *strtok(char *string, char *delimset);

     Function:      Divides a string into a set of tokens.  Each token is a
                    substring from the original string; successive calls to this
                    function returns successive tokens from the string.
                    On the first call to this function, pass a pointer to a
                    string to be tokenized, and a pointer to a string containing
                    one or more characters which are the delimiters that
                    separate tokens.  On subsequent calls, pass a NULL string
                    pointer to indicate that you want the next token from the
                    string already being tokenized.

                    Each call to this function modifies the original string.
                    Nullterm characters are inserted at the end of every token,
                    replacing the delimiter character that existed at the end of
                    the token originally.

     Input:         string                   A pointer to the string to be
                                             tokenized, or NULL to indicate you
                                             want the next token from the prior
                                             string.

                    delimset                 A pointer to a string containing
                                             one or more characters which are
                                             the delimiters between tokens.

     Return Value:  A pointer to the current token in the string, or NULL to
                    indicate that there are no more tokens in the string.


char *strlwr(char *string)

     Function:      Converts all alphabetic characters in a string to lowercase;
                    doesn't affect non-alphabetic characters.

     Input:         string                   A pointer to the string to be
                                             converted to lowercase.

     Return Value:  A pointer to the string, same as the string parameter.


char *strupd(char *string)

     Function:      Converts all alphabetic characters in a string to uppercase;
                    doesn't affect non-alphabetic characters.

     Input:         string                   A pointer to the string to be
                                             converted to lowercase.

     Return Value:  A pointer to the string, same as the string parameter.







char *getenv(char *varname)

     Function:      Searches the DOS environment data for the named variable.
                    Returns a pointer to that variable's data, or NULL if the
                    variable isn't present in the environment.

                    Environment variables are established using the MSDOS SET
                    command before Animator Pro is started.  This function
                    allows you to retrieve the environment data stored using the
                    MSDOS SET command.

                    The return value is a pointer into the DOS environment area;
                    you must not modify the string pointed to by the return
                    value pointer.

                    Poco does not provide a putenv() function.  To transport
                    data between different Poco programs within an Animator Pro
                    session, use the functions in the Global Variables Library.

     Input:         varname                  A pointer to a string containing
                                             the name of the variable.  Do not
                                             include the '=' after the variable
                                             name.

     Return Value:  A pointer to the data string associated with the environment
                    variable, or NULL if the variable doesn't exist in the
                    environment data area.


char *strerror(int errnum)

     Function:      Returns an error message associated with an error code.

     Input:         errnum                   The numeric error code.

     Return Value:  A pointer to an error message string.  This will never be
                    NULL, but it may point to an empty string ("") if there is
                    no error message associated with errnum.


-------------------------------------------------------------------------------
New Function in C STANDARD MEMORY MANAGER LIBRARY
-------------------------------------------------------------------------------
    memchr

void    *memchr(void *a, int match_char, int size);
     Function:      Scans the memory block for the specified character, returns
                    a pointer to the character or NULL if the character isn't
                    found in the block.

     Input:         string                   A pointer to the memory block to be
                                             scanned.

                    match_char                    The character to be searched
                                                  for.

                    size                     The size of the memory block.

     Return Value:  A pointer to the character found in the block, or NULL if
                    the character isn't found.

-------------------------------------------------------------------------------
BRAND NEW TITLE LIBRARY
-------------------------------------------------------------------------------
The Title library is useful for creating flics that include moving text.
See also the Text library.

 void   TitleSetMovement(int movement);
        Set how the titles move when rendered.
        This will be either up the screen, across the screen, typed on,
        or still.  See constants in title.h.
    parameter:
        int movement  -  0, 1, 2, or 3 indicating Scroll Up, Scroll Across, 
                         Type On, or Still.  See symbolic definitions of these 
                         constants in title.h.
    return value:
            none
    example:
        #include "title.h"
            ...
        TitleSetMovement(TM_TYPE_ON);


 int    TitleGetMovement(void);
        Get how the titles move when rendered.
    parameters:
        none
    return value:
        0, 1, 2, or 3 indicating Scroll Up, Scroll Across, Type On,
        or Still.  See symbolic definitions of these constants in
        title.h.
    example:
        int movement_type = TitleGetMovement();


 void   TitleSetScrolling(int scrolling);
        Set whether scrolling is done by pixel or by character.
    parameters:
        int scrolling - 0 to scroll by pixel,  1 to scroll by character.
                        See also symbolic definitions TS_BY_PIXEL and 
                        TS_BY_CHARACTER in title.h
    return value:
        none
    example:
        #include "title.h"
            ...
        TitleSetScrolling(TS_BY_PIXEL);

 int    TitleGetScrolling(void);
        Get whether scrolling is done by pixel or by character.
    parameters:
        none
    return value:
        0 is scroll by pixel,  1 is scroll by character.
        See also symbolic definitions TS_BY_PIXEL and 
        TS_BY_CHARACTER in title.h
    example:
        int scrolling = TitleGetScrolling();

 ErrCode    TitleSetText(char *text);
        Set the titling text to the contents of a string.
    parameters:
        char *text - Text string to use for titling.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        TitleSetText("Dancing Flame Announces MegaPixel Merger");

 ErrCode    TitleSetTextFromFile(char *file_name);
        Set the titling text to the contents of a file.
    parameters:
        char *file_name - Name of file to use for titling.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        TitleSetTextFromFile("C:\\ANI\\CREDITS.TXT");


 char   *TitleGetText(void);
        Read the current titling text file into a string. 
    parameters:
        none
    return value:
        String that contains titling text.  
        The Poco programmer should free() this string when finished.
        Returns NULL if there's no current titling text, or if there's
        an error.
    example:
        char *titles;
        int  len;
            ...
        titles = TitleGetText();            // Fetch text into a C string.
        if (titles != NULL)                 // Procede if text exists.
            {
            len = strlen(titles);           // Count characters in string.
            SetFrameCount(len);             // Make one frame for each char.
            TitleRender();                  // Render titles.
            free(titles);                   // Don't forget to free it.
            }

 Boolean    TitleHasText(void);
        See if there is any titling text.
    parameters:
        none
    return value:
        Returns TRUE if there is some titling text, FALSE otherwise.
    example:
        if (TitleHasText())         // If titles exist
            TitleRender();          // render them.

 void   TitleSetPosition(int x, int y, int w, int h);
        Set position of  the rectangle in which the titles will be rendered.
    parameters:
        int x - The x coordinate of the upper left corner of titling rectangle.
        int y - The y coordinate of the upper left corner of titling rectangle.
        int w - Width of titling rectangle.
        int h - Height of titling rectangle.
    return value:
        none.
    example:
        int w,h;
            ...
        GetSize(&w,&h);             //Find out size of screen.
        TitleSetPosition(0,0,w,h)   //Do titles over full screen.



 void   TitleGetPosition(int *x, int *y, int *w, int *h);
        Get position of the rectangle in which the titles will be rendered.
    parameters:
        int *x - Recieves x coordinate of the upper left corner of title rect.
        int *y - Recieves y coordinate of the upper left corner of title rect.
        int *w - Recieves width of title rectangle.
        int *h - Recieves height of title rectangle.
    return value:
        none
    example:
        int x,y,w,h;
            ...
        TitleGetPosition(&x,&y,&w,&h);      // Find title rectangle.
        SetColor(background);               // Clear behind title area
        Box(x,y,w,h);                       // with background color.
        SetColor(foreground);               // Draw titles in 
        TitleRender();                      // Foreground color.

 void   TitleEdit(void);
        Invoke the titling menu "place text" function, which lets the
        user type in text and move around the text rectangle.
    parameters:
        none
    return value:
        none
    example:
        TitleEdit();            // Give user a chance to edit text.
        TitleRender();          // Then render it.

 ErrCode    TitleRender(void);
        Render current titling text over time.  (Uses the FSA mode
        to decide whether to go over a single frame, the segment, or
        over all.)
    parameters:
        none
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        #include "title.h"
            ...
        SetFrameCount(25);                      // Make some frames.
        TitleSetScroll(TM_SCROLL_ACROSS);       // Set up scrolling.
        TitleSetText("Call 1-800-555-POCO");    // Set up text.
        TitleRender();                          // And render it!

-------------------------------------------------------------------------------
BRAND NEW TWEEN LIBRARY
-------------------------------------------------------------------------------
The tween library lets you transform one polygon shape into another.
It gives you programatic control of the functions in the Animator Pro
Tween panel.

ErrCode TweenLoad(char *file_name);
        Load tween file into memory for use by other tween functions
        or Ani Pro tweening panel.
    parameters:
        char *file_name - Name of .TWE file to load.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        TweenLoad("METAMORF.TWE");

ErrCode TweenSave(char *file_name);
        Save current tween to a file.
    parameters:
        char *file_name - Name of .TWE file to save.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        TweenSave("STRINGY.TWE");

Boolean TweenExists(void);
        See if there is currently a tween.
    parameters:
        none
    return value:
        TRUE if a tween exists, FALSE otherwise.
    example:
        if (!TweenExists())                 // Is there a tween already?
            TweenLoad("DEFAULT.TWE");       // If not load the usual one.

void    TweenClear(void);
        Get rid of current tween.
    parameters:
        none
    return value:
        none
    example:
        if (TweenExists())              // If there is a tween
            TweenClear();               // then get rid of it. 

ErrCode TweenSetStart(int ptcount, int *x, int *y);
        Set the starting polygon of the tween.  (If there is no
        tween currently this will set the ending polygon as well.)
    parameters:
        int ptcount - Number of points in the tween polygon.
        int *x      - The x coordinates of the tween polygon.
        int *y      - The y coordinates of the tween polygon.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        int x[4] = {100, 200, 200, 100};    // X coordinates of a square.
        int y[4] = {100, 100, 200, 200};    // Y coordinates of a square.
            ...
        TweenSetStart(4,x,y);               // Set up a square start

ErrCode TweenGetStart(int *ptcount, int **x, int **y);
        Get the starting polygon of the tween.
    parameters:
        int *ptcount  - Recieves number of points in the starting polygon.
        int **x       - Recieves X coordinates of starting polygon
        int **y       - Recieves Y coordinates of starting polygon
    return value:
        0 on Success, or a negative error code.
        (Err_not_found if there is no tween)
        (See appendix A.)
    example:
        int ptcount, *x, *y;
            ...
        if (TweenGetStart(&ptcount, &x, &y) >= Success)
            {
            Poly(ptcount, x, y);        // Draw the start polygon.
            free(x);                    // Don't forget to free the
            free(y);                    // X and Y coodinate buffers.
            }


ErrCode TweenSetEnd(int ptcount, int *x, int *y);
    parameters:
        int ptcount - Number of points in the tween polygon.
        int *x      - The x coordinates of the tween polygon.
        int *y      - The y coordinates of the tween polygon.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        int ptcount, *x, *y;            // Variable to hold a polygon.
            ...
        if ((ptcount = RubPoly(&x, &y)) > 0)    // Ask user for polygon
            {
            TweenSetEnd(ptcount, x, y);         // And store it in tween end.
            free(x);                            // Done with RubPoly's points
            free(y);                            // so free them.
            }

ErrCode TweenGetEnd(int *ptcount, int **x, int **y);
    parameters:
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        int ptcount, *x, *y;
            ...
        if (TweenGetEnd(&ptcount, &x, &y) >= Success)
            {
            Spline(ptcount, x, y);      // Draw a curvy end polygon.
            free(x);                    // Don't forget to free the
            free(y);                    // X and Y coodinate buffers.
            }

void    TweenSwapEnds(void);
        Exchange the start and end shapes of the tween.  Has the
        visual result of reversing the motion of the tween.
    parameters:
        none
    return value:
        none
    example:
        if (Qquestion("Do you want to do it again backwards?"))
            {
            TweenSwapEnds();
            TweenRender();
            }

ErrCode TweenEndToStart(void);
        Copy the end polygon to the start polygon.
    parameters:
        none
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        /* How to prompt user to create an animation made of
         * 5 linked tween segments. */
        int i;                          // Loop counter
        int ptcount, *x, *y;            // Polygon variables.
            ...
        SetFrameCount(50);              // Make animation 50 frames long.
        SetFSA(1);                      // We'll render over a time segment.
        ptcount = RubPoly(&x,&y);       // Get start shape from user
        TweenSetStart(ptcount,x,y);     // and tell the tween system about it.
        free(x); free(y);               // Free up polygon memory.
        for (i=0; i<5; ++i)
            {
            SetSegStart(i*10);          // Set up a 10 frame time
            SetSegEnd(i*10 + 10);       // time segment.
            ptcount = RubPoly(&x,&y);   // Get next shape from user
            TweenSetEnd(ptcount,x,y);   // and use it for end shape.
            free(x); free(y);           // Free up polygon memory.
            TweenRender();              // Render tween.
            TweenEndToStart();          // End of this tween is start of next.
            }
        /* Phew.  Alas in real life we should check the results of
         * RubPoly in case the user wants to cancel out of this process.
         */


ErrCode TweenOneLink(int start_point, int end_point);
        Force one vertex of starting polygon to transform into a specific 
        vertex of ending polygon.  (If you want to link more than one
        set of vertices use TweenSetLinks() below.)  
    note:
        This has a side effect of re-ordering both the start and end 
        polygons so that start_point and end_point's position in their 
        respective polygons are both zero.
    parameters:
        start_point - Index of point to link in starting polygon.
        end_point   - Index of point to link in ending polygon.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        /* This example shows a way to make a shape look like it's
         * crawling into itself.  The start and end shapes are the
         * same, but by linking the first point of the start shape to the
         * second point of the end shape, typically you'll see a
         * rotating ameoba like crawling motion.
         */
        int ptcount, *x, *y;
            ...
        if ((ptcount = RubPoly(&x,&y)) > 0)     // Get polygon from user.
            {
            TweenSetStart(ptcount,x,y);         // Use it for the start
            TweenSetEnd(ptcount,x,y);           // and end shapes.
            free(x); free(y);                   // Free poly coordinates.
            TweenOneLink(0,1);                  // Make cross-linkage.
            TweenRender();                      // And render it!
            }


Errcode TweenSetLinks(int link_count, int *starts, int *ends);
        Specify where a number of vertices in start polygon are to end up
        in the end polygon.
    note:
        This has a side effect of re-ordering both the start and end 
        polygons so that starts[0] and ends[0]'s position in their 
        respective polygons are both zero.
    parameters:
        int link_count - The number of links.
        int *starts    - Starting vertices.
        int *ends      - Ending vertices.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        /* This example shows how to turn a square inside out. */
        int x[4] = {100, 200, 200, 100};    // X coordinates of a square.
        int y[4] = {100, 100, 200, 200};    // Y coordinates of a square.
        int starts[4] = {0, 1, 2, 3};       // The start is in order.
        int ends[4] = {3, 2, 1, 0};         // But the end is backwards.
            ...
        TweenSetStart(4,x,y);               // Set start and end shape to
        TweenSetEnd(4,x,y);                 // the same square.
        TweenSetLinks(4,starts,ends);       // Set up inverter linkage.
        TweenRender();                      // And render it.


Errcode TweenGetLinks(int *link_count, int **starts, int **ends);
        Find out the linkages between the start and end points if any.
    parameters:
        int *link_count;    Recieves number of active links.
        int **starts;       Recieves starting vertices.
        int **ends;         Recieves ending vertices.
    return value:
        0 on Success, Err_not_found if no links exist,
        or possibly another negative error code (such as Err_no_memory)
        if there are other problems.
        (See appendix A.)
    example:
        /* This example draws the start and the end shapes as polygons,
         * and then draws lines between the points that are linked.
         * (Not unlike the display at the tween panel, but lacking color. */
        int start_count, *start_x, *start_y;        // Start polygon.
        int end_count, *end_x, *end_y;              // End polygon.
        int link_count, *start_links, *end_links;   // Links.
            /* First get polys and links from tween system. */
        if (!TweenExists())
            return;                                 // Bail out if no tween.
        TweenGetStart(&start_count, &start_x, &start_y);
        TweenGetEnd(&end_count, &end_x, &end_y);
        TweenGetLinks(&link_count, &start_links, &end_links);
            /* Now draw both polys. */
        Poly(start_count, start_x, start_y);
        Poly(end_count, end_x, end_y);
            /* And loop through links drawing each one. */
        int i;                                      // Loop counter
        int start_ix, end_ix;                       // Position in polys.
        for (i=0; i<link_count; ++i)                // Do this for each link
            {
            start_ix = start_links[i];                  // Find start vertex.
            end_ix = end_links[i];                      // Find end vertex.
            Line(start_x[start_ix], start_y[start_ix]   // Draw a line from
            , end_x[end_ix], end_y[end_ix]);            // one to the other.
            }
            /* Now free up everything */
        free(start_x); free(start_y);               // Free start polygon.
        free(end_x); free(end_y);                   // Free end polygon.
        if (link_count)                             // If there were any links
            {
            free(start_links);                      // then free them 
            free(end_links);                        // too.
            }

void TweenClearLinks(void);
        Gets rid of all links between vertices.
    note:
        In the absense of any links the first point of the start
        polygon moves into the first point of the end polygon.
    parameters:
        none
    return value:
        none
    example:
        if (Qquestion("Does this tween look too gnarly?"))
            TweenClearLinks();

void    TweenSetSplined(Boolean is_splined);
        Controls whether a tween is rendered as a spline or as a 
        straight edged polygon.  (SetFilled() and SetClosed() also
        effect how the tween is rendered as well as how Poly() is
        drawn.)
    parameters:
        Boolean is_splined - TRUE if you desire rendering as a spline.
                             FALSE otherwise.
    return value:
        none
    example:
        SetInk("glass");            // Set glass ink.
        TweenSetSplined(FALSE);     // Draw tween with
        TweenRender();              // straight edges first.
        TweenSetSplined(TRUE);      // Now draw tween with
        TweenRender();              // curvy edges on top of old one.

Boolean TweenGetSplined(void);
        Find out whether tween will be rendered as straight edged polygon
        or as a spline.
    parameters:
        none.
    return value:
        TRUE if rendering as a spline.  FALSE if as a polygon.
    example:
        if (TweenGetSplined())
            Qtext("I hope you like curves.");

ErrCode TweenTrails(int steps);
        Renders the tween repeatedly on the same frame (as opposed to
        over time.)
    parameters:
        int steps   - number of shapes to generate.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        SetCycleDraw(TRUE);     // Trails usually look better when cycled
        TweenTrails(16);        // 16 is a good number of steps.

ErrCode TweenMakePoly(double time, int *ptcount, int **x, int **y);
        Generate a polygon somewhere inbetween the start and the end
        shapes.
    parameters:
        double time - a number between 0.0 and 1.0.  Times close to
                      zero will result in shapes similar to the start shape.
                      Times closer to one merge into the end shape.
        int *ptcount - recieves number of points in the polygon result.
        int **x      - recieves x coordinates of polygon.
        int **y      - recieves y coordinates of polygon.
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        /* Here is a do it yourself TweenTrails function: */
        AnotherTweenTrails(int steps)
        {
        int ptcount, *x, *y;    // Store the polygon here.
        double how_far;         // Somewhere between 0 and 1.
        int i;                  // Yer basic loop counter.
            ...
        steps -= 1;             // Don't make me explain this....
        for (i=0; i<=steps; ++i)
            {
            how_far = i;                // Do it this way,  not as
            how_far /= steps;           // how_far = i/steps;  (Trust me.)
            TweenMakePoly(how_far, &ptcount, &x, &y);
            Poly(ptcount, x, y);        // Draw the inbetween polygon.
            free(x); free(y);           // Free up coordinates.
            }
        }

ErrCode TweenRender(void);
        Render the tween over time.   Uses SetFSA() mode to determine
        which frames to effect.  
    parameters:
        none
    return value:
        0 on Success, or a negative error code.
        (See appendix A.)
    example:
        TweenRender();

-------------------------------------------------------------------------------
BRAND NEW FLIC LIBRARY
-------------------------------------------------------------------------------
The Flic Playback Library provides functions which play a
flic directly from disk to a screen.  Library functions
provide several levels of control during playback, including
a function that gives control back to your Poco program
between each frame.

The general sequence of function calls to play a flic
directly from disk is:

  -  Use FlicOpen() to open the file.
  -  Optionally, use FlicOptions() to tailor the playback
     behavior.
  -  Use one of the FlicPlay() functions to do the playback.
  -  Use FlicClose() to close the file.

The library contains several different FlicPlayXxxx()
functions, each of which provides different methods of
stopping the playback.

Most functions in this library use or a return a Flic * data
type.  You can think of this type as a flic handle, in the
same way that a FILE * type is a file handle.  You can
declare variables using this type; it is a built in datatype
defined within Poco.  You cannot, however, dereference the
pointer to access the data in the internal control structure
it points to.







Errcode FlicInfo(char *path, int *width, int *height, int *speed, int *frames);

     Function:      Returns information about the flic.  This function closes
                    the flic file after obtaining the information.

                                                NOTE

                    This is the only Flic Playback Library function which will
                    not abort your program if the flic file can't be opened.
                    Use this function before calling FlicOpen() if you need to
                    ensure you have a valid flic file before attempting to open
                    and play it.


     Input:         filename            The device/path/file name of the flic.

                    width                    A pointer to an int variable; if
                                             non-NULL, the variable will contain
                                             the width of the flic after the
                                             call.

                    height              A pointer to an int variable ; if non-
                                        NULL, the variable will contain the
                                        height of the flic after the call.

                    speed                    A pointer to an int variable; if
                                             non-NULL, the variable will contain
                                             the playback speed (in
                                             milliseconds-per-frame) of the flic
                                             after the call.

                    frames              A pointer to an int variable; if non-
                                        NULL, the variable will contain the
                                        number of frames in the flic after the
                                        call.

     Return Value:  Success, or a standard negative error code.







Flic    *FlicOpenInfo(char *path, int *width, int *height, int *speed, int *frames);

     Function:      Opens a flic file and prepares it for playback, and returns
                    information about the flic in the specified variables.

     Input:         filename            The device/path/file name of the flic to
                                        open for playback.

                    width                    A pointer to an int variable; if
                                             non-NULL, the variable will contain
                                             the width of the flic after the
                                             call.

                    height              A pointer to an int; if non-NULL, the
                                        variable will contain the height of the
                                        flic after the call.

                    speed                    A pointer to an int variable; if
                                             non-NULL, the variable will contain
                                             the playback speed (in
                                             milliseconds-per-frame) of the flic
                                             after the call.

                    frames              A pointer to an int variable; if non-
                                        NULL, the variable will contain the
                                        number of frames in the flic after the
                                        call.

     Return Value:  A flic handle.  Aborts your Poco program if the file can't
                    be opened properly.



Flic *FlicOpen(char *filename)

     Function:      Opens a flic file and prepares it for playback.

     Input:         filename            The device/path/file name of the flic to
                                        open for playback.

     Return Value:  A flic handle.  Aborts your Poco program if the file can't
                    be opened properly.







void    FlicClose(Flic *theflic);

     Function:      Closes a flic file opened previously via FlicOpen() or
                    FlicOpenInfo().

     Input:         pflic                    The flic handle.

     Return Value:  None.



void FlicRewind(Flic *pflic)

     Function:      Rewinds a flic to the beginning.  This does not display the
                    first frame, it just sets internal control information so
                    that the next playback call will start with the first frame.

                    This function clears the internal cur_loop counter which is
                    passed to your event detector routine when you use
                    FlicPlayUntil() for playback.

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

     Return Value:  None.






void    FlicSeekFrame(Flic *theflic, int theframe);

     Function:      Positions a flic to an arbitrary frame, regardless of
                    current position.  The specified frame is displayed on the
                    playback screen at the end of this function.

                    When the playback screen is the main (visible) screen, this
                    function allocates a RAM screen and uses it as a work area
                    during the seek.  This has the effect of displaying the
                    requested frame on the playback screen without any of the
                    intervening frames being displayed.  If allocation of the
                    RAM work screen fails, the main screen is used as the work
                    area, and intermediate frames appear briefly during the seek
                    operation.

                    Random access to widely separated frames in a flic is not a
                    particularly efficient operation.  Skipping a few frames
                    forward goes pretty quickly, but moving backwards is
                    especially time consuming.

                    This function clears the internal cur_loop counter which is
                    passed to your event detector routine when you use
                    FlicPlayUntil() for playback.

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

                    new_frame           The zero-based frame number to position
                                        to.  The value must be between zero and
                                        the number of frames in the flic,
                                        inclusive.

     Return Value:  None.


void FlicOptions(Flic *pflic, int speed, int input_stops, int see_mouse,
                    Screen *playback_screen, int xoffset, int yoffset)

     Function:      Changes options used during flic playback for a particular
                    flic.  One or more options can be changed with each call to
                    this function.

                    The speed parameter sets the playback speed, in
                    milliseconds-per-frame.  A value of -1 leaves the current
                    speed unchanged.  Initially, the playback speed is set to
                    the value in the flic file header.

                    The input_stops parameter indicates whether user input
                    (keystroke or mouse button) stops the playback.  When TRUE,
                    the internal playback routines check for user input in
                    playback function.  When FALSE user input is not checked in
                    addition to other events.  A value of -1 leaves the current
                    option unchanged.  Initially, the value of this option is
                    FALSE.

                    The see_mouse parameter indicates whether the mouse cursor
                    is visible during flic playback.  A value of FALSE hides the
                    mouse during playback; TRUE shows the mouse during playback.
                    A value of -1 leaves the current option unchanged.
                    Initially, the mouse is not visible during playback.

                    The playback_screen parameter specifies the screen to use
                    for playback.  A NULL value indicates that no change is
                    being made to the destination screen.  Any non-NULL value is
                    the handle of the playback screen.  Initially, the playback
                    screen is set to the main (visible) screen when a flic is
                    opened.

                    The xoffset and yoffset parameters specify the offset of the
                    playback within the screen, when the flic is a different
                    size than the playback screen.  If both values are zero, the
                    current offsets are not changed.  If either value is non-
                    zero, it becomes the new offset for playback.  Negative
                    offsets are allowed.

                    If you change playback_screen, xoffset, or yoffset values, a
                    FlicRewind() is done internally.

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

                    speed                    The new playback speed, or -1 to
                                             leave unchanged.

                    input_stops              TRUE, FALSE, or -1 to leave
                                             unchanged.

                    see_mouse           TRUE, FALSE, or -1 to leave unchanged.

                    playback_screen          The handle of the new playback
                                             screen, or NULL to leave unchanged.

                    xoffset             The new x playback offset, or 0 to leave
                                        unchanged.

                    yoffset             The new y playback offset, or 0 to leave
                                        unchanged.

     Return Value:  None.







void FlicPlay(Flic *pflic)

     Function:      Plays a flic until the user hits a key or mouse button.
                    Loops from the last frame back to the first as necessary.

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

     Return Value:  None.


void FlicPlayOnce(Flic *pflic)

     Function:      Plays a flic once then stops.  Playback starts at the
                    current frame, and continues through the last frame in the
                    file.

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

     Return Value:  None.


void FlicPlayCount(Flic *pflic, int frame_count)

     Function:      Plays the specified number of frames.  Playback starts at
                    the current frame, and loops from the last frame back to the
                    first as needed.

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

                    frame_count              The number of frames to play.

     Return Value:  None.


void FlicPlayTimed(Flic *pflic, int for_milliseconds)

     Function:      Plays the flic for the specified number of milliseconds.
                    Playback starts at the current frame, and loops from the
                    last frame back to the first as needed.

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

                    for_milliseconds         The number of milliseconds.

     Return Value:  None.







void FlicPlayUntil(Flic *pflic, EventFunc *pocoeventfunc, void *userdata)

     Function:      Plays the flic until your Poco event function returns FALSE.
                    Playback starts at the current frame, and loops from the
                    last frame back to the first as needed.

                    After each frame is rendered, your event function is called
                    repeatedly until it's time to display the next frame.  Your
                    function is called at least once per frame; it may be called
                    many times, depending on playback speed.  As long as your
                    event function returns TRUE, playback continues; when it
                    returns FALSE, playback ends and control returns to the
                    function that called FlicPlayUntil().

                    Define your event detector (EventFunc) as follows:

                         int anyname(Flic *pflic,
                                   void *userdata,
                                   long cur_loop,
                                   long cur_frame,
                                   long frame_count);

                    The pflic variable is the handle of the flic being played.
                    The userdata variable is the value you passed to
                    FlicPlayUntil() in the userdata parameter.  The userdata
                    value is purely for your use and may be NULL if you don't
                    need it.  The cur_loop variable is the zero-based count of
                    how many times the flic has looped from the last frame to
                    the first.  The cur_frame variable is the zero-based index
                    of the frame currently on the screen.  The frame_count
                    variable is the total number of frames in the flic.

                    Within your event detector function, you can call any Poco
                    function or library function, other than Flic Playback
                    Library functions.  The only Flic Playback Library function
                    that you can safely call from within an event detector
                    function is FlicRewind().

                    If you do a lot of processing in the event detector, it can
                    slow down flic playback.

                    POE modules can not use FlicPlayUntil().

     Input:         pflic                    A flic handle, returned from a
                                             previous call to FlicOpen().

                    pocoeventfunc       A pointer to your event detecor
                                        function.
                                        your event detector.

     Return Value:  None.



-------------------------------------------------------------------------------
NOTES ON POE LOADABLE LIBRARIES
-------------------------------------------------------------------------------
A POE loadable library is a piece of compiled 80386 code which contains
extra library functions for Poco.   If you look in your resource directory
you'll find a couple of POE loadable libraries including PSTAMP.POE, 
PDRACCESS.POE , and LOOKUP.POE.    LOOKUP.POE is used by the Poco help
facility (available by pressing F1 when inside the Poco editor),  but generally
is not useful to a Poco programmer.  The other two POE libraries are described
below.

To use a POE library you must include a line of the form
    #pragma poco library "xxx.poe"
in your poco source file.   We suggest you put these pragma lines near the
top of your source file,  before any includes.   After this you can use
a POE loadable library function just as if it were one of your own functions,
or part of one of the permanent libraries.

-------------------------------------------------------------------------------
Brand New PSTAMP LOADABLE LIBRARY
-------------------------------------------------------------------------------

To use this library put the line:
    #pragma poco library "pstamp.poe"
near the top of your source file.

          The PSTAMP POE module provides 3 related functions for
          shrinking the image on an arbitrary screen to a postage
          stamp sized image on another screen.  Two of the
          functions provide housekeeping functions to initialize
          and finalize the output screen.  The other function
          performs the actual image reduction work.

          This module was originally written to provide a
          performance boost to FLISUMRY.POC, a Poco program which
          summarizes an entire flic into a series of postage stamp
          images on a single frame or two.  Since there may be
          other good uses for a function that downscales images
          quickly, the interface to the workhorse scaling function
          was kept fairly general.

          PSTAMP uses a six-cube color palette to provide
          independence from the palette(s) of the input images. 
          The six-cube palette takes advantage of the fact that a
          reduced-size image can get away with a reduced-accuracy
          color palette while still conveying the basic information
          of the original.  A variety of input images with vastly
          different color palettes can be quickly rendered as
          postage stamp images on a single output screen.  The
          six-cube palette sacrifices some color accuracy instead
          of using the extremely time-consuming method of reducing
          all the input palettes to a single 'best fit' output
          palette.

          Any type of Animator Pro screen can be used for the input
          and output screens.  This includes the current frame of
          the flic (the picscreen), the swapscreen, the celscreen,
          or a virtual or ram-based screen created by another POE
          module.

          The source code for PSTAMP.POE is included in POEKIT.


     void InitPstampScreen(Screen *s)

          This function prepares a screen to receive postage stamp
          images.  A screen must be initialized with this function
          before it is used as the destination of a MakePstamp()
          operation.  This function creates the six-cube color
          palette and loads it into the screen's color map, and
          clears the screen to color index zero.

     Input:

          A pointer to a screen.  From Poco, this is a Screen*
          type.  From another POE module, this is any type of Rcel.


     void CleanupPstampScreen(Screen *s)

          This function releases system resources acquired by the
          InitPstampScreen() function, and indicates that you are
          done drawing postage stamp images to the screen.  You
          must call this when you are done rendering postage stamps
          on a given screen.  When the screen is the current flic
          frame (the picscreen), you must call this before moving
          to another frame in the flic.  (It is this function that
          signals to Animator Pro that the contents of the
          picscreen have been modified, and the frame needs to be
          recompressed.)

     Input:

          A pointer to a screen; the same pointer that was passed
          to the InitPstampScreen() function.


     void MakePstamp(Screen *source, Screen *dest,
                int dx, int dy, int dw, int dh, 
                Boolean draw_border)


          This function reduces the image stored in the source
          screen to a smaller image on the dest screen.  

          The entire input screen is processed; there is no way to
          specify a subset of the input screen for processing.  You
          can, of course, clip a portion of an image into the
          celscreen and then use that as input to this function. 
          Other POE modules, which have access to GFX library
          functions, may build a virtual raster over the input
          screen, and use the virtual raster as the source
          parameter to this function.  Poco programs don't have
          direct access to virtual rasters.

          The reduced size output image is placed on the dest
          screen as specified in the dx, dy, dw, and dh parameters.
           The dest screen can be of any size and type, and need
          not be the same size or type as the source screen.  

          If the draw_border parameter is non-zero (TRUE), a border
          box is drawn around the postage stamp image.  By default,
          the border box is a medium blue color.  It is drawn with
          color index 255; that index is not used by the
          six-cubecolor space.  You can change the color of palette
          slot 255 to any value you want without disturbing the
          postage stamp images.  (Change the palette after calling
          InitPstampScreen(), but before CleanupPstampScreen().)

          It is not possible to expand an image with this function.
           If the dw or dh parameters are larger than the source
          screen's width or height, the scaling is forced to 1:1
          internally for that axis.  If both dw and dh are greater
          than or equal to the source screen sizes, the net effect
          is that the image will be rendered at 1:1 scaling in a
          six-cube color space.  It is unlikely that this will
          produce desirable results.

          It is possible (but generally not useful) to change the
          aspect ratio of an image as it is scaled.  It is your
          responsibility to ensure that the aspect ratio is
          maintained by providing dw and dh values that are
          properly proportional to the source screen's width and
          height.  (That is, if the width is being reduced by a
          factor of 3, make sure the height parameter also reflects
          a 3:1 reduction.)

          The smallest legal dw, dh values are 10, 10.  (A picture
          rendered smaller than 10x10 on the destination screen is
          not likely to carry useable detail, after all.)  In
          general, the smaller the output postage stamp, the faster
          the rendering.  (A 1:1 reduction is the slowest, a 5:1
          (or more) reduction screams right along.)

     Input:

          The source parameter is a pointer to the input screen. 
          The dest parameter is a pointer to the output screen. 
          The dx and dy parameters specify the x,y location of the
          upper left corner of the postage stamp image on the




          output screen.  The dw and dh parameters specify the
          width and height of the postage stamp image on the output
          screen.  The draw_border parameter, when non-zero, causes
          a bordering box to be drawn around the dx, dy, dw, dh
          coordinates of the output screen.


-------------------------------------------------------------------------------
Brand New PDRACCES LOADABLE LIBRARY
-------------------------------------------------------------------------------


          The PDRACCES POE module provides a set of functions for
          accessing the full capabilities of a picture driver (PDR)
          module.  This gives you more control over loading and 
          saving pictures than LoadPic() and SavePic() provide.
          Animator Pro has direct support for the basic
          PDR operations.  The ANICONV image conversion program
          contains support for extended PDR operations, including
          RGB input, and prompting of the user for output options. 
          The PDRACCES POE module provides access to the extended
          PDR operations from within Animator Pro.


          PDRACCES contains a built in table which maps file types
          to the PDR that handles that type.  (The file type is
          based on the name of the file.)  When you use the
          PicSave() and PicLoad() functions, PDRACCES automatically
          searches this table and loads the appropriate PDR module
          (unless a PDR was pre-loaded with PicDriverLoad()).  The
          following table shows the built in relationships between
          filetypes and PDR modules:

              File Type    Picture Driver
               .GIF           GIF.PDR
               .PCX           PCX.PDR
               .TIF           TIFF.PDR
               .TGA           TARGA.PDR
               .LBM           LBM.PDR
               .RIF           RIF.PDR
               .MAC           MAC.PDR
               .NEO           NEO.PDR
               .PI? .PC?      DEGAS.PDR
               .SLD           SLD.PDR
               .ANI           ANIM.PDR
               .PCT           PICT.PDR
               .BMP .RLE      BMP.PDR
               .MOV           MOV.PDR
               .RND           RND.PDR

          Two versions of this POE module exist.  PDRACCES is the
          full version, PDRDEMO is an abbreviated version that
          doesn't contain the RGB input support.  The source code
          for PDRDEMO is included in the POEKIT development
          package, but the RGB processing code is proprietary, and
          the full PDRACCES source code cannot be distributed.


     void PicDriverUnload(void)

          This function unloads the currently-loaded picture driver
          module (if any).  This function can be called any
          numberof times, even if a picture driver isn't currently
          loaded.


     Errcode PicDriverLoad(char *pdrname)





          This function loads the named picture driver module.  The
          picture driver is always loaded from the Ani Pro resource
          directory.  This means that the name specified by
          *pdrname must not contain any drive or path information.

          You may not need to use this function.  The PicSave() and
          PicLoad() functions attempt to find and load the proper
          PDR module (based on the filetype) automatically.  You
          can, however, pre-load a PDR module to sidestep the
          automatic search and force a given file format regardless
          of the filetype contained in the filename.

          You must use this function to work with a PDR not
          contained in the table (above) that maps filetypes to PDR
          names.

          If another PDR is already loaded when this function is
          called, it is unloaded automatically.

     Input:

          The pdrname parameter is a pointer to a string which
          names the PDR module to load.  The filetype (.PDR,
          generally) must appear in the name.

     Output:

          Success (0) if the PDR was loaded, or an appropriate
          negative Errcode value.

     Example:
            PicDriverLoad("TIFF.PDR");


     Errcode PicDriverFindLoad(char *picpath)

          This function finds the PDR associated with the specified
          file and loads it.  This is analogous to the action taken
          automatically by the PicSave() and PicLoad() functions.

          This function can be useful if you anticipate loading or
          saving a series of pictures of the same type.  By
          pre-loading, you eliminate the overhead of loading and
          unloading the PDR on each PicSave() or PicLoad() call.

          If another PDR is already loaded when this function is
          called, it is unloaded automatically.

     Input:

          The picpath parameter is a pointer to a string,
          ostensibly a filename.  The filetype at the end of the
          string is used in the table lookup which associates
          filetypes with PDR modules.

     Output:

          Success (0) if the PDR was loaded, or an appropriate
          negative Errcode value.

     Example:
         Errcode PicDriverFindLoad("atari.neo")


     Boolean PicPdrHasOptions(void)

          This function determines whether the currently-loaded PDR
          module has output options.  Call this only when you know
          a PDR module is currently loaded.

     Output:

          TRUE if the currently-loaded PDR has output options,
          FALSE if it does not.  Your Poco program will abort if
          there is no currently-loaded PDR.


     long PicPdrOptionsPreset(Boolean do_dialog, long options)

          This function pre-sets the output options for the
          currently-loaded PDR.  

          PDR output options are specific to any given PDR module. 
          The PDR itself contains the dialogs used to get the
          options from the user.  Not all PDR modules support
          output options; the PicPdrHasOptions() function
          determines whether a given PDR supports output options.

          If the do_dialog parameter is TRUE, the output options
          dialogs are conducted, and the options are pre-set based
          on the user's selections.  The user's selections are also
          returned as four bytes (one per option) packed into a
          longword.  When the do_dialog parameter is TRUE, the
          options parameter is ignored.

          If the do_dialog parameter is FALSE, the PDR's output
          options are pre-set to the contents of the options
          parameter.  The options parameter contains four options
          values, one byte per value, packed into a longword.

          When a PDR supports output options, and the options have
          not been pre-set, the PicSave() function automatically
          conducts the options dialogs with the user.  If you
          wantto save a series of images using the same options,
          this function provides a method a specifying the options
          just once, rather than prompting the user for the options
          on each PicSave() call.  Use a sequence such as:

            -  call PicDriverLoad() or PicDriverFindLoad().
            -  call PicPdrHasOptions() to see if the PDR supports
               any output options.
            -  if the PDR has options, call
               PicPdrOptionsPreset(TRUE, 0).
            -  call PicSave() repeatedly.
            -  call PicDriverUnload() when done.

          You can also call this function with the do_dialog
          parameter TRUE and save the return value.  Then you can
          pass this return value later with a do_dialog parameter
          of FALSE to reestablish the same options without
          conducting the dialogs again.  This can be useful for
          gathering the user's options interactively and then
          writing a 'script' Poco program to run later in a
          non-interactive batch mode.

          When a new PDR is loaded, all pre-set PDR options are
          cleared.

     Input:
          The do_dialog parameter, when non-zero, indicates that
          the user is to be prompted for output options.  When
          zero, it indicates that the options parameter is to be
          used to pre-set the output options without user
          interaction.  The options parameter is a 32-bit value
          returned by a prior call to this function.

     Output:

          A longword which contains an encoded form of the options
          selected by the user.  If there is no currently-loaded
          PDR when this function is called, your Poco program will
          abort.


     long PicRgbOptionsPreset(Boolean do_dialog, long options)

          This function pre-sets the RGB input processing options. 

          Unlike PDR output options, which are specific to a given
          PDR module, the RGB input options dictate options taken
          by PDRACCES.POE when an RGB input file is encountered.
          They are applicable to all PDR modules which support RGB
          input, and the dialog presented to the user is always the
          same, regardless of the currently-loaded PDR.
          The RGB input options dictate how PDRACCES handles the
          conversion of RGB data to color-mapped format is done. 
          Currently, PDRACCES supports the following conversions:

            -  Load color approximation.  This converts the RGB
               pixels to a six-cube color space.  The conversion is
               very fast, but not at all accurate.  This method is
               appropriate for a 'preview' of the picture.

            -  Load grayscale.  This converts the RGB pixels to a
               256-level grayscale color map.  The conversion is
               very fast, and fairly accurate.  The RGB colors are
               mapped to grey via simple averaging: (r+g+b)/3.

            -  Load 64-level color.  This converts the RGB pixels
               to a 'best fit' color map which is constructed
               dynamically.  Because many SuperVGA cards only
               support 64 levels of each color red, green, and blue
               color component, this is often the best option for
               accurate conversion.

            -  Load 256-level color.  This is similar to 64-level
               color conversion, except that 256 levels of each
               color component are supported.  This is slower than
               the 64-level conversion, but gives much better
               results when the graphics hardware supports
               256-level color components (ie, 8 bit DACs).  This
               method requires that approximately 2.5mb of memory
               be free at the time of the PicLoad() call.

            -  Dithering.  This is a TRUE/FALSE option which
               modifies the 64- and 256-level color conversions to
               apply a simple error-correction dithering.  The
               dithering slows down the conversion, but often
               yields better results, especially with the 64-level
               method.





          If the do_dialog parameter is TRUE, the RGB input options
          dialog is conducted, and the options are pre-set based on
          the user's selections.  The user's selections are also
          returned as four bytes (one per option) packed into a
          longword.  When the do_dialog parameter is TRUE, the
          options parameter is ignored.

          If the do_dialog parameter is FALSE, the RGB input
          options are pre-set to the contents of the options
          parameter.  The options parameter contains several
          values, one byte per value, packed into a longword.

          When an RGB image is encountered, and RGB input options
          have not been pre-set, the PicLoad() function
          automatically conducts the options dialogs with the user.
          If you want to load a series of images using the same
          options, this function provides a method a specifying the
          options just once, rather than prompting the user for the
          options on each PicLoad() call.  Simply call this
          function before calling PicLoad() for the first time. 
          The options will remain in effect until your Poco program
          ends, or you explicitly clear them with a call to
          PicRgbOptionsClear().  

          You can also call this function with the do_dialog
          parameter TRUE and save the return value.  Then you can
          pass this return value later with a do_dialog parameter
          of FALSE to reestablish the same options without
          conducting the dialogs again.  This can be useful for
          gathering the user's options interactively and then
          writing a 'script' Poco program to run later in a
          non-interactive batch mode.

          When a new PDR is loaded, pre-set RGB options are not
          cleared.

     Input:

          The do_dialog parameter, when non-zero, indicates that
          the user is to be prompted for output options.  When
          zero, it indicates that the options parameter is to be
          used to pre-set the output options without user
          interaction.  The options parameter is a 32-bit value
          returned by a prior call to this function.

     Output:

          A longword which contains an encoded form of the options
          selected by the user.


     void PicPdrOptionsClear(void)

          This function clears any PDR output options for the
          currently-loaded PDR.  It can be called any number of
          times, even if options were not previously pre-set.  

          PDR options are also cleared automatically whenever a new
          PDR module is loaded.

     void PicRgbOptionsClear(void)





          This function clears any RGB input options for the
          currently-loaded PDR.  It can be called any number of
          times, even if options were not previously pre-set.

          RGB options are not cleared automatically when a new PDR
          module is loaded; RGB options are not PDR-specific.


     Errcode PicGetSize(char *path, int *width, int *height, int
          *depth)

          This function returns information about the specified
          picture file.  As with PicLoad(), this function first
          attempts to use the currently-loaded PDR (if any) to read
          the picture file, and if that fails, it will unload the
          current PDR and load on that can handle the picture
          format.  It chooses a PDR based on the filetype at the
          end of *path, as per the table above.

     Input:

          The path parameter is a pointer to a filename (device
          and/or path info is optional) on which information is to
          be returned.  The width, height, and depth parameters are
          pointers to 32-bit integers; the picture information is
          returned into the locations these parameters point to.

     Output:

          Success (0) if the information is returned, or an
          appropriate negative Errcode value.  After the call, the
          memory locations at *width, *height, and *depth contain
          the picture information.  The depth value is in bits; a
          value greater than 8 indicates the picture file contains
          RGB data.


     Errcode PicLoad(char *path, Screen *screen)

          This function loads a picture from disk into the
          specified screen.  Its behavior is different from the
          built in library LoadPic() function, in that it can
          process RGB input data.

          If a PDR has been pre-loaded, this function attempts to
          use that PDR to load the picture.  If there is no
          pre-loaded PDR, or if the pre-loaded PDR fails to process
          the picture, the filetype-to-PDR mapping table is used to
          load the proper PDR for the picture file type.  If the
          filetype is not in the mapping table, or if the picture
          still can't be loaded, this function returns the error
          status reported by the PDR.  Whenever this function
          returns an error status, you must assume that there is no
          longer a currently-loaded PDR, even if you pre-loaded one
          earlier.

          This function handles RGB input images.  If the RGB input
          options have been pre-set with PicRgbOptionsPreset(),
          those options are applied without user interaction.  If
          the options have not been pre-set, the user is prompted
          for the processing options.





          When the picture is not the same size as the destination
          screen, it is automatically centered within the screen,
          and clipped around the edges as needed.

     Input:

          The path parameter is a pointer to a string which
          contains the filename to load.  The filename can include
          drive and path information.  The screen parameter is a
          handle for the screen into which the picture is loaded. 
          The screen parameter can be NULL, indicating that the
          destination is the main picscreen.

     Output:

          Success (0), or an appropriate negative Errcode value. 


     Errcode PicSave(char *path, Screen *screen)

          This function saves the contents of the specified screen
          to a file.  Its behavior is different from the built in
          library SavePic() function, in that it can process output
          options if the PDR supports them.

          If a PDR has been pre-loaded, it is used to save the
          picture.  If there is no pre-loaded PDR, one will be
          loaded, based on the filetype-to-PDR mapping table. 

          Unlike the PicLoad() routine, this function has no
          automatic retry logic.  If the pre-loaded PDR fails to
          save the picture, the PDR remains loaded, and the error
          status is returned.

          If the PDR supports output options, and the options have
          been pre-set using PicPdrOptionsPreset(), the picture is
          saved without user interaction.  If the output options
          have not been pre-set, the user is prompted for options.

          The picture is always saved using the width & height of
          the specified screen.

     Input:

          The path parameter is a pointer to a string which
          contains the filename to save.  The filename can
          includedrive and path information.  The screen parameter
          is a handle for the screen from which the picture is
          saved.  The screen parameter can be NULL, indicating that
          the source is the main picscreen.

     Output:

          Success (0), or an appropriate negative Errcode value. 

     VSCREEN.POE


          The VSCREEN POE provides several functions for
          manipulating virtual screens.  A virtual screen is a
          rectangular portion of another screen, referred to as the




          root screen.  The virtual screen can describe a
          rectangular portion which is either smaller or larger
          than the root screen.  When the virtual screen is larger
          than the root, clipping I/O routines are automatically
          used to access the virtual screen pixels.

          Several built in and POE-based functions operate on an
          entire screen of data, and have no provision for
          specifying a subset rectangle for processing.  You can
          create a virtual screen that maps a rectangular subset of
          a screen, and then pass the virtual screen handle to the
          function.  This gives the effect of operating on a subset
          of the root screen.


     Screen *MakeCenteredScreen(Screen *root, int w, int h)

          This function builds a virtual screen which is centered
          over or within the root screen.  

          When the specified sizes for the virtual screen are
          smaller than the root screen, the virtual screen is in
          effect a window within the root.  The window is centered
          in each axis within the root.  Write operations outside
          the virtual screen's boundaries are clipped (not
          performed at all), and read operations return zeroes for
          pixels outside the virtual screen's boundaries.

          When the specified virtual screen sizes are larger than
          the root screen's sizes, the larger virtual screen is
          centered over the root screen in each axis.  Write
          operations outside the root screen's boundaries are
          clipped, and read operations outside the root boundaries
          return zeroes.

          The virtual screen will be deleted automatically when
          your Poco program ends.  You cannot allocate a virtual
          screen in one program and refer to it in another.

     Input:

          The root parameter is a screen handle.  It can refer to
          any type of screen, including another virtual screen. 
          The w and h parameters contain the sizes for the new
          virtual screen; they must be greater than zero.
     Output:

          A handle to the virtual screen.  This will never be NULL;
          the only error that can happen is an out-of-memory
          condition, and that will abort the Poco program
          automatically.


     void FreeCenteredScreen(Screen *vscreen)

          This function frees a virtual screen allocated by
          MakeCenteredScreen().

     Input:

          The vscreen parameter is the handle of a screen
          previously created by MakeCenteredScreen().






     Screen *MakeVirtualScreen(Screen *root, int x, int y, int w,
          int h)

          This function builds a virtual screen at an arbitrary
          offset over or within the root screen.  This function is
          similar to MakeCenteredScreen() in all ways, except that
          instead of centering the virtual screen, this function
          places the virtual screen at the x/y offset you specify. 

          Negative x/y values are legal.

     Input:

          The root parameter is a screen handle.  It can refer to
          any type of screen, including another virtual screen. 
          The x and y parameters specify the placement of the upper
          left corner of the virtual screen, relative to the root
          screen.  The w and h parameters contain the sizes for the
          new virtual screen; they must be greater than 0.

     Output:

          A handle to the virtual screen.  This will never be NULL;
          the only error that can happen is an out-of-memory
          condition, and that will abort the Poco program
          automatically.


     void FreeVirtualScreen(Screen *vscreen)

          This function frees a virtual screen allocated by
          MakeVirtualScreen().

     Input:

          The vscreen parameter is the handle of a screen
          previously created by MakeVirtualScreen().

