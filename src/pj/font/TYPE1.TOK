/*

		Read and decrypt an Adobe Type 1 font.
		This code was written originally by John Walker
		using the _Adobe Type 1 Font Format 1.1_ published
		by Addison-Wesley ISBN 0-201-57044-0 as a guide.

		Jim Kent changed it a fair amount,  reformatting the
		indentation and renaming some of the identifiers to
		mix with the local style;  making the output go through
		functions embedded in a structure so the same interpreter 
		could be used for both sizing and drawing the font,  and
		putting in stuff to glue it into Animator Pro's font
		manager.

		There are four main sections to this file set apart with
		long comment blocks.  One reads the font into memory.
		The second interprets the font language.  The third is concerned
		with directing the output of the interpreter into a form
		useful for PJ.  The final bit is the glue into the PJ
		virtual font system.

*/

#include <string.h>
#include <ctype.h>
#include <math.h>
#include <limits.h>
#include <setjmp.h>
#include "lstdio.h"
#include "token.h"
#include "pjbasics.h"
#include "rastext.h"
#include "fontdev.h"
#include "blockall.h"
#include "render.h"
#include "sdot.h"
#include "linklist.h"
#include "type1.h"


#define EOS     '\0'

#define X   0
#define Y   1

void calc_font_bounds(Type1_font *tcd);
static void free_scale_info(Type1_scale_info *si);

/*********DEBUGGING STUFF********/
FILE *debug_log;

open_debug_log()
{
	if (debug_log == NULL)
		debug_log = fopen("H:\\debug.log", "w");
}

dlog(char *fmt, ...)
/* Printf to debug file. */
{
va_list argptr;

open_debug_log();
va_start(argptr, fmt);
vfprintf(debug_log,fmt,argptr);
va_end(argptr);
fflush(debug_log);
}


/*****************************************************************************
 *****************************************************************************
 ** The Load Section.  A PostScript Type 1 file is composed of a list of
 ** definitions.  Each definition is a keyword followed by data.  
 ** At the start of the file are a bunch of definitions that are about the
 ** font as a whole.  Then we come to the individual letters,   which are
 ** encrypted and in their own little RPN language.
 **
 ** The load section is concerned with verifying that the file is indeed
 ** a PostScript Type 1,  extracting a few interesting things (including
 ** the full font name) from the pre-letter definitions,  and then decrypting
 ** the individual letters and the subroutines they use and sticking them 
 ** in a couple of arrays for later access.
 *****************************************************************************
 ****************************************************************************/

/*****************************************************************************
 * Let's handle errors (not enough memory, bad data in file, etc.) during
 * reading with a setjmp/longjmp.  The longjmp destination will be the
 * highest level read routine (read_font).
 ****************************************************************************/
static jmp_buf type1_load_errhandler; /* Jump buffer for load errors.	*/

static void type1_load_error(char *fmt, ...)
/*
 * format & output an error message, then longjump to error handler.
 */
{
char	sbuf[512];
va_list args;

va_start(args, fmt);
varg_continu_box(NULL,fmt,args,NULL);
va_end(args);
longjmp(type1_load_errhandler, Err_reported);
}


static enum {Unknown, Binary, Hex} filemode = Unknown, forcemode = Unknown;

/*  Sections of the font file.  */
typedef enum { Header, FontInfo, OtherSubrs, Subrs, CharStrings } file_section;
static file_section section;


/*  Map of PostScript character names to ISO 8859-1 Latin 1  */

#define MAP_SIZE 256

static char *isomap[MAP_SIZE] = {
	NULL,				 /*  00 */
	NULL,				 /*  01 */
	NULL,				 /*  02 */
	NULL,				 /*  03 */
	NULL,				 /*  04 */
	NULL,				 /*  05 */
	NULL,				 /*  06 */
	NULL,				 /*  07 */
	NULL,				 /*  08 */
	NULL,				 /*  09 */
	NULL,				 /*  10 */
	NULL,				 /*  11 */
	NULL,				 /*  12 */
	NULL,				 /*  13 */
	NULL,				 /*  14 */
	NULL,				 /*  15 */
	NULL,				 /*  16 */
	NULL,				 /*  17 */
	NULL,				 /*  18 */
	NULL,				 /*  19 */
	NULL,				 /*  20 */
	NULL,				 /*  21 */
	NULL,				 /*  22 */
	NULL,				 /*  23 */
	NULL,				 /*  24 */
	NULL,				 /*  25 */
	NULL,				 /*  26 */
	NULL,				 /*  27 */
	NULL,				 /*  28 */
	NULL,				 /*  29 */
	NULL,				 /*  30 */
	NULL,				 /*  31 */
    "space",             /*  32 */
    "exclam",            /*  33 */
    "quotedbl",          /*  34 */
    "numbersign",        /*  35 */
    "dollar",            /*  36 */
    "percent",           /*  37 */
    "ampersand",         /*  38 */
    "quoteright",        /*  39 */
    "parenleft",         /*  40 */
    "parenright",        /*  41 */
    "asterisk",          /*  42 */
    "plus",              /*  43 */
    "comma",             /*  44 */
    "hyphen",            /*  45 */
    "period",            /*  46 */
    "slash",             /*  47 */
    "zero",              /*  48 */
    "one",               /*  49 */
    "two",               /*  50 */
    "three",             /*  51 */
    "four",              /*  52 */
    "five",              /*  53 */
    "six",               /*  54 */
    "seven",             /*  55 */
    "eight",             /*  56 */
    "nine",              /*  57 */
    "colon",             /*  58 */
    "semicolon",         /*  59 */
    "less",              /*  60 */
    "equal",             /*  61 */
	"greater",           /*  62 */
    "question",          /*  63 */
    "at",                /*  64 */
    "A",                 /*  65 */
    "B",                 /*  66 */
    "C",                 /*  67 */
    "D",                 /*  68 */
    "E",                 /*  69 */
    "F",                 /*  70 */
    "G",                 /*  71 */
    "H",                 /*  72 */
    "I",                 /*  73 */
    "J",                 /*  74 */
    "K",                 /*  75 */
    "L",                 /*  76 */
    "M",                 /*  77 */
    "N",                 /*  78 */
    "O",                 /*  79 */
    "P",                 /*  80 */
    "Q",                 /*  81 */
    "R",                 /*  82 */
    "S",                 /*  83 */
    "T",                 /*  84 */
    "U",                 /*  85 */
    "V",                 /*  86 */
    "W",                 /*  87 */
    "X",                 /*  88 */
    "Y",                 /*  89 */
    "Z",                 /*  90 */
    "bracketleft",       /*  91 */
    "backslash",         /*  92 */
    "bracketright",      /*  93 */
    "asciicircum",       /*  94 */
    "underscore",        /*  95 */
    "grave",             /*  96 */
	"a",                 /*  97 */
    "b",                 /*  98 */
    "c",                 /*  99 */
    "d",                 /* 100 */
    "e",                 /* 101 */
    "f",                 /* 102 */
    "g",                 /* 103 */
    "h",                 /* 104 */
    "i",                 /* 105 */
    "j",                 /* 106 */
    "k",                 /* 107 */
    "l",                 /* 108 */
    "m",                 /* 109 */
    "n",                 /* 110 */
    "o",                 /* 111 */
    "p",                 /* 112 */
    "q",                 /* 113 */
    "r",                 /* 114 */
    "s",                 /* 115 */
    "t",                 /* 116 */
    "u",                 /* 117 */
    "v",                 /* 118 */
    "w",                 /* 119 */
    "x",                 /* 120 */
    "y",                 /* 121 */
    "z",                 /* 122 */
    "braceleft",         /* 123 */
    "bar",               /* 124 */
    "braceright",        /* 125 */
    "asciitilde",        /* 126 */
    NULL,            /* 127 */
    "Ccedilla",            /* 128 */
    "uumlaut",            /* 129 */
    "eacute",            /* 130 */
    "acircumflex",               /* 131 */
	"aumlaut",           /* 132 */
    "agrave",            /* 133 */
    "aring",             /* 134 */
    "ccedilla",          /* 135 */
    "ecircumflex",               /* 136 */
    "eumlaut",           /* 137 */
    "egrave",            /* 138 */
    "iumlaut",           /* 139 */
    "icircumflex",               /* 140 */
    "igrave",            /* 141 */
    "Aumlaut",           /* 142 */
    "Aring",             /* 143 */
    "Eacute",            /* 144 */
    "ae",            /* 145 */
    "AE",        /* 146 */
    "ocircumflex",               /* 147 */
    "oumlaut",           /* 148 */
    "ograve",            /* 149 */
    "ucircumflex",               /* 150 */
    "ugrave",            /* 151 */
    "yumlaut",           /* 152 */
    "Oumlaut",           /* 153 */
    "Uumlaut",           /* 154 */
    "cent",              /* 155 */
    "sterling",          /* 156 */
    "yen",               /* 157 */
    NULL,                /* 158 */
    NULL,                /* 159 */
    "aacute",             /* 160 */
    "iacute",        /* 161 */
    "oacute",              /* 162 */
    "uacute",          /* 163 */
    "ntilde",          /* 164 */
    "Ntilde",               /* 165 */
    NULL,               /* 166 */
	NULL,           /* 167 */
    "questiondown",          /* 168 */
    NULL,         /* 169 */
    NULL,       /* 170 */
    "onehalf",     /* 171 */
    "onequarter",        /* 172 */
    "exclamdown",             /* 173 */
    NULL,        /* 174 */
    NULL,            /* 175 */
    NULL,              /* 176 */
    NULL,         /* 177 */
    NULL,       /* 178 */
    NULL,     /* 179 */
    NULL,             /* 180 */
    NULL,                /* 181 */
    NULL,         /* 182 */
    NULL,    /* 183 */
    NULL,           /* 184 */
    NULL,       /* 185 */
    NULL,      /* 186 */
    NULL,    /* 187 */
    NULL,        /* 188 */
    NULL,           /* 189 */
    NULL,     /* 190 */
    NULL,      /* 191 */
    NULL,            /* 192 */
    NULL,            /* 193 */
    NULL,       /* 194 */
    NULL,            /* 195 */
    NULL,         /* 196 */
    NULL,             /* 197 */
    NULL,                /* 198 */
    NULL,          /* 199 */
    NULL,            /* 200 */
    NULL,            /* 201 */
	NULL,       /* 202 */
    NULL,         /* 203 */
    NULL,            /* 204 */
    NULL,            /* 205 */
    NULL,       /* 206 */
    NULL,         /* 207 */
    NULL,               /* 208 */
    NULL,            /* 209 */
    NULL,            /* 210 */
    NULL,            /* 211 */
    NULL,       /* 212 */
    NULL,            /* 213 */
    NULL,         /* 214 */
    NULL,          /* 215 */
    NULL,            /* 216 */
    NULL,            /* 217 */
    NULL,            /* 218 */
    NULL,       /* 219 */
    NULL,         /* 220 */
    NULL,            /* 221 */
    NULL,             /* 222 */
    NULL,        /* 223 */
    "alpha",            /* 224 */
    "beta",            /* 225 */
    "gamma",       /* 226 */
    "pi",            /* 227 */
    "Sigma",         /* 228 */
    "sigma",             /* 229 */
    "mu",                /* 230 */
    "tau",          /* 231 */
    "Phi",            /* 232 */
    "theta",            /* 233 */
    "omega",       /* 234 */
    "delta",         /* 235 */
    "infinity",            /* 236 */
	"phi",            /* 237 */
    "epsilon",       /* 238 */
    NULL,         /* 239 */
    NULL,               /* 240 */
    "plusminus",            /* 241 */
    NULL,            /* 242 */
    NULL,            /* 243 */
    NULL,       /* 244 */
    NULL,            /* 245 */
    "divide",         /* 246 */
    NULL,            /* 247 */
    "degree",            /* 248 */
    NULL,            /* 249 */
    "bullet",            /* 250 */
    NULL,       /* 251 */
    NULL,         /* 252 */
    "twosuperior",            /* 253 */
    NULL,             /* 254 */
    NULL          /* 255 */
};




static void *loader_alloc(Type1_font *tcd, unsigned nbytes)
/* Alloc some memory for loader.  Bail out if can't. */
{
	char *cp;

	if ((cp = alloc_from_block(&tcd->font_ba, nbytes)) == NULL) {
		type1_load_error("Out of memory.  Couldn't find %d bytes", nbytes);
	}
	return (void *) cp;
}



static char *loader_strdup(Type1_font *tcd, char *s)
/*  STRSAVE  --  Allocate a duplicate of a string.  */
{
	char *c = loader_alloc(tcd, (unsigned) (strlen(s) + 1));

	strcpy(c, s);
	return c;
}


/*****************************************************************************
 * File input.
 ****************************************************************************/

static int byte_in(FILE *fp)
/*  INBYTE  --  Get the next binary byte from the file, either in
				hexadecimal or binary mode. */
{
    int c, xd = 0, i;

    for (i = 0; i < 2; i++) {
		for (;;) {
			c = getc(fp);
			if (filemode == Binary || c == EOF)
                return c;
            if (isspace(c))
                continue;
            break;
        }
		if (islower(c))
			c = toupper(c);
        if (c >= '0' && c <= '9') {
            c -= '0';
		} else if (c >= 'A' && c <= 'F') {
            c = (c - 'A') + 10;
		} else {
            type1_load_error("Bad hex digit\n");
            return EOF;
        }
        xd = (xd << 4) | c;
    }
    return xd;
}


static int line_in( FILE *fp, char *line, int maxlen)
/*  INLINE  --  Read a line from the file, delimited by any of the
                end of line sequences. */
{
    char *lp = line;

    while (--maxlen > 0) 
		{
        int ch = getc(fp);

        if (ch == '\r' || ch == '\n') 
			{
            char cn = getc(fp);
            if (!((ch == '\r' && cn == '\n') || (ch == '\n' && cn == '\r'))) 
				{
                ungetc(cn, fp);
	            }
            *lp = EOS;
            return TRUE;
	        }

        if (ch == EOF) 
			{
			if (lp != line)
				{
				*lp = EOS;
                return TRUE;
				}
			return FALSE;
	        }
        *lp++ = ch;
	    }
		type1_load_error("Line too long.");
		return FALSE;
}

/*****************************************************************************
 *  DECRYPT  --  Perform running decryption of file.  
 ****************************************************************************/

static unsigned short int cryptR, cryptC1, cryptC2, cryptCSR;

static void crypt_init( unsigned int key)
{
	cryptR = key;
    cryptC1 = 52845;
    cryptC2 = 22719;
}

static unsigned int decrypt(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptR >> 8));

    cryptR = (cipher + cryptR) * cryptC1 + cryptC2;
	return plain;
}

static void cstrinit(void)
{
    cryptCSR = 4330;
}

static unsigned int decstr(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptCSR >> 8));

    cryptCSR = (cipher + cryptCSR) * cryptC1 + cryptC2;
    return plain;
}

/*****************************************************************************
 *  PARSER  --  Chop up file a line at a time and decide what to put where...
 ****************************************************************************/


static void process_definition(Type1_font *tcd, char *t)
/*  PROCESS_DEFINITION  --  Blunder through the font by stumbling over
                            key defining words.  */
{
if (strcmp(t, "FontInfo") == 0) 
	{
	section = FontInfo;
	} 
else if (strcmp(t, "OtherSubrs") == 0) 
	{
	section = OtherSubrs;
    } 
else if (strcmp(t, "Subrs") == 0) 
	{
	section = Subrs;
    } 
else if (strcmp(t, "CharStrings") == 0) 
	{
	section = CharStrings;
    } 
else
	{
	switch (section) 
	  {
	  case CharStrings:
		if (tcd->def_count >= (NCdefs - 1)) 
			{
			type1_load_error("\nToo many CharString definitions.\n");
			}
		else 
			{
			/* Save char name */
			tcd->letter_names[tcd->def_count] =	loader_strdup(tcd,t);
			/* Clear definition */
			tcd->letter_defs[tcd->def_count++] = NULL;       
            }
		break;
	  default:
		break;
      }
    }
}

typedef enum 
	{
	TTT_EOF,
	TTT_NAME,
	TTT_NUMBER,
	TTT_OTHER,
	TTT_TOO_LONG,
	} T1_token_type;

typedef struct
	{
	T1_token_type type;
	char string[256];
	int pushback;
	FILE *file;
	int (*source)(FILE *f);
	} Type1_token;

void type1_token_init(Type1_token *tok, FILE *file, int (*source)(FILE *f))
{
	clear_struct(tok);
	tok->file = f;
	tok->source = source;
}


static Boolean continue_number(int ch)
/* Return true if character is a digit */
{
	return isdigit(ch);
}

static Boolean continue_name(int ch)
/* Return true if character can be the second or further character in 
 * a name. */
{
	return ch == '_' || isalnum(ch);
}

void _type1_get_token(Type1_token token)
/* Read in a token from file and categorize it. 
 * In this case a token is a run of numbers, a letter followed by 
 * letters and numbers, or a single non-alpha-numeric character.  
 * White space serves to separate tokens but is otherwise skipped. 
 * Pass in a "source" function to get next character from file. */
{
	int ch;
	int size = 0;
	T1_token_type retval;
	Boolean (*get_next)(int ch);
	int tok_len = sizeof(token->string);
	char *string = token->string;

	/* Get pushed-back character if any. */
	if (token->pushback == 0)
		ch = token->source(token->file);
	else
		{
		ch = token->pushback;
		token->pushback = 0;
		}
	/* Skip leading spaces. */
	for (;;)
		{
		if (ch == EOF)
			return TTT_EOF;
		if (!isspace(ch))
			break;
		ch = token->source(token->file);
		}
	if (isdigit(ch))
		{
		get_next = continue_number;
		token->type = TTT_NUMBER;
		}
	else if (ch == '_' || isalpha(ch))
		{
		get_next = continue_name;
		token->type = TTT_NAME;
		}
	else
		{
		*string++ = ch;
		*string = 0;
		token->type = TTT_OTHER;
		return;
		}
	for (;;)
		{
		if (--tok_len <= 0)
			{
			token->type = TTT_TOO_LONG;
			return;
			}
		*string++ = ch;
		ch = token->source(token->file);
		if (!(*get_next)(ch))
			{
			token->pushback = ch;
			*string = EOS;
			return;
			}
		}
}

void type1_get_token(Type1_token *tok)
{

	_type1_get_token(tok);
	switch (tok->type)
		{
		case TTT_EOF:
			dlog("<eof>\n");
			break;
		case TTT_TOO_LONG:
			dlog("<too long>\n");
			break;
		default:
			dlog("\t%s\n", tok->string);
			break;
		}
}

Errcode type1_check_signature(FILE *fp)
/* This just verifies that the font begins with %!FontType1 or
 * %!PS-AdobeFont-1.0.  We expect this in the first 128 bytes. */
{
	int ch;
	int i;
	char buf[80];
	static char magic1[16] = "PS-AdobeFont-1.0";
	static char magic2[9] = "FontType1";

	for (i=0; i<128; ++i)
		{
		ch = getc(fp);
		if (ch == EOF)
			break;
		if (ch == '%') 
			{
			ch = getc(fp);
            if (ch == EOF)
				break;
            if (ch == '!')
				{
				if (fgets(buf, sizeof(buf), fp) == NULL)
					break;
				if (strncmp(buf, magic1, sizeof(magic1)) == 0
				||	strncmp(buf, magic2, sizeof(magic2)) == 0)
					return Success;
				}
	        }
		}
	return Err_bad_magic;
}

Errcode type1_read_to_eexec(Type1_font *tcd, Type1_token *tok)
/*****************************************************************************
 * Read in unencrypted header.  Stops at the eexec statement.
 ****************************************************************************/
{
	for (;;)
		{
		type1_get_token(&tok);
		switch (tok->type)
			{
			case TTT_EOF:
				return Err_truncated;
			case TTT_OTHER:
				if (tok->string[0] == '/')
					process_header_definition(tcd, tok);
				break;
			case TTT_NAME:
				if (strcmp(tok->string, "eexec") == 0)
					return Success;
				break;
			default:
				break;
			}
		}
}

Errcode rtype1(Type1_font *tcd, FILE *fp)
/*  RTYPE1  --  Load a type 1 font into memory.  */
{
    char line_buf[256], token[256], ltoken[256], stoken[256], ptoken[256];
	char *linept = NULL;
	char *tmp;
    char *tokenp;
	int pushback;
	char cs[4];
    int i, ic, inEncoding = FALSE;
	long encrypt_start;
	Errcode err;
	int ttype;
	Type1_token tok;

	tcd->char_map = isomap;              		/* Active mapping vector */
	tcd->def_count = 0;
	tcd->sub_count = 0;
    tcd->subrs = NULL;
	section = Header;
    tcd->full_name[0] = ptoken[0] = stoken[0] = ltoken[0] = token[0] = EOS;

	if ((err = type1_check_signature(fp)) < Success)
		{
		type1_load_error("Couldn't find %!FontType1 signature");
		return Err_not_found;
		}

	for (;;)
		{
		if (linept == NULL)
			{
			if (line_in(fp, line_buf, sizeof(line_buf)) == NULL)
				{
				type1_load_error("No eexec.");
				return Err_truncated;	
				}
			linept = line_buf;
			}
        if (inEncoding) 
			{
			}
		else
			{
			if (strstr(linept, "eexec") != NULL)
				goto GOT_EEXEC;
	        if ((tmp = strstr(linept, "/Encoding")) != NULL) 
				{
	            int i;

				if (strstr(line, "StandardEncoding") == NULL) 
					{
	                inEncoding = TRUE;
					tcd->user_map 
					= loader_alloc(tcd, NCdefs*sizeof(*(tcd->user_map)));
		            }
				}
        if (strstr(linept, "/FullName ") != NULL) 
			{
            char *cp;
			
			cp = linept = strchr(linept, '(');
            if (cp != NULL) 
				{
                char *ep;
				
				ep = linept = strchr(cp, ')');
				if (ep != NULL)
					{
					*ep = EOS;
                    strcpy(tcd->full_name, cp + 1);
	                }
	            }
	        }
/**** It ends up the FontBBox is less than useful because it is simply
 **** not accurate.  Many fonts have characters bigger than 
 **** the bounding box.  */
		else if (strstr(linept, "/FontBBox") != NULL) 
			{
			char *cp;
			cp = linept = strchr(linept, '{');
			if (cp != NULL) 
				{
				char *ep;
				
				ep = linept = strchr(cp, '}');
				if (ep != NULL) 
					{
					*ep = EOS;
					if(sscanf(cp+1,"%d %d %d %d"
					, &tcd->head_bounds.xmin,&tcd->head_bounds.ymin
					, &tcd->head_bounds.xmax,&tcd->head_bounds.ymax)==4) 
						{
						tcd->got_head_bounds = TRUE;
						}
					} 
				}
			}

		/* If font contains a custom encoding vector, load the encoding
		   vector into the user-defined encoding. */

        if (inEncoding) 
			{
			char *pt;

			if ((pt = strstr(linept, " def")) != NULL)
				{
                inEncoding = FALSE;
                tcd->char_map = tcd->user_map;
				linept = pt + 4;	/* skip past " def" */
            	}
			else 
				{
                char *dname = strchr(linept, '/');

                if (dname != NULL) 
					{
                    if (dname[1] != '.') 
						{
                        char token[80];

						if (sscanf(dname+1, "%s ", token) > 0) 
							{
                            int n;

							dname--;
                            while (isspace(*dname) && (dname > linept)) 
								{
								dname--;
	                            }
                            while (!isspace(*dname) && (dname > linept)) 
								{
                                dname--;
	                            }
                            n = atoi(dname);
                            if (n < 0 || n >= NCdefs) 
								{
                                type1_load_error(
						        "Error parsing encoding vector.\n"
								"Character index %d out of range.\n"
								, n);
								}
							else 
								{
                                tcd->user_map[n-0] = loader_strdup(tcd,token);
	                            }
	                        }
	                    }
					else
						linept += 1;
	                }
				else
					linept = NULL;
                }
			}

        /* If no explicit encoding vector has been loaded from a file and
           the font contains an encoding vector of its own, use the vector
           from the to map the characters into font slots. */

	    }
GOT_EEXEC:
    for (i = 0; i < 6; i++) 
		{
        (void) getc(fp);              /* Beats me, but there's 6 trash bytes */
	    }

	/* O.K., we're now into the encrypted portion of the file.
       Determine if it's ASCII or binary and process accordingly. */


	encrypt_start = ftell(fp);
	cs[0] = getc(fp);

    /* 
	   (John Walker's comment on how to tell hex from binary.)
	   "Adobe Type 1 Font Format Version 1.1", ISBN 0-201-57044-0 states
       on page 64 that one distinguishes an ASCII from a Hexadecimal
       font file by two tests:

            * The first ciphertext byte must not be an ASCII white space
                  character (blank, tab, carriage return or line feed).
			* At least one of the first 4 ciphertext bytes must not be one
              of the ASCII hexadecimal character codes (a code for 0-9,
              A-F, or a-f).  These restrictions can be satisfied by adjusting
              the random plaintext bytes as necessary.

       Well, notwithstanding this statement, Adobe's own Helvetica Bold
       Narrow Oblique file furnished with Adobe Type Manager for Windows
       has a carriage return as the first byte after the eexec invocation.
       Consequently, I turned off recognition of a hex file by the
       presence of a carriage return.  Note also the "-B" and "-H"
       command line switches that you can use to override the automatic
       recognition of file format. */

	if (forcemode != Unknown) 
		{
        filemode = forcemode;
        } 
	else 
		{
		if (cs[0] == ' ' || cs[0] == '\t' ||
            /* cs[0] == '\r' || */
			cs[0] == '\n') 
			{
            filemode = Hex;
	        } 
		else 
			{
            for (i = 1; i < 4; i++) 
				{
                cs[i] = getc(fp);
	            }
			filemode = Hex;
            for (i = 0; i < 4; i++) 
				{
                if (!((cs[i] >= '0' && cs[0] <= '0') ||
					  (cs[i] >= 'A' && cs[0] <= 'F') ||
                      (cs[i] >= 'a' && cs[0] <= 'f'))) 
					{
                    filemode = Binary;
                    break;
	                }
	            }
	        }
	    }

	fseek(fp, encrypt_start, SEEK_SET);	/* Reread encrypted random bytes as
										 * the decrypter depends on everything
										 * from encrypt_start on going through
										 * byte_in(). */

    crypt_init(55665);

    /* Now burn the first four plaintext bytes. */

	for (i = 0; i < 4; i++)
		{
        (void) decrypt(byte_in(fp));
	    }
    tokenp = token;
	while ((ic = byte_in(fp)) != EOF) 
		{
        int dc = decrypt(ic);

        if (isspace(dc)) 
			{
            if (tokenp > token) 
				{
                *tokenp = EOS;
                strcpy(ptoken, stoken);
                strcpy(stoken, ltoken);
                strcpy(ltoken, token);
                tokenp = token;
                if (strcmp(ltoken, "closefile") == 0) 
					{
                    return TRUE;
	                }
                if (ltoken[0] == '/') 
					{
					process_definition(tcd, ltoken + 1);
	                }
				if (strcmp(ltoken, "array") == 0 && section == Subrs 
				&& tcd->subrs == NULL) 
					{
                    int l = (tcd->sub_count = atoi(stoken)) * sizeof(char *);

                    tcd->subrs = loader_alloc(tcd, l);
                    memset(tcd->subrs, 0, l);
	                }
	            }
			}
		else 
			{
            *tokenp++ = dc;
			}
        if (isspace(dc) 
		&&  ((strcmp(ltoken, "-|") == 0) || (strcmp(ltoken, "RD") == 0))) 
			{
            int l = atoi(stoken), j;
            cstrinit();

            for (j = 0; j < 4; j++) 
				{
                (void) decstr(decrypt(byte_in(fp)));
                }

            /* Process the charstring depending on the section it's
                   encountered within. */

            switch (section) 
			  {
              case CharStrings:
                if (tcd->def_count > 0 
				&& tcd->letter_defs[tcd->def_count - 1] == NULL) 
					{
                    unsigned char *csd = loader_alloc(tcd, l - 4);

                    tcd->letter_defs[tcd->def_count - 1] = csd;
                    l -= 4;
					while (l-- > 0) 
						{
                        *csd++ = decstr(decrypt(byte_in(fp)));
                        }
                    } 
				else 
					{
                    type1_load_error("\nUnexpected data in CharStrings.\n");
                    }
				break;

			  case Subrs:
				j = atoi(ptoken); /* Subr number */
				if (j < 0 || j >= tcd->sub_count) 
					{
					type1_load_error("\nSubr %d out of range (0-%d).\n"
					, j, tcd->sub_count);
					} 
				else 
					{
					if (l > 4) 
						{
						unsigned char *csd = loader_alloc(tcd, l - 4);

						tcd->subrs[j] = csd;
						l -= 4;
						while (l-- > 0) 
							{
							*csd++ = decstr(decrypt(byte_in(fp)));
                            }
                        }
                    }
				break;

              default:
				/* Oh my, what do we do here?  Shouldn't happen.
				 * Let's just pretend it didn't... */
				break;
			  }
		ltoken[0] = EOS;
	        }
		}
    return Success;
}

static void tcd_freez(Type1_font **ptcd)
/* Free up memory associated with Type1_font. */
{
Type1_font *tcd;

if (ptcd != NULL && (tcd = *ptcd) != NULL)
	{
	destroy_block_allocator(&tcd->font_ba);
	free_scale_info(&tcd->scale);
	pj_freez(ptcd);
	}
}

static Errcode read_font(FILE *fp, Type1_font **ptcd)
{
Errcode err = Success;
Type1_font *tcd;

if ((tcd = pj_zalloc(sizeof(*tcd))) == NULL)
	err = Err_no_memory;
else
	{
	construct_block_allocator(&tcd->font_ba, 512L, pj_zalloc, pj_free);
	if (Success != (err = setjmp(type1_load_errhandler)))
		{	/* Got here via longjmp. */
		tcd_freez(&tcd);
		}
	else
		{
		err = rtype1(tcd, fp);
		}
	}
*ptcd = tcd;
return err;
}

static Errcode find_ascii_values(Type1_font *tcd)
/*****************************************************************************
 * Go through and build up an ascii-ordered array of character definitions.
 ****************************************************************************/
{
	char *name;
	unsigned char *def;
	unsigned char *ascii_name;
	unsigned char **map = tcd->char_map;
	char **names = tcd->letter_names;
	unsigned char **defs = tcd->letter_defs;
	int i,ascii_val;
	int def_ix;
	int def_count;
	int matches = 0;

/* The character defs are stored in the font file in *roughly* ascii order.
 * The logic in this routine takes some advantage of this by starting
 * the search for the next letter where the search for the current letter
 * left off. */
	def_ix = 0;		/* Initialize search starting position. */
	def_count = tcd->def_count;
	for (ascii_val=0; ascii_val<BYTE_MAX; ++ascii_val)
		{
		if ((ascii_name = *map++) != NULL)
			{
			i = def_count;
			while (--i >= 0)
				{
				if (++def_ix >= def_count)
					def_ix = 0;
				if ((name = names[def_ix]) != NULL)
					{
					if (strcmp(name, ascii_name) == 0)
						{
						tcd->ascii_defs[ascii_val] = defs[def_ix];
						++matches;
						break;
						}
					}
				}
			}
		}
	if (matches > 0)
		return Success;
	else
		{
			{ 	/* DEBUGGING BLOCK */
				dlog("%s char_map\n", tcd->full_name);
				map = tcd->char_map;
				for (i=0; i<NCdefs; ++i)
					{
					if (*map != NULL)
						dlog("\t%d %s\n", i, *map);
					++map;
					}
				dlog("%s names\n", tcd->full_name);
				for (i=0; i<BYTE_MAX; ++i)
					{
					if ((name = names[i]) != NULL)
						dlog("\t%d %s\n", i, name);
					}
			}
		return Err_not_found;
		}
}

Errcode type1_load_font(char *file_name, Type1_font **ptcd)
/*****************************************************************************
 * Load a type1 font into memory and do everything short of scaling to
 * prepare it for display.
 ****************************************************************************/
{
FILE *file;
Errcode err;

if ((file = fopen(file_name, "rb")) == NULL)
	return(errno);
if ((err = read_font(file, ptcd)) >= Success)
	if ((err = find_ascii_values(*ptcd)) >= Success)
		calc_font_bounds(*ptcd);
fclose(file);
return err;
}



/*****************************************************************************
 *****************************************************************************
 ** The Interpreter Section.  This section deals with interpreting the
 ** little reverse-polish-notation language that describes the letters in
 ** the font.  
 *****************************************************************************
 ****************************************************************************/



enum cscommand {
/*  Charstring command op-codes.  */
	Unused_0,
	Hstem,
	Unused_2,
	Vstem,
	Vmoveto,
	Rlineto,
	Hlineto,
	Vlineto,
	Rrcurveto,
	Closepath,
    Callsubr,
    Return,
    Escape,
    Hsbw,
    Endchar,
    Unused_15,
    Unused_16,
    Unused_17,
    Unused_18,
    Unused_19,
    Unused_20,
    Rmoveto,
	Hmoveto,
    Unused_23,
    Unused_24,
    Unused_25,
    Unused_26,
    Unused_27,
    Unused_28,
    Unused_29,
    Vhcurveto,
    Hvcurveto,

    /* 12 x commands */

    Dotsection,
    Vstem3,
    Hstem3,
    Unused_12_3,
    Unused_12_4,
    Unused_12_5,
    Seac,
    Sbw,
    Unused_12_8,
    Unused_12_9,
    Unused_12_10,
    Unused_12_11,
    Div,
    Unused_12_13,
    Unused_12_14,
    Unused_12_15,
    Callothersubr,
    Pop,
    Unused_12_18,
    Unused_12_19,
    Unused_12_20,
    Unused_12_21,
	Unused_12_22,
    Unused_12_23,
    Unused_12_24,
    Unused_12_25,
    Unused_12_26,
    Unused_12_27,
    Unused_12_28,
    Unused_12_29,
    Unused_12_30,
    Unused_12_31,
    Unused_12_32,
    Setcurrentpoint
};


#define StackLimit  25
#define OtherLimit  10                /* Maximum othersubr return values */

#define Npop(n) sp -= (n)
#define Clear() sp = 0



#define S0  stack[sp - 1]
#define S1  stack[sp - 2]
#define S2  stack[sp - 3]
#define S3  stack[sp - 4]
#define S4  stack[sp - 5]
#define S5  stack[sp - 6]

static long stack[StackLimit];        /* Data stack */
static int sp;                        /* Stack pointer */
static long osres[OtherLimit];        /* Results from othersubrs */
static int orp;                       /* Othersubr result pointer */

#define ReturnStackLimit 10

static unsigned char *rstack[ReturnStackLimit]; /* Return stack */
static int rsp;                       /* Return stack pointer */

static int curx, cury;			      /* The current point */
static int flexing;			          /* If a Flex in progress ? */
static int flexx, flexy;              /* Flex current position */
static Boolean pathopen;                  /* Path open ? */

static int bnum;                  	  /* Line segments per Bezier curve */

static int pcount;

#define AddPoint(output,x,y) {output->shape_point(output,x,y); ++pcount;}
#define ClosePath(output) {if (pcount) output->shape_close(output);}

static void Opath(Type1_output *output)
/*----------------------------------------------------------------------*
 * Start new closed shape if not in the middle of one already.
 *----------------------------------------------------------------------*/
{
        if (!pathopen)
        {
                pathopen = TRUE;
				pcount = 0;
                output->shape_open(output,curx,cury);
        }
}

static void Dpath(Type1_output *output)
/*----------------------------------------------------------------------*
 * Close current shape if any and start a new one.
 *----------------------------------------------------------------------*/
{
		if (pathopen)
        {
                ClosePath(output);
                pathopen = FALSE;
        }
        Opath(output);
}


/*  BEZIER  --  Evaluate a Bezier curve defined by four control
                points.  */


static Errcode draw_bezier(Type1_output *output, long x0, long y0
, long x1, long y1, long x2, long y2, long x3, long y3, int n)
/*----------------------------------------------------------------------*
 *	Draw a bezier curve.
 *----------------------------------------------------------------------*/
{
	int i;
	double ax, bx, cx, ay, by, cy;
	double t, dt = 1.0/n;

	ax = -x0 + 3 * x1 - 3 * x2 + x3;
	bx = 3 * x0 - 6 * x1 + 3 * x2;
	cx = 3 * (x1 - x0);

	ay = -y0 + 3 * y1 - 3 * y2 + y3;
	by = 3 * y0 - 6 * y1 + 3 * y2;
	cy = 3 * (y1 - y0);

	t = dt;
	for (i = 1; i <= n; i++) 
		{
        double vx, vy;

		vx = x0 + t * (cx + t * (bx + t * ax));
		vy = y0 + t * (cy + t * (by + t * ay));
        //vy = ay * t * t * t + by * t * t + cy * t + y0;
        t += dt;
		AddPoint(output,vx,vy);
        }
	curx = x3;
	cury = y3;
	return Success;
}

#ifdef UNUSED
static Errcode null_bezier(Type1_output *output, long x0, long y0
, long x1, long y1, long x2, long y2, long x3, long y3, int n)
/*----------------------------------------------------------------------*
 * Quick return stand in for bezier.
 *----------------------------------------------------------------------*/
{
	return Success;
}
#endif /* UNUSED */

static void othersubr(Type1_output *output, int procno, int nargs, int argp)
/*----------------------------------------------------------------------*
 * Interpret an "other subroutine".  I'm not 100% sure what all this
 * can be.  There are some predefined ones for all fonts,  but potentially they
 * can reside in the file too?
 *----------------------------------------------------------------------*/
{
    static int flexp;                 /* Flex argument pointer */
    static int flexarg[8][2];

    orp = 0;                          /* Reset othersubr result pointer */

	switch (procno) {
        case 0:                       /* Flex */
			output->bezier(output,
				   flexarg[0][X], flexarg[0][Y],
				   flexarg[2][X], flexarg[2][Y],
				   flexarg[3][X], flexarg[3][Y],
				   flexarg[4][X], flexarg[4][Y], bnum);
			output->bezier(output,
				   flexarg[4][X], flexarg[4][Y],
				   flexarg[5][X], flexarg[5][Y],
				   flexarg[6][X], flexarg[6][Y],
				   flexarg[7][X], flexarg[7][Y], bnum);
            osres[0] = stack[argp + 1];
            osres[1] = stack[argp + 2];
            flexing = FALSE;          /* Terminate flex */
            break;

        case 1:                       /* Flex start */
            flexing = TRUE;           /* Mark flex underway */
            flexx = curx;
            flexy = cury;
            flexp = 0;
            /* Note fall-through */
        case 2:                       /* Flex argument specification */
            flexarg[flexp][X] = flexx;
            flexarg[flexp++][Y] = flexy;
            break;

        case 3:                       /* Hint replacement */
            osres[0] = 3;             /* Null hint replacement subr */
            break;

        default:
    /*        fprintf(stderr, "\nCall to undefined othersubr %d\n",
                procno); */
			break;
    }
}


/*  EXCHARS  --  Execute charstring.  */

static Errcode type1_exchars(Type1_font *tcd, int *pwidth
,	Type1_output *output, int bezier_points, unsigned char *cp)
/* Returns Errcode or the width of character. */
{
#define So(n) if ((sp + (n)) > StackLimit) {err = Err_stack; goto ERROR;}
#define Sl(n) if (sp < (n)) {err = Err_stack; goto ERROR;}
	Errcode err = Success;
	int sub;
	int sidebear[2], charwid[2];   /* Character sidebearing and width */

	bnum = bezier_points;			  /* Set how many points in bezier curve. */
	sp = rsp = 0;                     /* Reset stack pointer */
	pathopen = FALSE;
	flexing = FALSE;          

	for (;;)
		{
		int c = *cp++;

		if (c < 32) 
			{
			/* Command */
			if (c == 12) 
				{
				/* Two byte command */
				c = *cp++ + 32;
	            }

			switch (c)
				{
				/* Commands for Starting and Finishing */
				case Endchar:     /* 14: End character */
					Clear();
					goto OUT;
				case Hsbw:        /* 13:  Set horizontal sidebearing */
					Sl(2);
					curx = sidebear[X] = S1;
					cury = sidebear[Y] = 0;
					*pwidth = charwid[X] = S0;
					charwid[Y] = 0;
					Clear();
					break;
				case Seac:        /* 12-6:  Standard encoding accented char */
					Sl(5);
					Clear();
					goto OUT;
				case Sbw:         /* 12-7:  Sidebearing point (x-y) */
					Sl(4);
					curx = sidebear[X] = S3;
					cury = sidebear[Y] = S2;
					*pwidth = charwid[X] = S1;
					charwid[Y] = S0;
					Clear();
					break;

				/* Path Construction Commands */
				case Closepath:       /* 9:  Close path */
					if (!pathopen) 
						{
						err = Err_format;
						goto ERROR;
						} 
					else 
						{
						ClosePath(output);
						}
					pathopen = FALSE;
					Clear();
					break;
				case Hlineto:         /* 6: Horizontal line to */
					Sl(1);
					Opath(output);
					curx = curx + S0;
					AddPoint(output,curx, cury);
					Clear();
					break;
				case Hmoveto:         /* 22:  Horizontal move to */
					Sl(1);
					if (flexing)
						flexx += S0;
					else
						{
						curx += S0;
						Dpath(output);
						}
					Clear();
					break;
				case Hvcurveto:       /* 31:  Horizontal-vertical curve to */
					Sl(4);
					Opath(output);
					output->bezier(output, curx, cury, curx + S3, cury,
					   curx + S3 + S2, cury + S1,
					   curx + S3 + S2, cury + S1 + S0, bnum);
					Clear();
					break;
				case Rlineto:         /* 5:  Relative line to */
					Sl(2);
					Opath(output);
					curx += S1;
					cury += S0;
					AddPoint(output,curx, cury);
					Clear();
					break;
				case Rmoveto:         /* 21:  Relative move to */
					Sl(2);
					if (flexing) 
						{
						flexx += S1;
						flexy += S0;
						}
					else
						{
						curx += S1;
						cury += S0;
						Dpath(output);
						}
					Clear();
					break;
				case Rrcurveto:       /* 8:  Relative curve to */
					Sl(6);
					Opath(output);
					output->bezier(output, curx, cury, curx + S5, cury + S4,
					   curx + S5 + S3, cury + S4 + S2,
					   curx + S5 + S3 + S1, cury + S4 + S2 + S0, bnum);
					Clear();
					break;
				case Vhcurveto:       /* 30:  Vertical-horizontal curve to */
					Sl(4);
					Opath(output);
					output->bezier(output, curx, cury, curx, cury + S3,
					   curx + S2, cury + S3 + S1,
					   curx + S2 + S0, cury + S3 + S1, bnum);
					Clear();
					break;
				case Vlineto:         /* 7:  Vertical line to */
					Sl(1);
					Opath(output);
					cury = cury + S0;
					AddPoint(output,curx,cury);
					Clear();
					break;
				case Vmoveto:         /* 4:  Vertical move to */
					Sl(1);
					if (flexing)
						flexy += S0;
					else
						{
						cury += S0;
						Dpath(output);
						}
					Clear();
					break;

				/*  Hint Commands  */
				case Dotsection:      /* 12-0:  Dot section */
					Clear();
					break;
				case Hstem:           /* 1:  Horizontal stem zone */
					Sl(2);
					Clear();
					break;
				case Hstem3:          /* 12-2:  Three horizontal stem zones */
					Sl(6);
					Clear();
					break;
				case Vstem:           /* 3:  Vertical stem zone */
					Sl(2);
					Clear();
					break;
				case Vstem3:          /* 12-1:  Three vertical stem zones */
					Sl(6);
					Clear();
					break;
				/* Arithmetic command */

				case Div:             /* 12 12:  Divide */
					Sl(2);
					S1 = (S1 + (S0 / 2)) / S0;
					Npop(1);
					break;

				/* Subroutine Commands */
				case Callothersubr:   /* 12 16:  Call other subroutine */
					Sl(2);
					Sl(2 + S1);
					othersubr(output, S0, S1, sp - (2 + S1));
					Npop(2 + S1);
					break;
				case Callsubr:        /* 10:  Call subroutine */
					Sl(1);
					if (rsp >= ReturnStackLimit) 
						{
						err = Err_stack;
						goto ERROR;
						}
					rstack[rsp++] = cp;
					sub = S0;
					Npop(1);
					if (sub < 0 || sub >= tcd->sub_count) 
						{
						err = Err_function_not_found;
						goto ERROR;
						}
					if (tcd->subrs[sub] == NULL)
						{
						err = Err_null_ref;
						goto ERROR;
						}
					/* Set instruction pointer to subr code */
					cp = tcd->subrs[sub];  
					break;
				case Pop:      /* 12 17:  Return argument from othersubr */
					So(1);
					stack[sp++] = 3;  /****?????*****/
					break;
				case Return:   /* 11:  Return from subroutine */
					if (rsp < 1) 
						{
						err = Err_stack;
						goto ERROR;
						}
					cp = rstack[--rsp]; /* Restore pushed call address */
					break;
				case Setcurrentpoint: /* 12 33:  Set current point */
					Sl(2);
					if (S1 != curx || S0 != cury) 
						{
						curx = S1;
						cury = S0;
						}
					Clear();
					break;
				}
			} 
		else 
			{
			long n;

			if (c <= 246)
				{
				n = c - 139;
				} 
			else if (c <= 250) 
				{
				n = ((c - 247) << 8) + *cp++ + 108;
				} 
			else if (c < 255) 
				{
				n = -((c - 251) << 8) - *cp++ - 108;
				} 
			else 
				{
				char a[4];

				a[0] = *cp++;
				a[1] = *cp++;
				a[2] = *cp++;
				a[3] = *cp++;
				n = (((((a[0] << 8) | a[1]) << 8) | a[2]) << 8) | a[3];
				}
			if (sp >= StackLimit) 
				{
				err = Err_stack;
				goto ERROR;
				} 
			else 
				{
				stack[sp++] = n;
				}
			}
	    }
ERROR:
OUT:
	return err;
#undef So
}

Errcode type1_interp_char(Type1_font *tcd,	int *pwidth
,	Type1_output *output, int bezier_points, unsigned char *cp)
/* Returns Errcode or the width of character. */
{
	Errcode err,terr;

	if ((err = output->letter_open(output)) >= Success)
		{
		terr = type1_exchars(tcd,pwidth,output,bezier_points,cp);
		err = output->letter_close(output);
		if (err >= Success)	/* Give precedence to letter_close error. */
			err = terr;
		}
	return err;
}

/*****************************************************************************
 *****************************************************************************
 * Output section - a couple of ways of using the interpreter above.  One
 * for finding the bounds of characters,  and one for actually drawing them.
 *****************************************************************************
 ****************************************************************************/


/*****************Help figure out how much space letter uses*****************/

static void init_bounding_box(Type1_box *b)
/*----------------------------------------------------------------------*
 * Set up bounding box so that any incoming point will set the
 * min and the max.
 *----------------------------------------------------------------------*/
{
	b->xmin = b->ymin = INT_MAX;
	b->xmax = b->ymax = INT_MIN;
}

static void point_into_bounding_box(Type1_box *b, double x, double y)
/*----------------------------------------------------------------------*
 * Update the bounding box with a new point.
 *----------------------------------------------------------------------*/
{
	if (x < b->xmin)
		b->xmin = x;
	if (x > b->xmax)
		b->xmax = x;
	if (y < b->ymin)
		b->ymin = y;
	if (y > b->ymax)
		b->ymax = y;
}

static void box_into_bounding_box(Type1_box *dest
,	Type1_box *new)
/*----------------------------------------------------------------------*
 * Update the bounding box to include a new box.
 *----------------------------------------------------------------------*/
{
	if (new->xmin < dest->xmin)
		dest->xmin = new->xmin;
	if (new->xmax > dest->xmax)
		dest->xmax = new->xmax;
	if (new->ymin < dest->ymin)
		dest->ymin = new->ymin;
	if (new->ymax > dest->ymax)
		dest->ymax = new->ymax;
}

/*********************Stuff to position font on screen************************/
static int sf_xoff, sf_yoff;		/* Upper left corner of current char. */
static double sf_scalex, sf_scaley;	/* How to scale current character. */
static int sf_bezier_points = 8;	/* How many points to put in bezier. */

#define X_TO_SCREEN(fo,x) (sf_xoff + (int)((x)*sf_scalex))
#define Y_TO_SCREEN(fo,y) (sf_yoff - (int)((y)*sf_scaley))


/*********************Stuff for finding bounds of letter*********************/
static Type1_box bounds_box;
static int bounds_points;

static Errcode bounds_letter_open(Type1_output *fo)
{
	init_bounding_box(&bounds_box);
	return Success;
}

static Errcode bounds_close(Type1_output *fo)
{
	return Success;
}

static Errcode bounds_add_point(Type1_output *fo, double x, double y)
{
	point_into_bounding_box(&bounds_box, x, -y);
	++bounds_points;
	return Success;
}

static Type1_output bounds_output = 
	{
	draw_bezier,
	bounds_letter_open,
	bounds_close, 
	bounds_add_point, 
	bounds_close, 
	bounds_add_point,
	};

static Errcode bounds_interpret(Type1_font *tcd, unsigned char *def
,	Type1_box *bounds)
/************************************************************************
 * 
 ************************************************************************/
{
	int width;

	bounds_points = 0;
	type1_interp_char(tcd, &width, &bounds_output, sf_bezier_points, def);
	if (bounds_points > 0)
		*bounds = bounds_box;
	return width;
}

void calc_font_bounds(Type1_font *tcd)
/************************************************************************
 *  Figure out the (unscaled) size of each letter in font.
 ************************************************************************/
{
	unsigned char **ascii_defs = tcd->ascii_defs;
	Type1_box *pbounds = tcd->letter_bounds;
	int *pwidth = tcd->letter_width;
	int width, widest;
	unsigned char *def;
	int i;

	init_bounding_box(&tcd->font_bounds);
	i = BYTE_MAX;
	widest = 0;
	while (--i >= 0)
		{
		if ((def = *ascii_defs++) != NULL)
			{
			width = *pwidth = bounds_interpret(tcd, def, pbounds);
			if (width > widest)
				widest = width;
			box_into_bounding_box(&tcd->font_bounds, pbounds);
			}
		++pwidth;
		++pbounds;
		}
	tcd->font_widest = widest;

}



/*********************Stuff to draw a filled letter**************************/

static Block_allocator fill_ba;

typedef struct shape_list
	{
	struct shape_list *next;
	LLpoint *points;
	int point_count;
	} Shape_list;

static Shape_list *fill_shape_list;

static Type1_box fill_bounds;


static Errcode fill_point(Type1_output *fo, double x, double y)
/*----------------------------------------------------------------------*
 * Add a point to a filled shape.
 *----------------------------------------------------------------------*/
{
	LLpoint *p;
	int sx,sy;

	if ((p = alloc_from_block(&fill_ba, sizeof(*p))) == NULL)
		return Err_no_memory;
	p->next = fill_shape_list->points;
	fill_shape_list->points = p;
	p->x = sx = X_TO_SCREEN(fo,x);
	p->y = sy = Y_TO_SCREEN(fo,y);
	point_into_bounding_box(&fill_bounds, sx, sy);
	++fill_shape_list->point_count;
	return Success;
}

static Errcode fill_shape_open(Type1_output *fo, double x, double y)
/*----------------------------------------------------------------------*
 * Start a new filled shape.
 *----------------------------------------------------------------------*/
{
	Shape_list *s;

	if ((s = alloc_from_block(&fill_ba, sizeof(*s))) == NULL)
		return Err_no_memory;
	s->next = fill_shape_list;
	s->points = NULL;
	s->point_count = 0;
	fill_shape_list = s;
	return fill_point(fo,x,y);
}

static Errcode fill_shape_close(Type1_output *fo)
/*----------------------------------------------------------------------*
 * Finish up a filled shape.
 *----------------------------------------------------------------------*/
{
	LLpoint *last_point;

	last_point = slist_last(fill_shape_list->points);
	last_point->next = fill_shape_list->points;
	return Success;
}

static Errcode fill_letter_open(Type1_output *fo)
/*----------------------------------------------------------------------*
 * Start a filled letter.
 *----------------------------------------------------------------------*/
{
	fill_shape_list = NULL;
	construct_block_allocator(&fill_ba, 512L, pj_malloc, pj_free);
	init_bounding_box(&fill_bounds);
	return Success;
}


static void find_shape_bounds(Type1_box *bounds, Shape_list *shapes)
/*----------------------------------------------------------------------*
 * Make up a bounding box that contains every point in every shape in
 * the shape list.
 *----------------------------------------------------------------------*/
{
	Type1_box b;
	LLpoint *points;
	int point_count;
	int x,y;

	init_bounding_box(&b);
	while (shapes != NULL)
		{
		/* Ignore dotty input. */
		if ((point_count = shapes->point_count) > 1)
			{
			points = shapes->points;
			while (--point_count >= 0)
				{
				x = points->x;
				y = points->y;
				if (x < b.xmin)
					b.xmin = x;
				if (x > b.xmax)
					b.xmax = x;
				if (y < b.ymin)
					b.ymin = y;
				if (y > b.ymax)
					b.ymax = y;
				points = points->next;
				}
			}
		shapes = shapes->next;
		}
	*bounds = b;
}


static Errcode output_shape_list(Type1_output *fo, Shape_list *shapes)
/*----------------------------------------------------------------------*
 * Render shape list to screen.
 *----------------------------------------------------------------------*/
{
	Poly poly;
	int width,height;
	Type1_box bounds;
	int bpr;
	long size;
	UBYTE *on_off_buf;
	Errcode err;

/* Allocate a single bit-plane buffer big enough for whole shape. */
	find_shape_bounds(&bounds, shapes);
	width = bounds.xmax - bounds.xmin + 1;
	height = bounds.ymax - bounds.ymin + 1;
	bpr = Bitmap_bpr(width);
	size = ((long)bpr*height);
	if ((on_off_buf = pj_zalloc(size)) == NULL)
		return Err_no_memory;

	while (shapes != NULL)
		{
		/* kludge around dotty input. */
		if ((poly.pt_count = shapes->point_count) > 1)
			{
			poly.clipped_list = shapes->points;
			fill_add_shape(&poly, on_off_buf, bpr, bounds.xmin, bounds.ymin);
			err = fo->poly_out.outline(&poly,TRUE,fo->poly_out.data);
			}
		shapes = shapes->next;
		}
	err = fill_on_off(bpr, width, height, bounds.xmin, bounds.ymin
	, on_off_buf, fo->poly_out.hline, fo->poly_out.data);
	pj_free(on_off_buf);
	return err;
}

static Errcode fill_letter_close(Type1_output *fo)
/*----------------------------------------------------------------------*
 * Finish up a filled letter.
 *----------------------------------------------------------------------*/
{
	Errcode err;

	err = output_shape_list(fo, fill_shape_list);
	destroy_block_allocator(&fill_ba);
	fill_shape_list = NULL;
	return err;
}

static Type1_output fill_output = 
	{
	draw_bezier,
	fill_letter_open, 
	fill_letter_close, 
	fill_shape_open, 
	fill_shape_close,
	fill_point,
	};

static int fill_interpret(Type1_font *tcd	/* Font definition */
, unsigned char *def						/* Code to interpret */
, int xoff, int yoff						/* Upper left corner of result */
, Type1_poly_out *poly_out)					/* How to draw lines etc. */
/************************************************************************
 * Call interpreter to actually draw a filled character.
 ************************************************************************/
{
	int width;

	sf_xoff = xoff;
	/* sf_yoff = -tcd->scale.max_bounds.ymin + yoff; */
	sf_yoff = yoff;
	sf_scalex = tcd->scale.scalex;
	sf_scaley = tcd->scale.scaley;
	fill_output.poly_out = *poly_out;
	type1_interp_char(tcd, &width, &fill_output, sf_bezier_points, def);
	return width*tcd->scale.scalex;
}

/*******************Stuff to scale font*******************************/

static void free_scale_info(Type1_scale_info *si)
/*-----------------------------------------------------------------------
 * Free up resources associated with one size of font.
 *----------------------------------------------------------------------*/
{
	destroy_block_allocator(&si->ba);
}

int find_right_overlap(Type1_font *tcd, double scalex)
/*----------------------------------------------------------------------*
 * Find out the maximum difference between the right edge of a letter in
 * font and the width the same letter.  (This will be useful in telling
 * us how far to the right of the ostensible string width we need to
 * erase when undrawing.)
 *----------------------------------------------------------------------*/
{
	int *pwidth = tcd->scale.width;
	Type1_box *pbox = tcd->letter_bounds;
	unsigned char **ascii_defs = tcd->ascii_defs;
	int i = BYTE_MAX;
	int font_right_overlap = 0;
	int char_right_overlap;

	while (--i >= 0)
		{
		if (*ascii_defs++ != NULL)
			{
			if ((char_right_overlap = pbox->xmax * scalex - *pwidth) 
			> font_right_overlap)
				font_right_overlap = char_right_overlap;
			}
		++pwidth;
		++pbox;
		}
	return font_right_overlap;
}

static void scale_box(double scalex, double scaley
, Type1_box *in, Type1_box *out)
{
	out->xmin = in->xmin * scalex;
	out->ymin = in->ymin * scaley;
	out->xmax = in->xmax * scalex;
	out->ymax = in->ymax * scaley;
}

void scale_type1_font(Type1_font *tcd, double scalex, double scaley)
/*----------------------------------------------------------------------*
 *  Set up font for a particular size.
 *----------------------------------------------------------------------*/
{
	unsigned char **ascii_defs = tcd->ascii_defs;
	int *lwidth = tcd->letter_width;
	int *pscaled = tcd->scale.width;
	int i;
	long mem_block_size;

	tcd->scale.scalex = scalex;
	tcd->scale.scaley = scaley;
	tcd->scale.widest = tcd->font_widest * scaley;
	scale_box(scalex, scaley, &tcd->font_bounds, &tcd->scale.max_bounds);
	i = BYTE_MAX;
	while (--i >= 0)
		*pscaled++ = *lwidth++ * scalex;
	tcd->scale.right_overlap = find_right_overlap(tcd, scalex);
	/* Set up # of points in bezier to correspond roughly with
	 * resolution. Also set up memory block size so at small resolutions
	 * we allocate in 512 blocks, but at larger resolutions allocate
	 * for each letter individually. */
	if (scalex < 0.02)
		{
		sf_bezier_points = 4;
		mem_block_size = 512;
		}
	else if (scalex < 0.10)
		{
		sf_bezier_points = 8;
		mem_block_size = 10*1024;
		}
	else
		{
		sf_bezier_points = 16;
		mem_block_size = 64L*1024;
		}
	free_scale_info(&tcd->scale);
	construct_block_allocator(&tcd->scale.ba, mem_block_size
	,	pj_zalloc, pj_free);
	clear_mem(tcd->scale.bits, sizeof(tcd->scale.bits));

}

void set_type1_height(Type1_font *tcd, int height)
/************************************************************************
 *  Scale font so it will be a specific height.  Scale X and Y the same
 *  amount.
 ************************************************************************/
{
	double scale;
	double unscaled_height;

	unscaled_height = tcd->font_bounds.ymax - tcd->font_bounds.ymin + 1;
	scale = (double)height/unscaled_height;
	scale_type1_font(tcd, scale, scale);
}



/*****************************************************************************
 *****************************************************************************
 ** PJ Vfont glue section.  This bit folds the type1 stuff into the
 ** protocol shared by all types of fonts that PJ uses.
 *****************************************************************************
 ****************************************************************************/


/****************************Vfont functions*********************************/

static void attatch_type1_font(Vfont *vfont, Type1_font *tcd);

void vfont_free(Vfont *v)
{
	tcd_freez(&v->font);
}

#ifdef OLD
static Errcode fast_outline(Poly *poly, Boolean closed, void *data)
{
	int count = poly->pt_count;
	LLpoint *this, *next;

	this = poly->clipped_list;
	while (--count >= 0)
	{
		next = this->next;
		pj_cline(this->x, this->y, next->x, next->y, gl_sdot, data);
		this = next;
	}
	return Success;
}

Errcode vfont_gftext(Raster *rast,
			Vfont *v,
			register unsigned char *s,
			int x,int y,
			Pixel color,Text_mode tmode,
			Pixel bcolor)
{
	Type1_font *tcd = v->font;
	unsigned char c;
	unsigned char *def;
	Sdat sdata;
	Type1_poly_out output;

	if (tmode == TM_RENDER)
		{
		output.hline = render_hline;
		output.outline = render_opoly;
		output.data = rast;
		}
	else
		{
		sdata.rast = rast;
		sdata.color = color;
		output.hline = gl_shline;
		output.outline = fast_outline;
		output.data = &sdata;
		}

	while ((c = *s++) != EOS)
		{
		if ((def = tcd->ascii_defs[c]) != NULL)
			x += fill_interpret(tcd, def, x, y - tcd->scale.max_bounds.ymin
			, &output);
		}
	return Success;
}
#endif /* OLD */

#ifdef NEW
#endif /* NEW */
void type1_clip(int yoff, int xstart, int xend, Type1_bitplane *bits)
/* Just for debugging.. */
{
	static FILE *f;

	if (f == NULL)
		f = fopen("H:clipme.log", "w");
	fprintf(f, "Clipping %d %d %d  into %dx%d\n"
	, yoff, xstart, xend, bits->width, bits->height);
	fflush(f);
}

/** Stuff to draw onto a bitplane. **/
Errcode type1_bits_hline(int yoff, int xstart, int xend, Type1_bitplane *bits)
{
	if (yoff < 0 || xstart < 0)
		type1_clip(yoff, xstart, xend, bits);
	else if (yoff >= bits->height || xend >= bits->width)
		type1_clip(yoff, xstart, xend, bits);
	else
		set_bit_hline(bits->bits, bits->bpr, yoff, xstart, xend);
	return Success;
}

Errcode type1_bits_dot(int x, int y, Type1_bitplane *bits)
{
	if (x < 0 || y < 0 || x >= bits->width || y >= bits->height)
		type1_clip(y,x,x,bits);
	bits->bits[y*bits->bpr + (x>>3)] |= bit_masks[x&7];
	return Success;
}

Errcode type1_bits_outline(Poly *poly, Boolean closed, Type1_bitplane *bits)
{
	int count = poly->pt_count;
	LLpoint *this, *next;

	this = poly->clipped_list;
	while (--count >= 0)
	{
		next = this->next;
		pj_cline(this->x, this->y, next->x, next->y, type1_bits_dot, bits);
		this = next;
	}
	return Success;
}

Errcode get_bit_image(Type1_font *tcd
, unsigned char letter, Type1_bitplane **pbits)
/*****************************************************************************
 * Returns bitmap for a letter.  If it's already been drawn and is in
 * the cache returns rather quickly.  Otherwise calls
 * PS Type II interpreter to make a bitmap.  
 ****************************************************************************/
{
	static Type1_poly_out output = {type1_bits_hline, type1_bits_outline, NULL};
	int width, height;
	Type1_bitplane *bits;
	Type1_box bounds;
	Errcode err;

	/* If it's already in the cache it's pretty easy. */
	if ((bits = tcd->scale.bits[letter]) != NULL)
		{
		*pbits = bits;
		return Success;
		}
	/* Find dimensions of bit image. */
	scale_box(tcd->scale.scalex, tcd->scale.scaley
	, &tcd->letter_bounds[letter], &bounds);
	/* And allocate bitmap. */
	if ((bits = alloc_from_block(&tcd->scale.ba, sizeof(*bits))) == NULL)
		return Err_no_memory;
	bits->x = bounds.xmin;
	bits->y = bounds.ymin - tcd->scale.max_bounds.ymin;
	bits->width = width = bounds.xmax - bounds.xmin + 1;
	bits->height = height = bounds.ymax - bounds.ymin + 1;
	bits->bpr = Bitmap_bpr(width);
	if ((bits->bits = alloc_from_block(&tcd->scale.ba, height*bits->bpr))
	== NULL)
		return Err_no_memory;
	/* Now set up output data structure for interpreter and draw it. */
	output.data = bits;
	if ((err = fill_interpret(tcd
	, tcd->ascii_defs[letter], -bounds.xmin, -bounds.ymin, &output)) >= Success)
		{
		tcd->scale.bits[letter] = *pbits = bits;
		}
	return err;
}

Errcode vfont_gftext(Raster *rast,
			Vfont *v,
			register unsigned char *s,
			int x,int y,
			Pixel color,Text_mode tmode,
			Pixel bcolor)
/*****************************************************************************
 * Draw a text string in the font.  
 For each character guy checks to see if 
 * it's already been rendered as a bitmap.  If not vfont_gftext calls the 
 * PS Type II interpreter to make a bitmap.  Then he draws the bitmap.
 ****************************************************************************/
{
	Type1_font *tcd = v->font;
	Type1_bitplane *bits;
	unsigned char c;
	unsigned char *def;
	VFUNC blit = blit_for_mode[tmode];
	Errcode err;
	int width, height;


	while ((c = *s++) != EOS)
		{
		if ((def = tcd->ascii_defs[c]) != NULL)
			{
			if ((err = get_bit_image(tcd, c, &bits)) < Success)
				return err;
			(*blit)(bits->bits, bits->bpr, 0, 0
			, rast, x+bits->x, y+bits->y
			, bits->width, bits->height, color, bcolor);
			x += tcd->scale.width[c];
			}
		}
	return Success;
}

int vfont_char_width(Vfont *v, UBYTE *s)
{
	Type1_font *tcd = v->font;

	return (tcd->scale.width[s[0]] + v->spacing);
}

Boolean vfont_in_font(Vfont *v, int c)
{
	Type1_font *tcd = v->font;

	return ( c >= 0 && c < BYTE_MAX && tcd->ascii_defs[c] != NULL);
}

Errcode vfont_scale_font(Vfont *v, int height)
{
	Type1_font *tcd = v->font;

	set_type1_height(tcd, height);
	attatch_type1_font(v, tcd);
	return Success;
}

/****************************Font_dev functions******************************/

Errcode check_type1_font(char *name)
/* Verify it's a Post-script font by looking for the !% signature in the
 * first 128 bytes, and making sure the file suffix starts with a 'p' */
{
FILE *f;
char *suff = pj_get_path_suffix(name);
Errcode err;

if (!(suff[1] == 'p' || suff[1] == 'P'))
	return Err_suffix;
if ((err = ffopen(name, &f, "rb")) < Success)
	return err;
err = type1_check_signature(f);
ffclose(&f);
return err;
}

static void attatch_type1_font(Vfont *vfont, Type1_font *tcd)
/*----------------------------------------------------------------------*
 * Fill out Vfont structure from relevant fields of Type1_font.
 *----------------------------------------------------------------------*/
{
clear_struct(vfont);
vfont->type = TYPE1FONT;
vfont->font = tcd;
vfont->close_vfont = vfont_free;
vfont->gftext = vfont_gftext;
vfont->char_width = vfont_char_width;
vfont->scale_font = vfont_scale_font;
vfont->in_font = vfont_in_font;
vfont->widest_image = tcd->scale.max_bounds.xmax 
- tcd->scale.max_bounds.xmin + 1;
vfont->widest_char = tcd->scale.widest;
vfont->image_height = tcd->scale.max_bounds.ymax 
- tcd->scale.max_bounds.ymin + 1;
vfont->line_spacing = vfont->image_height;
vfont->tab_width = vfont->widest_char*TABEXP;
if (tcd->scale.max_bounds.xmin < 0)
	vfont->left_overlap = -tcd->scale.max_bounds.xmin;
vfont->right_overlap = tcd->scale.right_overlap;
vfont->flags = VFF_SCALEABLE;
scan_init_vfont(vfont);
}

Errcode load_vfont(char *title, Vfont *vfont, SHORT height)
{
	Type1_font *tcd;
	Errcode err;

	if (height <= 0)
		height = 100;		/* Set default height. */
	if ((err = type1_load_font(title, &tcd)) >= Success)
		{
		set_type1_height(tcd, height);
		attatch_type1_font(vfont, tcd);
		}
	return err;
}

Font_dev type1_font_dev = {
NULL,
"Postscript Type 1",
"*.PF?",
check_type1_font,
load_vfont,
TYPE1FONT,
};

