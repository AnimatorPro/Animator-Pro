/*

		Read and decrypt an Adobe Type 1 font.
		This code was written originally by John Walker
		using the _Adobe Type 1 Font Format 1.1_ published
		by Addison-Wesley ISBN 0-201-57044-0 as a guide.

		There are two main sections to this file set apart with
		long comment blocks.  One reads the font into memory.
		The other draws the font.

*/

#include <string.h>
#include <ctype.h>
#include <math.h>
#include <limits.h>
#include <setjmp.h>
#include "lstdio.h"
#include "pjbasics.h"
#include "jimk.h"
#include "rastext.h"
#include "blockall.h"
#include "fixpoint.h"
#include "type1.h"

#define EOS     '\0'

#define X   0
#define Y   1


/*****************************************************************************
 *****************************************************************************
 ** The Load Section.  A PostScript Type 1 file is composed of a list of
 ** definitions.  Each definition is a keyword followed by data.  
 ** At the start of the file are a bunch of definitions that are about the
 ** font as a whole.  Then we come to the individual letters,   which are
 ** encrypted and in their own little RPN language.
 **
 ** The load section is concerned with verifying that the file is indeed
 ** a PostScript Type 1,  extracting a few interesting things (including
 ** the full font name) from the pre-letter definitions,  and then decrypting
 ** the individual letters and the subroutines they use and sticking them 
 ** in a couple of arrays for later access.
 *****************************************************************************
 ****************************************************************************/

/*****************************************************************************
 * Let's handle errors (not enough memory, bad data in file, etc.) during
 * reading with a setjmp/longjmp.  The longjmp destination will be the
 * highest level read routine (read_type1_font).
 ****************************************************************************/
static jmp_buf type1_load_errhandler; /* Jump buffer for load errors.	*/

static void type1_load_error(char *fmt, ...)
/*
 * format & output an error message, then longjump to error handler.
 */
{
char	sbuf[512];
va_list args;

va_start(args, fmt);
varg_continu_box(NULL,fmt,args,NULL);
va_end(args);
longjmp(type1_load_errhandler, Err_reported);
}


static enum {Unknown, Binary, Hex} filemode = Unknown, forcemode = Unknown;

/*  Sections of the font file.  */
typedef enum { Header, FontInfo, OtherSubrs, Subrs, CharStrings } file_section;
static file_section section;

#ifdef NEVER
/*  Some variables read during the Header or FontInfo sections. */
char fullname[256];         /* Font name */


/* These variables contain the letters in the font. */
static unsigned char *chardefs[NCdefs][2]; /* Character definitions */
static int chardl[NCdefs];                 /* Character definition lengths */

/* These variables contain the subroutines used by the letters. */
static int nsubrs = 0;                     /* Number of subroutines */
static unsigned char **subrs = NULL;       /* Subroutine pointer table */
static int *subrl = NULL;                  /* Subroutine lengths */
char **usermap;              /* User-defined mapping vector */
char **charmap;              /* Active mapping vector (isomap or usermap). */
#endif /* NEVER */


/*  Map of PostScript character names to ISO 8859-1 Latin 1  */

static char *isomap[224] = {
    "space",             /*  32 */
    "exclam",            /*  33 */
    "quotedbl",          /*  34 */
    "numbersign",        /*  35 */
    "dollar",            /*  36 */
    "percent",           /*  37 */
    "ampersand",         /*  38 */
    "quoteright",        /*  39 */
    "parenleft",         /*  40 */
    "parenright",        /*  41 */
    "asterisk",          /*  42 */
    "plus",              /*  43 */
    "comma",             /*  44 */
    "hyphen",            /*  45 */
    "period",            /*  46 */
    "slash",             /*  47 */
    "zero",              /*  48 */
    "one",               /*  49 */
    "two",               /*  50 */
    "three",             /*  51 */
    "four",              /*  52 */
    "five",              /*  53 */
    "six",               /*  54 */
    "seven",             /*  55 */
    "eight",             /*  56 */
    "nine",              /*  57 */
    "colon",             /*  58 */
    "semicolon",         /*  59 */
    "less",              /*  60 */
    "equal",             /*  61 */
    "greater",           /*  62 */
    "question",          /*  63 */
    "at",                /*  64 */
    "A",                 /*  65 */
    "B",                 /*  66 */
    "C",                 /*  67 */
    "D",                 /*  68 */
    "E",                 /*  69 */
    "F",                 /*  70 */
    "G",                 /*  71 */
    "H",                 /*  72 */
    "I",                 /*  73 */
    "J",                 /*  74 */
    "K",                 /*  75 */
    "L",                 /*  76 */
    "M",                 /*  77 */
    "N",                 /*  78 */
    "O",                 /*  79 */
    "P",                 /*  80 */
    "Q",                 /*  81 */
    "R",                 /*  82 */
    "S",                 /*  83 */
    "T",                 /*  84 */
    "U",                 /*  85 */
    "V",                 /*  86 */
    "W",                 /*  87 */
    "X",                 /*  88 */
    "Y",                 /*  89 */
    "Z",                 /*  90 */
    "bracketleft",       /*  91 */
    "backslash",         /*  92 */
    "bracketright",      /*  93 */
    "asciicircum",       /*  94 */
    "underscore",        /*  95 */
    "grave",             /*  96 */
    "a",                 /*  97 */
    "b",                 /*  98 */
    "c",                 /*  99 */
    "d",                 /* 100 */
    "e",                 /* 101 */
    "f",                 /* 102 */
    "g",                 /* 103 */
    "h",                 /* 104 */
    "i",                 /* 105 */
    "j",                 /* 106 */
    "k",                 /* 107 */
    "l",                 /* 108 */
    "m",                 /* 109 */
    "n",                 /* 110 */
    "o",                 /* 111 */
    "p",                 /* 112 */
    "q",                 /* 113 */
    "r",                 /* 114 */
    "s",                 /* 115 */
    "t",                 /* 116 */
    "u",                 /* 117 */
    "v",                 /* 118 */
    "w",                 /* 119 */
    "x",                 /* 120 */
    "y",                 /* 121 */
    "z",                 /* 122 */
    "braceleft",         /* 123 */
    "bar",               /* 124 */
    "braceright",        /* 125 */
    "asciitilde",        /* 126 */
    NULL,            /* 127 */
    "Ccedilla",            /* 128 */
    "uumlaut",            /* 129 */
    "eacute",            /* 130 */
    "acircumflex",               /* 131 */
    "aumlaut",           /* 132 */
    "agrave",            /* 133 */
    "aring",             /* 134 */
    "ccedilla",          /* 135 */
    "ecircumflex",               /* 136 */
    "eumlaut",           /* 137 */
    "egrave",            /* 138 */
    "iumlaut",           /* 139 */
    "icircumflex",               /* 140 */
    "igrave",            /* 141 */
    "Aumlaut",           /* 142 */
    "Aring",             /* 143 */
    "Eacute",            /* 144 */
    "ae",            /* 145 */
    "AE",        /* 146 */
    "ocircumflex",               /* 147 */
    "oumlaut",           /* 148 */
    "ograve",            /* 149 */
    "ucircumflex",               /* 150 */
    "ugrave",            /* 151 */
    "yumlaut",           /* 152 */
    "Oumlaut",           /* 153 */
    "Uumlaut",           /* 154 */
    "cent",              /* 155 */
    "sterling",          /* 156 */
    "yen",               /* 157 */
    NULL,                /* 158 */
    NULL,                /* 159 */
    "aacute",             /* 160 */
    "iacute",        /* 161 */
    "oacute",              /* 162 */
    "uacute",          /* 163 */
    "ntilde",          /* 164 */
    "Ntilde",               /* 165 */
    NULL,               /* 166 */
    NULL,           /* 167 */
    "questiondown",          /* 168 */
    NULL,         /* 169 */
    NULL,       /* 170 */
    "onehalf",     /* 171 */
    "onequarter",        /* 172 */
    "exclamdown",             /* 173 */
    NULL,        /* 174 */
    NULL,            /* 175 */
    NULL,              /* 176 */
    NULL,         /* 177 */
    NULL,       /* 178 */
    NULL,     /* 179 */
    NULL,             /* 180 */
    NULL,                /* 181 */
    NULL,         /* 182 */
    NULL,    /* 183 */
    NULL,           /* 184 */
    NULL,       /* 185 */
    NULL,      /* 186 */
    NULL,    /* 187 */
    NULL,        /* 188 */
    NULL,           /* 189 */
    NULL,     /* 190 */
    NULL,      /* 191 */
    NULL,            /* 192 */
    NULL,            /* 193 */
    NULL,       /* 194 */
    NULL,            /* 195 */
    NULL,         /* 196 */
    NULL,             /* 197 */
    NULL,                /* 198 */
    NULL,          /* 199 */
    NULL,            /* 200 */
    NULL,            /* 201 */
    NULL,       /* 202 */
    NULL,         /* 203 */
    NULL,            /* 204 */
    NULL,            /* 205 */
    NULL,       /* 206 */
    NULL,         /* 207 */
    NULL,               /* 208 */
    NULL,            /* 209 */
    NULL,            /* 210 */
    NULL,            /* 211 */
    NULL,       /* 212 */
    NULL,            /* 213 */
    NULL,         /* 214 */
    NULL,          /* 215 */
    NULL,            /* 216 */
    NULL,            /* 217 */
    NULL,            /* 218 */
    NULL,       /* 219 */
    NULL,         /* 220 */
    NULL,            /* 221 */
    NULL,             /* 222 */
    NULL,        /* 223 */
    "alpha",            /* 224 */
    "beta",            /* 225 */
    "gamma",       /* 226 */
    "pi",            /* 227 */
    "Sigma",         /* 228 */
    "sigma",             /* 229 */
    "mu",                /* 230 */
    "tau",          /* 231 */
    "Phi",            /* 232 */
    "theta",            /* 233 */
    "omega",       /* 234 */
    "delta",         /* 235 */
    "infinity",            /* 236 */
    "phi",            /* 237 */
    "epsilon",       /* 238 */
    NULL,         /* 239 */
    NULL,               /* 240 */
    "plusminus",            /* 241 */
    NULL,            /* 242 */
    NULL,            /* 243 */
    NULL,       /* 244 */
    NULL,            /* 245 */
    "divide",         /* 246 */
    NULL,            /* 247 */
    "degree",            /* 248 */
    NULL,            /* 249 */
    "bullet",            /* 250 */
    NULL,       /* 251 */
    NULL,         /* 252 */
    "twosuperior",            /* 253 */
    NULL,             /* 254 */
    NULL          /* 255 */
};



static void *tcd_alloc(Type1_char_defs *tcd, unsigned nbytes)
/* Alloc some memory.  Bail out if can't. */
{
	char *cp;

	if ((cp = alloc_from_block(&tcd->ba, nbytes)) == NULL) {
		type1_load_error("Out of memory.  Couldn't find %d bytes", nbytes);
	}
	return (void *) cp;
}



static char *tcd_strsave(Type1_char_defs *tcd, char *s)
/*  STRSAVE  --  Allocate a duplicate of a string.  */
{
	char *c = tcd_alloc(tcd, (unsigned) (strlen(s) + 1));

	strcpy(c, s);
	return c;
}


/*****************************************************************************
 * File input.
 ****************************************************************************/

static int inbyte(FILE *fp)
/*  INBYTE  --  Get the next binary byte from the file, either in
				hexadecimal or binary mode. */
{
    int c, xd = 0, i;

    for (i = 0; i < 2; i++) {
		for (;;) {
			c = getc(fp);
			if (filemode == Binary || c == EOF)
                return c;
            if (isspace(c))
                continue;
            break;
        }
		if (islower(c))
			c = toupper(c);
        if (c >= '0' && c <= '9') {
            c -= '0';
        } else if (c >= 'A' && c <= 'F') {
            c = (c - 'A') + 10;
		} else {
            type1_load_error("Bad hex digit\n");
            return EOF;
        }
        xd = (xd << 4) | c;
    }
    return xd;
}


static int inline( FILE *fp, char *line)
/*  INLINE  --  Read a line from the file, delimited by any of the
                end of line sequences. */
{
    char *lp = line;

    while (TRUE) {
        int ch = getc(fp);

        if (ch == '\r' || ch == '\n') {
            char cn = getc(fp);
                        if (!((ch == '\r' && cn == '\n') || (ch == '\n' && cn == '\r'))) {
                ungetc(cn, fp);
            }
            *lp = EOS;
            return TRUE;
        }

        if (ch == EOF) {
			if (lp != line) {
				*lp = EOS;
                return TRUE;
			}
			return FALSE;
        }
        *lp++ = ch;
    }
}

/*****************************************************************************
 *  DECRYPT  --  Perform running decryption of file.  
 ****************************************************************************/

static unsigned short int cryptR, cryptC1, cryptC2, cryptCSR;

static void cryptinit( unsigned int key)
{
        cryptR = key;
    cryptC1 = 52845;
    cryptC2 = 22719;
}

static unsigned int decrypt(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptR >> 8));

    cryptR = (cipher + cryptR) * cryptC1 + cryptC2;

        return plain;
}

static void cstrinit(void)
{
    cryptCSR = 4330;
}

static unsigned int decstr(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptCSR >> 8));

    cryptCSR = (cipher + cryptCSR) * cryptC1 + cryptC2;

    return plain;
}

/*****************************************************************************
 *  PARSER  --  Chop up file a line at a time and decide what to put where...
 ****************************************************************************/


static void process_definition(Type1_char_defs *tcd, char *t)
/*  PROCESS_DEFINITION  --  Blunder through the font by stumbling over
                            key defining words.  */
{
if (strcmp(t, "FontInfo") == 0) 
	{
	section = FontInfo;
	} 
else if (strcmp(t, "OtherSubrs") == 0) 
	{
	section = OtherSubrs;
    } 
else if (strcmp(t, "Subrs") == 0) 
	{
	section = Subrs;
    } 
else if (strcmp(t, "CharStrings") == 0) 
	{
	section = CharStrings;
    } 
else 
	{
	switch (section) 
	  {
	  case CharStrings:
		if (tcd->ncdefs >= (NCdefs - 1)) 
			{
			type1_load_error("\nToo many CharString definitions.\n");
			}
		else 
			{
			/* Save char name */
			tcd->chardefs[tcd->ncdefs][0] = (unsigned char *) tcd_strsave(tcd,t);
			/* Clear definition */
			tcd->chardefs[tcd->ncdefs++][1] = NULL;       
            }
		break;
	  default:
		break;
      }
    }
}


int rtype1(Type1_char_defs *tcd, FILE *fp)
/*  RTYPE1  --  Load a type 1 font into memory.  */
{
    char line[256], token[256], ltoken[256], stoken[256], ptoken[256];
    char *tokenp;
	char cs[4];
    int i, ic, inEncoding = FALSE;
	long encrypt_start;

	tcd->charmap = isomap;              		/* Active mapping vector */
	tcd->ncdefs = 0;
	tcd->nsubrs = 0;
    tcd->subrs = NULL;
        section = Header;
    tcd->fullname[0] = ptoken[0] = stoken[0] = ltoken[0] = token[0] = EOS;

    /* Skip any prefix before the font header. */

    while (TRUE) {
        int ch = getc(fp);

		if (ch == EOF)
            return FALSE;
                if (ch == '%') {
                ch = getc(fp);
            if (ch == EOF)
                return FALSE;
            if (ch == '!')
                break;
        }
    }

	strcpy(line, "%!");
    inline(fp, line + 2);

    while (inline(fp, line)) {
        if (strstr(line, "/FullName ") != NULL) {
            char *cp = strchr(line, '(');

            if (cp != NULL) {
                char *ep = strchr(cp, ')');

                if (ep != NULL) {
					*ep = EOS;
                    strcpy(tcd->fullname, cp + 1);
                }
            }
        }
#ifdef NEVER
/**** It ends up the FontBBox is less than useful because it is simply
 **** not accurate.  Many fonts have characters bigger than 
 **** the bounding box. */
		else if (strstr(line, "/FontBBox") != NULL) {
			char *cp = strchr(line, '{');
			if (cp != NULL) {
				char *ep = strchr(cp, '}');

				if (ep != NULL) {
					*ep = EOS;
					if(sscanf(cp+1,"%d %d %d %d"
					, &t1_bounds.xmin,&t1_bounds.ymin
					, &t1_bounds.xmax,&t1_bounds.ymax)!=4) {
						continu_box("Invalid font bounding box");
					}
				} 
			}
		}
#endif /* NEVER */

		/* If font contains a custom encoding vector, load the encoding
		   vector into the user-defined encoding. */

        if (inEncoding) {
            if (strstr(line, " def") != NULL) {
                inEncoding = FALSE;
                tcd->charmap = tcd->usermap;
            } else {
                char *dname = strchr(line, '/');

                if (dname != NULL) {
                    if (dname[1] != '.') {
                        char token[80];

						if (sscanf(dname + 1, "%s ", token) > 0) {
                            int n;

                                dname--;
                            while (isspace(*dname) && (dname > line)) {
								dname--;
                            }
                            while (!isspace(*dname) && (dname > line)) {
                                dname--;
                            }
                            n = atoi(dname);
                            if (n < 32 || n > 255+32) {
                                type1_load_error(
         "Error parsing encoding vector.  Character index %d out of range.\n",
                                        n);
                            } else {
                                tcd->usermap[n - 32] = tcd_strsave(tcd,token);
                            }
                        }
                    }
                }
                }
		}

        /* If no explicit encoding vector has been loaded from a file and
           the font contains an encoding vector of its own, use the vector
           from the to map the characters into font slots. */

        if ((strstr(line, "/Encoding") != NULL) 
		&& (tcd->charmap != tcd->usermap)) {
            int i;

			if (strstr(line, "StandardEncoding") == NULL) {
                inEncoding = TRUE;
				tcd->usermap = tcd_alloc(tcd, NCdefs*sizeof(*(tcd->usermap)));
            }
		}
                if (strstr(line, "eexec") != NULL)
            break;
    }

    for (i = 0; i < 6; i++) {
        (void) getc(fp);              /* Beats me, but there's 6 trash bytes */
    }

	/* O.K., we're now into the encrypted portion of the file.
       Determine if it's ASCII or binary and process accordingly. */


	encrypt_start = ftell(fp);
	cs[0] = getc(fp);

    /* 
	   (John Walker's comment on how to tell hex from binary.)
	   "Adobe Type 1 Font Format Version 1.1", ISBN 0-201-57044-0 states
       on page 64 that one distinguishes an ASCII from a Hexadecimal
       font file by two tests:

            * The first ciphertext byte must not be an ASCII white space
                  character (blank, tab, carriage return or line feed).
			* At least one of the first 4 ciphertext bytes must not be one
              of the ASCII hexadecimal character codes (a code for 0-9,
              A-F, or a-f).  These restrictions can be satisfied by adjusting
              the random plaintext bytes as necessary.

       Well, notwithstanding this statement, Adobe's own Helvetica Bold
       Narrow Oblique file furnished with Adobe Type Manager for Windows
       has a carriage return as the first byte after the eexec invocation.
       Consequently, I turned off recognition of a hex file by the
       presence of a carriage return.  Note also the "-B" and "-H"
       command line switches that you can use to override the automatic
       recognition of file format. */

	if (forcemode != Unknown) {
        filemode = forcemode;
        } else {
        if (cs[0] == ' ' || cs[0] == '\t' ||
            /* cs[0] == '\r' || */
			cs[0] == '\n') {
            filemode = Hex;
        } else {
            for (i = 1; i < 4; i++) {
                cs[i] = getc(fp);
            }
			filemode = Hex;
            for (i = 0; i < 4; i++) {
                if (!((cs[i] >= '0' && cs[0] <= '0') ||
					  (cs[i] >= 'A' && cs[0] <= 'F') ||
                      (cs[i] >= 'a' && cs[0] <= 'f'))) {
                    filemode = Binary;
                    break;
                }
            }
        }
    }

	fseek(fp, encrypt_start, SEEK_SET);	/* Reread encrypted random bytes as
										 * the decrypter depends on everything
										 * from encrypt_start on going through
										 * inbyte(). */

    cryptinit(55665);

    /* Now burn the first four plaintext bytes. */

	for (i = 0; i < 4; i++) {
        (void) decrypt(inbyte(fp));
    }
    tokenp = token;
	while ((ic = inbyte(fp)) != EOF) {
        int dc = decrypt(ic);

        if (isspace(dc)) {
            if (tokenp > token) {
                *tokenp = EOS;
                strcpy(ptoken, stoken);
                strcpy(stoken, ltoken);
                strcpy(ltoken, token);
                tokenp = token;
                if (strcmp(ltoken, "closefile") == 0) {
                    return TRUE;
                }
                if (ltoken[0] == '/') {
                        process_definition(tcd, ltoken + 1);
                }
				if (strcmp(ltoken, "array") == 0 && section == Subrs &&
                    tcd->subrs == NULL) {
                    int l = (tcd->nsubrs = atoi(stoken)) * sizeof(char *);

                    tcd->subrs = tcd_alloc(tcd, l);
					tcd->subrl = tcd_alloc(tcd, tcd->nsubrs * sizeof(int));
                    memset(tcd->subrs, 0, l);
                }
            }
        } else {
            *tokenp++ = dc;
		}

        if (isspace(dc) 
		&&  ((strcmp(ltoken, "-|") == 0) || (strcmp(ltoken, "RD") == 0))) {
            int l = atoi(stoken), j;
            cstrinit();

            for (j = 0; j < 4; j++) {
                (void) decstr(decrypt(inbyte(fp)));
                }

            /* Process the charstring depending on the section it's
                   encountered within. */

            switch (section) {
                case CharStrings:
                    if (tcd->ncdefs > 0 
					&& tcd->chardefs[tcd->ncdefs - 1][1] == NULL) {
                        unsigned char *csd = tcd_alloc(tcd, l - 4);

                        tcd->chardefs[tcd->ncdefs - 1][1] = csd;
                        l -= 4;
						tcd->chardl[tcd->ncdefs - 1] = l;
						while (l-- > 0) {
                            *csd++ = decstr(decrypt(inbyte(fp)));
                        }
                    } else {
                        type1_load_error("\nUnexpected data in CharStrings.\n");
                    }
                    break;

				case Subrs:
                    j = atoi(ptoken); /* Subr number */
					if (j < 0 || j >= tcd->nsubrs) {
							type1_load_error("\nSubr %d out of range (0-%d).\n",
                            j, tcd->nsubrs);
                    } else {
                        if (l > 4) {
                            unsigned char *csd = tcd_alloc(tcd, l - 4);

                            tcd->subrs[j] = csd;
                            l -= 4;
                            tcd->subrl[j] = l;
                            while (l-- > 0) {
                                *csd++ = decstr(decrypt(inbyte(fp)));
                            }
                        }
                    }
                    break;

                default:
						/* Oh my, what do we do here?  Shouldn't happen.
						 * Let's just pretend it didn't... */
                        break;
			}
            ltoken[0] = EOS;
        }
    }
    return TRUE;
}

static void tcd_freez(Type1_char_defs **ptcd)
/* Free up memory associated with Type1_char_defs. */
{
if (ptcd != NULL && *ptcd != NULL)
	{
	destroy_block_allocator(&(*ptcd)->ba);
	pj_freez(ptcd);
	}
}

static Errcode read_type1_font(FILE *fp, Type1_char_defs **ptcd)
{
Errcode err = Success;
Type1_char_defs *tcd;

if ((tcd = pj_zalloc(sizeof(*tcd))) == NULL)
	err = Err_no_memory;
else
	{
	construct_block_allocator(&tcd->ba, 512L, pj_zalloc, pj_free);
	if (Success != (err = setjmp(type1_load_errhandler)))
		{	/* Got here via longjmp. */
		tcd_freez(&tcd);
		}
	else
		{
		rtype1(tcd, fp);
		}
	}
*ptcd = tcd;
return err;
}

Errcode load_type1_font(char *file_name, Type1_char_defs **ptcd)
{
FILE *file;
Errcode err;

if ((file = fopen(file_name, "rb")) == NULL)
	return(errno);
err = read_type1_font(file, ptcd);
fclose(file);
return err;
}



/*****************************************************************************
 *****************************************************************************
 ** The Interpreter Section.  This section deals with interpreting the
 ** little reverse-polish-notation language that describes the letters in
 ** the font.  
 *****************************************************************************
 ****************************************************************************/


typedef struct font_output
	{
	/* This guy tells the interpreter where to send drawing commands. */
	Errcode (*shape_open)(int x, int y);
	Errcode (*shape_close)(void);
	Errcode (*shape_point)(int x, int y);
	} Font_output;


enum cscommand {
/*  Charstring command op-codes.  */
	Unused_0,
	Hstem,
	Unused_2,
	Vstem,
	Vmoveto,
	Rlineto,
	Hlineto,
	Vlineto,
	Rrcurveto,
	Closepath,
    Callsubr,
    Return,
    Escape,
    Hsbw,
    Endchar,
    Unused_15,
    Unused_16,
    Unused_17,
    Unused_18,
    Unused_19,
    Unused_20,
    Rmoveto,
    Hmoveto,
    Unused_23,
    Unused_24,
    Unused_25,
    Unused_26,
    Unused_27,
    Unused_28,
    Unused_29,
    Vhcurveto,
    Hvcurveto,

    /* 12 x commands */

    Dotsection,
    Vstem3,
    Hstem3,
    Unused_12_3,
    Unused_12_4,
    Unused_12_5,
    Seac,
    Sbw,
    Unused_12_8,
    Unused_12_9,
    Unused_12_10,
    Unused_12_11,
    Div,
    Unused_12_13,
    Unused_12_14,
    Unused_12_15,
    Callothersubr,
    Pop,
    Unused_12_18,
    Unused_12_19,
    Unused_12_20,
    Unused_12_21,
    Unused_12_22,
    Unused_12_23,
    Unused_12_24,
    Unused_12_25,
    Unused_12_26,
    Unused_12_27,
    Unused_12_28,
    Unused_12_29,
    Unused_12_30,
    Unused_12_31,
    Unused_12_32,
    Setcurrentpoint
};


#define StackLimit  25
#define OtherLimit  10                /* Maximum othersubr return values */

#define Sl(n) if (sp < (n)) {fflush(stdout); fprintf(stderr,"\nStack underflow.\n"); return;}
#define Npop(n) sp -= (n)
#define So(n) if ((sp + (n)) > StackLimit) {fflush(stdout); fprintf(stderr, "\nStack overflow.\n"); return;}
#define Clear() sp = 0



#define S0  stack[sp - 1]
#define S1  stack[sp - 2]
#define S2  stack[sp - 3]
#define S3  stack[sp - 4]
#define S4  stack[sp - 5]
#define S5  stack[sp - 6]

static long stack[StackLimit];        /* Data stack */
static int sp;                        /* Stack pointer */
static long osres[OtherLimit];        /* Results from othersubrs */
static int orp;                       /* Othersubr result pointer */

#define ReturnStackLimit 10

static unsigned char *rstack[ReturnStackLimit]; /* Return stack */
static int rsp;                       /* Return stack pointer */

static int curx, cury;			      /* The current point */
static int flexing;			          /* If a Flex in progress ? */
static int flexx, flexy;              /* Flex current position */
static int sidebear[2], charwid[2];   /* Character sidebearing and width */
static Boolean pathopen;                  /* Path open ? */

static Font_output *fo;				  /* Place to put shapes interp draws. */
static int bnum;                  	  /* Line segments per Bezier curve */

static int pcount;

#define AddPoint(x,y) {fo->shape_point(x,y); ++pcount;}
#define ClosePath() {if (pcount) fo->shape_close();}

static void Opath()
/************************************************************************
 * Start new closed shape if not in the middle of one already.
 ************************************************************************/
{
        if (!pathopen)
        {
                pathopen = TRUE;
				pcount = 0;
                fo->shape_open(curx,cury);
        }
}

static void Dpath()
/************************************************************************
 * Close current shape if any and start a new one.
 ************************************************************************/
{
        if (pathopen)
        {
                ClosePath();
                pathopen = FALSE;
        }
        Opath(fo);
}

/*  BEZIER  --  Evaluate a Bezier curve defined by four control
                points.  */


static void bezier(long x0, long y0
, long x1, long y1, long x2, long y2, long x3, long y3, int n)
{
        int i;
        fixpoint ax, bx, cx, ay, by, cy, t, t_squared, t_cubed;
        fixpoint dt = FIXPOINT_ONE/n;
		fixpoint x0f = FVAL(x0), y0f = FVAL(y0);

        ax = FVAL(-x0 + 3 * x1 - 3 * x2 + x3);
        bx = FVAL(3 * x0 - 6 * x1 + 3 * x2);
        cx = FVAL(3 * (x1 - x0));

        ay = FVAL(-y0 + 3 * y1 - 3 * y2 + y3);
        by = FVAL(3 * y0 - 6 * y1 + 3 * y2);
        cy = FVAL(3 * (y1 - y0));

        t = dt;
        for (i = 1; i <= n; i++) 
			{
	        fixpoint vx, vy;

			t_squared = FT(t,t);
			t_cubed = (t*t*t)>>(2*FIXPOINT_SHIFT);
			vx = FP(FP(FT(ax,t_cubed),FT(bx,t_squared)),FP(FT(cx,t),x0f));
			vy = FP(FP(FT(ay,t_cubed),FT(by,t_squared)),FP(FT(cy,t),y0f));
	        /*   vx = ax * t * t * t + bx * t * t + cx * t + x0; */
	        /*   vy = ay * t * t * t + by * t * t + cy * t + y0; */
	        t += dt;
	        AddPoint(FINT(vx),FINT(vy));
	        }
        curx = x3;
        cury = y3;
}

static void othersubr(int procno, int nargs, int argp)
{
    static int flexp;                 /* Flex argument pointer */
    static int flexarg[8][2];

    orp = 0;                          /* Reset othersubr result pointer */

    switch (procno) {
        case 0:                       /* Flex */
			bezier(flexarg[0][X], flexarg[0][Y],
				   flexarg[2][X], flexarg[2][Y],
				   flexarg[3][X], flexarg[3][Y],
				   flexarg[4][X], flexarg[4][Y], bnum);
			bezier(flexarg[4][X], flexarg[4][Y],
				   flexarg[5][X], flexarg[5][Y],
				   flexarg[6][X], flexarg[6][Y],
				   flexarg[7][X], flexarg[7][Y], bnum);
            osres[0] = stack[argp + 1];
            osres[1] = stack[argp + 2];
            flexing = FALSE;          /* Terminate flex */
            break;

        case 1:                       /* Flex start */
            flexing = TRUE;           /* Mark flex underway */
            flexx = curx;
            flexy = cury;
            flexp = 0;
            /* Note fall-through */
        case 2:                       /* Flex argument specification */
            flexarg[flexp][X] = flexx;
            flexarg[flexp++][Y] = flexy;
            break;

        case 3:                       /* Hint replacement */
            osres[0] = 3;             /* Null hint replacement subr */
            break;

        default:
            fprintf(stderr, "\nCall to undefined othersubr %d\n",
                procno);
    }
}


/*  EXCHARS  --  Execute charstring.  */

void type1_exchars(Type1_char_defs *tcd
,	Font_output *output, int bezier_points, unsigned char *cp)
{
    int sub;

	fo = output;					  /* Direct output somewhere. */
	bnum = bezier_points;			  /* Set how many points in bezier curve. */
    sp = rsp = 0;                     /* Reset stack pointer */
	pathopen = FALSE;
	flexing = FALSE;          

    while (TRUE) {
        int c = *cp++;

        if (c < 32) {
            /* Command */
            if (c == 12) {
                /* Two byte command */
                c = *cp++ + 32;
            }

            switch (c) {

                /* Commands for Starting and Finishing */

                case Endchar:     /* 14: End character */
                    Clear();
					return;

                case Hsbw:        /* 13:  Set horizontal sidebearing */
                        Sl(2);
                        curx = sidebear[X] = S1;
                        cury = sidebear[Y] = 0;
                        charwid[X] = S0;
                        charwid[Y] = 0;
                        Clear();
                        break;

                case Seac:        /* 12-6:  Standard encoding accented char */
                        Sl(5);
                        Clear();
                        return;

                case Sbw:         /* 12-7:  Sidebearing point (x-y) */
                        Sl(4);
                        curx = sidebear[X] = S3;
                        cury = sidebear[Y] = S2;
                        charwid[X] = S1;
                        charwid[Y] = S0;
                        Clear();
                        break;

                /* Path Construction Commands */

                case Closepath:       /* 9:  Close path */
                        if (!pathopen) {
	                        fflush(stdout);
							fprintf(stderr, "\nClosepath, yet no path open.\n");
                        } else {
							ClosePath();
                        }
                        pathopen = FALSE;
                        Clear();
                        break;

                case Hlineto:         /* 6: Horizontal line to */
                        Sl(1);
                        Opath();
                        curx = curx + S0;
                        AddPoint(curx, cury);
                        Clear();
                        break;

                case Hmoveto:         /* 22:  Horizontal move to */
                        Sl(1);
	                    if (flexing)
	                        flexx += S0;
						else
						{
	                        curx += S0;
	                        Dpath();
						}
                        Clear();
                        break;

                case Hvcurveto:       /* 31:  Horizontal-vertical curve to */
                        Sl(4);
                        Opath();
                        bezier(curx, cury, curx + S3, cury,
                           curx + S3 + S2, cury + S1,
                           curx + S3 + S2, cury + S1 + S0, bnum);
                        Clear();
                        break;

                case Rlineto:         /* 5:  Relative line to */
                        Sl(2);
                        Opath();
                        curx += S1;
                        cury += S0;
                        AddPoint(curx, cury);
                        Clear();
                        break;

                case Rmoveto:         /* 21:  Relative move to */
                        Sl(2);
	                    if (flexing) 
						{
	                        flexx += S1;
	                        flexy += S0;
						}
						else
						{
	                        curx += S1;
	                        cury += S0;
	                        Dpath();
						}
                        Clear();
                        break;

                case Rrcurveto:       /* 8:  Relative curve to */
                        Sl(6);
                        Opath();
                        bezier(curx, cury, curx + S5, cury + S4,
                           curx + S5 + S3, cury + S4 + S2,
                           curx + S5 + S3 + S1, cury + S4 + S2 + S0, bnum);
                        Clear();
                        break;

                case Vhcurveto:       /* 30:  Vertical-horizontal curve to */
                        Sl(4);
                        Opath();
                        bezier(curx, cury, curx, cury + S3,
                           curx + S2, cury + S3 + S1,
                           curx + S2 + S0, cury + S3 + S1, bnum);
                        Clear();
                        break;

                case Vlineto:         /* 7:  Vertical line to */
                        Sl(1);
                        Opath();
                        cury = cury + S0;
                        AddPoint(curx,cury);
                        Clear();
                        break;

                case Vmoveto:         /* 4:  Vertical move to */
                        Sl(1);
	                    if (flexing)
	                        flexy += S0;
						else
						{
	                        cury += S0;
	                        Dpath();
						}
                        Clear();
                        break;

                /*  Hint Commands  */

                case Dotsection:      /* 12-0:  Dot section */
                        Clear();
                        break;

                case Hstem:           /* 1:  Horizontal stem zone */
                        Sl(2);
                        Clear();
                        break;

                case Hstem3:          /* 12-2:  Three horizontal stem zones */
                        Sl(6);
                        Clear();
                        break;

                case Vstem:           /* 3:  Vertical stem zone */
                        Sl(2);
                        Clear();
                        break;

                case Vstem3:          /* 12-1:  Three vertical stem zones */
                        Sl(6);
                        Clear();
                        break;

                /* Arithmetic command */

                case Div:             /* 12 12:  Divide */
                        Sl(2);
                        S1 = (S1 + (S0 / 2)) / S0;
                        Npop(1);
                        break;

                /* Subroutine Commands */

                case Callothersubr:   /* 12 16:  Call other subroutine */
                        Sl(2);
                        Sl(2 + S1);
	                    othersubr(S0, S1, sp - (2 + S1));
                        Npop(2 + S1);
                        break;

                case Callsubr:        /* 10:  Call subroutine */
                        Sl(1);
                        if (rsp >= ReturnStackLimit) {
                        fflush(stdout);
						fprintf(stderr, "\nReturn stack overflow.\n");
                        return;
                        }
                        rstack[rsp++] = cp;
                        sub = S0;
                        Npop(1);
                        if (sub < 0 || sub >= tcd->nsubrs) {
                        fflush(stdout);
						fprintf(stderr
						, 	"\nSubr number %d out of range in call.\n", sub);
                        return;
                        }
                        if (tcd->subrs[sub] == NULL) {
                        fflush(stdout);
						fprintf(stderr, "\nSubr %d is undefined.\n", sub);
                        return;
                        }
						/* Set instruction pointer to subr code */
                        cp = tcd->subrs[sub];  
                        break;

                case Pop:      /* 12 17:  Return argument from othersubr */
                        So(1);
						stack[sp++] = 3;  /****?????*****/
                        break;

                case Return:   /* 11:  Return from subroutine */
                        if (rsp < 1) {
                        fflush(stdout);
						fprintf(stderr, "\nReturn stack underflow.\n");
                        return;
                        }
                        cp = rstack[--rsp]; /* Restore pushed call address */
                        break;

                case Setcurrentpoint: /* 12 33:  Set current point */
                        Sl(2);
	                    if (S1 != curx || S0 != cury) 
						{
	                        curx = S1;
							cury = S0;
						}
                        Clear();
                        break;
                }

        } else {
                long n;

                if (c <= 246) {
                n = c - 139;
                } else if (c <= 250) {
                n = ((c - 247) << 8) + *cp++ + 108;
                } else if (c < 255) {
                n = -((c - 251) << 8) - *cp++ - 108;
                } else {
                char ba[4];

                ba[0] = *cp++;
                ba[1] = *cp++;
                ba[2] = *cp++;
                ba[3] = *cp++;
                n = (((((ba[0] << 8) | ba[1]) << 8) | ba[2]) << 8) | ba[3];
            }
            if (sp >= StackLimit) {
                fflush(stdout);
                fprintf(stderr, "\nData stack overflow.\n");
            } else {
                stack[sp++] = n;
            }
        }
    }
}

/*****************************************************************************
 *****************************************************************************
 ** Testing Code.
 *****************************************************************************
 ****************************************************************************/

static int cx,cy;	/* Current coordinate in shape. */
static int fx,fy;	/* First coordinate in shape */

#define X_TO_SCREEN(x) (100 + x/3)
#define Y_TO_SCREEN(y) (400 - y/3)

static Errcode outline_open(int x, int y)
{
		fx = cx = X_TO_SCREEN(x);
		fy = cy = Y_TO_SCREEN(y);
		return Success;
}

static Errcode outline_close(void)
{
	return render_line(cx,cy,fx,fy);
}

static Errcode outline_point(int x, int y)
{
	int nx,ny;
	Errcode err;

	++pcount;
	nx = X_TO_SCREEN(x);
	ny = Y_TO_SCREEN(y);
	err = render_line(cx,cy,nx,ny);
	cx = nx;
	cy = ny;
	return err;
}

static Font_output outline_output = 
	{outline_open, outline_close, outline_point};

void type1_stop()
{
}

Errcode type1_show1(Type1_char_defs *tcd, 
	int ix, int  intween, int  scale)
{
	Errcode err;
	unsigned char *chardef;
	
	if ((chardef = tcd->chardefs[ix][1]) != NULL)
	{
		if((err = make_render_cashes()) < Success)
			return(err);
		gftext(vb.pencel,get_menu_font(),tcd->chardefs[ix][0],
			   0, 0, 31, pj_mask1blit);
		type1_exchars(tcd, &outline_output, 8, chardef);
		if (vs.cycle_draw) cycle_ccolor();
		free_render_cashes();
	}
	return Success;
}

void type1_show(Type1_char_defs *tcd)
{
	do_autodraw(type1_show1, tcd);
}

test_type1()
{
	static char filename[80] = "F:\\PAA\\FONT\\PS1\\COB.PFB";
	Type1_char_defs *tcd;

	if (pj_get_filename("Select PostScript Type 1 Font"
	,	".PFB", "View", filename, filename, FALSE, NULL, NULL) != NULL)
	{
		if (load_type1_font(filename, &tcd) >= Success)
			{
			type1_show(tcd);
			tcd_freez(&tcd);
			}
	}
}

/************** Stuff for calculating bounding box. ***************/
static void init_type1_bounding_box(Type1_bounding_box *b)
{
	b->xmin = b->ymin = INT_MAX;
	b->xmax = b->ymax = INT_MIN;
}

static void expand_type1_bounding_box(Type1_bounding_box *b, int x, int y)
{
	if (x < b->xmin)
		b->xmin = x;
	if (x > b->xmax)
		b->xmax = x;
	if (y < b->ymin)
		b->ymin = y;
	if (y > b->ymax)
		b->ymax = y;
}

Type1_bounding_box bounds;
Type1_bounding_box bound1;

static Errcode bound_open(int x, int y)
{
	expand_type1_bounding_box(&bounds, x, y);
	expand_type1_bounding_box(&bound1, x, y);
	return Success;
}

static Errcode bound_close(void)
{
	return Success;
}

static Errcode bound_point(int x, int y)
{
	expand_type1_bounding_box(&bounds,x,y);
	expand_type1_bounding_box(&bound1,x,y);
	return Success;
}

static Font_output bound_output = 
	{bound_open, bound_close, bound_point};

void bound_type1(Type1_char_defs *tcd, FILE *output)
/* Calculate bounding box for the whole thing and print it and the
 * normal font bounding box. */
{
int i;
char *chardef;

init_type1_bounding_box(&bounds);
for (i=0; i<tcd->ncdefs; ++i)
	{
	if ((chardef = tcd->chardefs[i][1]) != NULL)
		{
		init_type1_bounding_box(&bound1);
		type1_exchars(tcd, &bound_output, 8, chardef);
		fprintf(output, "\t%s (%d %d) to (%d %d)\n"
		,	tcd->chardefs[i][0]
		 ,	bound1.xmin, bound1.ymin, bound1.xmax, bound1.ymax);
		}
	}
fprintf(output, 
	 "chars_box (%d %d) to (%d %d)\n\n"
	 ,	bounds.xmin, bounds.ymin, bounds.xmax, bounds.ymax);
}

void print_one_bounds(char *filename, FILE *output)
{
Type1_char_defs *tcd;

fprintf(output, "%s\n", filename);
if (load_type1_font(filename,&tcd) >= Success)
	{
	bound_type1(tcd, output);
	tcd_freez(&tcd);
	}
}

btest_type1()
{
	Errcode err;
	Names *dir_list;
	Names *pt;
	FILE *bound_file;
	char full_name[80];
	char *dir = "F:\\PAA\\FONT\\PS1";


	if ((err = build_dir_list(&dir_list, "*.pfb", FALSE, dir))
	>= Success)
		{
		if ((bound_file 
		=  fopen("F:\\PAA\\FONT\\PS1\\BOUNDS.TXT", "w")) != NULL)
			{
			for (pt = dir_list; pt != NULL; pt = pt->next)
				{
				sprintf(full_name, "%s\\%s", dir, pt->name);
				top_textf(full_name);
				print_one_bounds(full_name, bound_file);
				}
			fclose(bound_file);
			}
		free_wild_list(&dir_list);
		}
}

