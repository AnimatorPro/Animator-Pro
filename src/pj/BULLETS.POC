
// show'em.poc - A program which makes fancy bulleted text slide shows
// out of simple text files.   This program was inspired by
// Mike Edmond's show'em.poc.
//
// Copyright 1992 Dancing Flame
// This file may be copied, used, and modified by owners of
// the Autodesk Animator Pro.

// Need to make sure we're running the right version of Animator Pro.
// This next line will report an error during the "compile" phase
// if we're not.
#if __POCO__ < 181
	#error "You must upgrade to Animator Pro 1.3 or later to run this program"
#endif

#include <stdio.h>
#include <ctype.h>

//-------------------------------------------------------------------------
//		Defines and stuff you know and love
//-------------------------------------------------------------------------
#define TRUE 1
#define FALSE 0
#define Success 0
#define EOS 0
#define ESCAPE_KEY 0x1b

typedef struct 
	{
	int r,g,b;
	} RGB;
typedef struct
	{
	int x,y;
	} XY;

//-------------------------------------------------------------------------
//				Menu Definitions
//-------------------------------------------------------------------------

static char mm_header[] = "Show'em Slide Maker";
static char *mm_choices[] = 
      {
	  "Help",
      "Create Slide Show",
      "Set Slide Style",
      "Exit",
      };
static enum { MAIN_EXIT, MAIN_HELP, MAIN_CREATE, MAIN_FORMAT};

static char mm_help[] =
"This program creates a set of slides from simple text. "
"To enter the text for your slides select \"Create Slide Show\" "
"and then \"Help\" for more information.\n"
"\n"
"The slides each have a background image, a logo, a title, and some "
"bulleted text items.  You can specify the imagery and fonts used in the "
"slides with the \"Set Slide Style\" command.\n"
"\n"
"This program will create a numbered series of single frame .FLC files,  and a "
"player script (.SCR) file.  To see your presentation in it's final form "
"exit Animator Pro and invoke the AniPlay program with the name of your "
"script - typing something like:\n"
"	aniplay bullet.scr\n"
	;

static char css_header[] = "Create Slide Show";
static char *css_choices[] =
	{
	"Help",
	"Edit Text",
	"Load Text",
	"Save Text",
	"Preview",
	"Render Slides",
	"Return",
	};
static enum {CSS_EXIT, CSS_HELP, CSS_EDIT, CSS_LOAD, CSS_SAVE
, CSS_PREVIEW, CSS_RENDER};
static char css_help[] =
"To create a slide show you define the text for each slide, and then select "
"\"Render Slides\".  You can load the slide text from an ascii text file "
"or you can enter the text directly by selecting \"Edit Text\".  "
"Each paragraph of text (separated by a blank line) will create one slide.  "
"The first line of each paragraph will become the title.  Subsequent "
"lines will become bullet items.\n"
	;

static char ssf_header[] = "Set Slide Style";
static char *ssf_choices[] =
	{
	"Help",
	"Title",
	"Items",
	"Bullet",
	"Background",
	"Logo",
	NULL,	//"Antialias",
	"Load Style",
	"Save Style",
	"Return",
	};
static enum {SSF_EXIT, SSF_HELP, SSF_TITLE, SSF_ITEMS, SSF_BULLET
, SSF_BACKGROUND, SSF_LOGO, SSF_ANTIALIAS, SSF_LOAD, SSF_SAVE};
static char ssf_help[] =
"This menu controls the slide style.\n"
"Here are the individual options:\n"
"\n" 
"Title - Set the title color, font,\n"
"   position, and justification.\n"
"Items - Set the item color and font.\n"
"Bullet - Set image used for bullet.\n"
"   May be none, a circle, or a cel.\n"
"Background - Set the background image.\n"
"   Either a gradient or solid color,\n"
"   or an image from a file.\n"
"Logo - Load a cel to use as logo,\n"
"   position it, or don't use a logo.\n"
"Load Style - Load all of above from\n"
"   a style file.\n"
"Save Style - Save a style file.\n"
	;

static char title_header[] = "Title Style";
static char *title_choices[] =
	{
	"Title Color",
	"Title Font",
	"Position Title",
	"Return",
	};
static enum {TITLE_EXIT, TITLE_COLOR, TITLE_FONT, TITLE_POSITION};

static char item_header[] = "Item Style";
static char *item_choices[] =
	{
	"Item Color",
	"Item Font",
	"Return",
	};
static enum {ITEM_EXIT, ITEM_COLOR, ITEM_FONT};

static char bullet_header[] = "Set Bullet Image";
static char *bullet_choices[] =
	{
	"Circle",
	"Load Bullet Cel",
	"None",
	"Return",
	};
static enum {BULLET_EXIT
, BULLET_CIRCLE, BULLET_USE_CEL, BULLET_NONE};

static char background_header[] = "Set Background Image";
static char *background_choices[] =
	{
	"Set Color",
	"Solid",
	"Gradient",
	"Load Background Pic",
	"Return",
	};
static enum {BACKGROUND_EXIT, BACKGROUND_GET_COLOR
, BACKGROUND_SOLID, BACKGROUND_GRADIENT, BACKGROUND_USE_PIC};

static char logo_header[] = "Logo Style";
static char *logo_choices[] =
	{
	"Load Logo Cel",
	"None",
	"Position Logo",
	"Return",
	};
static enum {LOGO_EXIT, LOGO_USE_CEL, LOGO_NONE, LOGO_POSITION};


//-------------------------------------------------------------------------
//  	Some Utility Routines maybe we'll use in  another poco program too
//-------------------------------------------------------------------------

Boolean ignore_changes()
/*
 * 	If have made changes to flic make sure it's ok to ignore them.
 */
{
	int changes;
	static char replace_changes_prompt[]  = "Okay to discard current flic?\n"
											 "(You have unsaved changes)"
									 ;

	if ((changes = GetChangeCount()) != 0)
		return Qquestion(replace_changes_prompt);
	else
		return TRUE;
}

Boolean overwrite_ok(char *file_name)
/*
 * 	If file exists make sure it's ok to overwrite it.
 */
{
	if (DosExists(file_name))
		return Qquestion("Write over old %s", file_name);
	else
		return TRUE;
}

FILE *must_open(char *file_name, char *mode)
/*
 * Open file to read.  Complain if can't.
 */
{
	FILE *f;
	char c = tolower(mode[0]);

	if ((f = fopen(file_name, mode)) == NULL)
		{
		if (c == 'w')
			Qtext("Can't create %s, sorry\n", file_name);
		else
			Qtext("Can't find %s, sorry\n", file_name);
		}
	return f;
}

void *need_memory(unsigned size)
/*
 * Request memory.  Squawk if can't get it.
 */
{
	void *pt;

	if ((pt = malloc(size)) == NULL)
		Qtext("Couldn't find %d bytes of free memory, sorry", size);
	return pt;
}

Boolean copy_file(char *source, char *dest)
/*
 *	Copy one file to another. 
 */
{
	FILE *s, *d;
	int c;
	Boolean ok = FALSE;

	if ((s = must_open(source, "rb")) != NULL)
		{
		if ((d = must_open(dest, "wb")) != NULL)
			{
			while ((c = getc(s)) != EOF)
				{
				if (putc(c, d) == EOF)
					{
					Qtext("Couldn't copy %s to %s,  %s truncated"
					, source, dest, dest);
					break;
					}
				}
			fclose(d);
			}
		fclose(s);
		ok = TRUE;
		}
	return ok;
}


char *skip_space(char *pt)
/*
 *	Return first non-space character in string, or NULL if all spaces
 *  until end.
 */
{
if (pt == NULL)
	return NULL;
while (isspace(*pt))
	++pt;
if (*pt == EOS)
	return(NULL);
return(pt);
}

char *skip_to_space(char *pt)
/*
 *	Return first space character (or EOS) character in string. 
 */
{
char c;

for (;;)
	{
	c = *pt;
	if (isspace(c) || c == EOS)
		break;
	++pt;
	}
return(pt);
}

void file_name_only(char *path, char *file_only)
/*
 *	Extract just the file name from a path.   That is
 *  convert C:\ANI\DUCKY.FLI  to   DUCKY.FLI
 */
{
char dev[4], dir[70], file[10], suff[5];	/* FNsplit/merge stuff */

fnsplit(path,dev,dir,file,suff);
sprintf(file_only, "%s%s", file, suff);
}

void translate_to_rgb(int index, RGB *color)
/*
 * Look up color map index and store it in color
 */
{
	GetColorMap(index, &color->r, &color->g, &color->b);
}

//-------------------------------------------------------------------------
// Some font related stuff.
//-------------------------------------------------------------------------
void full_font_name(char *name, char *path)
/*
 * This removes any existing directory info from name and replaces it
 * with the current font directory.  The result is in path.
 */
{
char name_only[PATH_SIZE];

GetFontDir(path);
file_name_only(name, name_only);
strcat(path, name_only);
}


ErrCode load_font(char *name)
/*
 * Load font, looking if necessary in the font directory for it.
 * Also keep last font name used for reference to prevent unnecessary
 * reloading of font.
 */
{
char fdir[80];
ErrCode err;
static char last_font_name[PATH_SIZE];


if (strcmp(last_font_name, name) == 0)
	return Success;
if ((err = LoadFont(name)) < Success)
	{
	full_font_name(name, fdir);
	err =  Qerror(LoadFont(fdir), "Loading font %s", fdir);
	}
strcpy(last_font_name, name);
return err;
}

typedef struct
/*
 * Holds all pertinant info about type face - font size spacing data.
 */
	{
	char name[PATH_SIZE];
	int size, spacing, leading;
	} Font_style;

void get_font_style(Font_style *fs)
/*
 * Get current status of font into Font_style
 */
{
	GetFontName(fs->name);
	fs->spacing = GetFontSpacing();
	fs->leading = GetFontLeading();
	fs->size = FontHeight() - fs->leading;
}


Boolean set_font_style(Font_style *fs)
/*
 *	Set font from Font_style
 */
{
	if (load_font(fs->name) < Success)
		return FALSE;
	ScaleFont(fs->size);
	SetFontSpacing(fs->spacing);
	SetFontLeading(fs->leading);
	return TRUE;
}


//-------------------------------------------------------------------------
// Some stuff to read a file a line at a time and report errors.
//-------------------------------------------------------------------------
typedef struct 
/* This structure keeps track of where we are in a file. */
	{
	FILE *f;
	char *file_name;
	char *line_buf;
	int buf_size;
	int current_line;
	} Line_file;

Boolean line_file_open(Line_file *f, char *file_name, char *buf, int buf_size)
/*
 * Open up a file and set up structure to read it one line at a time
 */
{
	if ((f->f = must_open(file_name, "r")) == NULL)
		return FALSE;
	f->file_name = file_name;
	f->line_buf = buf;
	f->buf_size = buf_size;
	f->current_line = 0;
	return TRUE;
}

void line_file_close(Line_file *f)
/*
 * Close a line file.
 */
{
	if (f->f != NULL)
		{
		fclose(f->f);
		f->f = NULL;
		}
}


Boolean read_line(Line_file *file)
/* 
 * Read a line from file.  Return FALSE at EOF.
 */
{
	char *pt;

	pt = file->line_buf;
	pt = fgets(pt, file->buf_size, file->f);
	++file->current_line;
	return (pt != NULL);
}

Boolean must_read_line(Line_file *file)
/* 
 * Read a line from file 
 * complain if it's not there.
 */
{
	if (!read_line(file))
		{
		Qtext("%s %d:  file too short\n"
		,  file->file_name, file->current_line);
		return FALSE;
		}
	return TRUE;
}

void expecting_got(Line_file *file, char *expecting, char *got)
/*
 * Print "expecting/got" error message
 */
{
	if (got == NULL)
		got = "(NULL)";
	if (skip_space(got) == NULL)
		got = "<cr>";
	Qtext("%s line %d:\nExpecting %s got %s"
	, file->file_name, file->current_line
	, expecting, got);
}


Boolean next_string(Line_file *file, char **input,  char *result, int max_size)
/*
 *	Get next space separated token from input (and advance input).
 */
{
	char *start;
	char *end;
	int size;

	if ((start = skip_space(*input)) == NULL)
		return FALSE;
	end = skip_to_space(start);
	size = end - start;
	if (size >= max_size)
		{
		Qtext("%s %d:\nToken \"%s\" too long.\nCan only handle %d characters\n"
		,	file->file_name, file->current_line, start, max_size-1);
		*input = NULL;
		return FALSE;
		}
	strncpy(result, start, size);
	result[size] = EOS;
	*input = end;
	return TRUE;
}

Boolean next_number(Line_file *file, char **input, int *result)
/*
 *	Get next number from string.  
 *  Put numerical result in *result.  Complain if it's not a number.
 */
{
	char num_buf[64];	/* Long enough for any reasonable integer! */

	if (!next_string(file, input, num_buf, sizeof(num_buf)))
		{
		expecting_got(file, "number", "<cr>");
		return FALSE;
		}
	if (!isdigit(num_buf[0]))
		{
		expecting_got(file, "number", num_buf);
		return FALSE;
		}
	*result = atoi(num_buf);
	return TRUE;
}


//-------------------------------------------------------------------------
// 	Style data structure.
//-------------------------------------------------------------------------
	/* Give names to various text justify modes. */
enum Justify {JUST_LEFT, JUST_RIGHT, JUST_CENTER, JUST_FILL};
	/* Give names to various animation modes. */
enum AnimMode {AM_STILL, AM_SCROLL, AM_FADE};


typedef struct 
/* This guy holds our slide style. */
	{
	RGB background_color;
	char background_image[PATH_SIZE];
	RGB title_color;
	Font_style title_font;
	enum Justify title_justification;
	XY	title_position;
	RGB item_color;
	Font_style item_font;
	char bullet_image[PATH_SIZE];
	char logo_image[PATH_SIZE];
	XY	logo_position;
	int antialias;
	enum AnimMode animode;
	int aniframes;
	int anispeed;
	} Slide_style;

Slide_style default_style =
	{
	{100, 40, 255},				/* Background Color. */
	"gradient",					/* Background Name */
	{204, 108, 12,},			/* Title Color */
	{"SERB14.FNT", 67, 0, 0},	/* Title font, size, spacing, leading */
	JUST_CENTER, 				/* Title justify */
	{0,0,},						/* Title position */
	{60, 156, 156,},			/* Item color */
	{"SERB10.FNT", 48, 0, 0},	/* Item font, size, spacing, leading */
	"circle",					/* Bullet name */
	"none",						/* Logo name */
	{590, 50},					/* Logo position */
	FALSE,						/* Antialias? */
	AM_STILL,					/* Anim_mode */
	10,							/* Anim frames */
	50,							/* Anim speed (milliseconds) */
	};


//-------------------------------------------------------------------------
// 	Style File Save Routines
//-------------------------------------------------------------------------

static char slide_style_magic[] = "Bullets Slide Style:\n";

static Boolean write_rgb(FILE *f, RGB *rgb, char *label)
/*
 * Write out RGB triples and label to file.
 */
{
	return (fprintf(f, "%d %d %d %s\n", rgb->r, rgb->g, rgb->b, label) > 0);
}

static Boolean write_xy(FILE *f, XY *xy, char *label)
/*
 * Write out XY pair and label to file.
 */
{
	return (fprintf(f, "%d %d %s\n", xy->x, xy->y, label) > 0);
}

static Boolean write_font_style(FILE *f, Font_style *font, char *label)
/*
 * Write out a Font style and label to file.
 */
{
	return (fprintf(f, "%s %d %d %d %s Font, Size, Spacing, Leading\n",
	font->name, font->size, font->spacing, font->leading, label) > 0);
}

Boolean inside_write_slide_style(Slide_style *sf, FILE *f)
/*
 * Write slide style file.  Return FALSE if there's a problem.
 */
{
	if (fputs(slide_style_magic, f) < Success)
		return FALSE;
	if (!write_rgb(f, &sf->background_color, "Background Color"))
		return FALSE;
	if (fprintf(f, "%s Background Image\n", sf->background_image) <= 0)
		return FALSE;
	if (!write_rgb(f, &sf->title_color, "Title Color"))
		return FALSE;
	if (!write_font_style(f, &sf->title_font, "Title"))
		return FALSE;
	if (fprintf(f, "%d Title Justification\n", sf->title_justification) <= 0)
		return FALSE;
	if (!write_xy(f, &sf->title_position, "Title Position"))
		return FALSE;
	if (!write_rgb(f, &sf->item_color, "Item Color"))
		return FALSE;
	if (!write_font_style(f, &sf->item_font, "Item"))
		return FALSE;
	if (fprintf(f, "%s Bullet Image\n", sf->bullet_image) <= 0)
		return FALSE;
	if (fprintf(f, "%s Logo Image\n", sf->logo_image) <= 0)
		return FALSE;
	if (!write_xy(f, &sf->logo_position, "Logo Position"))
		return FALSE;
	if (fprintf(f,"%i  AntiAliased Text and Logo (0 = off, 1 = on)\n"
	, sf->antialias) <= 0)
   		return FALSE;
	if (fprintf(f,"%i  %i  %i  Text Animation Mode\n"
	,  sf->animode, sf->aniframes, sf->anispeed) <= 0)
		return FALSE;
	return TRUE;
}


Boolean write_slide_style(Slide_style *sf, char *file_name)
/*
 * Open slide style file and write it out.  Delete file and complain
 * if there's a problem.
 */
{
	FILE *f;
	Boolean ok = FALSE;

	if ((f = must_open(file_name, "w")) != NULL)
		{
		ok = inside_write_slide_style(sf, f);
		fclose(f);
		if (!ok)
			{
			Qtext("Couldn't write slide style to %s, sorry", file_name);
			DosDelete(file_name);
			}
		}
	return ok;
}

//-------------------------------------------------------------------------
// 	Style File Load Routines
//-------------------------------------------------------------------------

Boolean verify_label(Line_file *file, char *buf, char *label)
/*
 *	Verify that buf contains label.
 */
{
	if (stristr(buf, label) == NULL)
		{
		expecting_got(file, label, buf);
		return FALSE;
		}
	return TRUE;
}

Boolean read_numbers_and_label(Line_file *file
, int *nums, int num_count, char *label)
/*
 * Read in a line of form:
 *		NN ... NN label
 * into nums.   This is the basis for read_rgb and read_xy.
 * Complain and return FALSE if there's a problem.
 */
{
	char *buf = file->line_buf;

	if (!must_read_line(file))
		return FALSE;
	while (--num_count >= 0)
		{
		if (!next_number(file, &buf, nums))
			return FALSE;
		++nums;
		}
	return verify_label(file, buf, label);
}

Boolean read_rgb(Line_file *file, RGB *rgb, char *label)
/*
 * Read in a line of form:
 *		NN NN NN label
 * into an RGB triple.
 * Complain and return FALSE if there's a problem.
 */
{
	return read_numbers_and_label(file, (int *)rgb, 3, label);
}

Boolean read_xy(Line_file *file, XY *xy, char *label)
/*
 * Read in a line of form:
 *		NN NN label
 * into an XY pair.
 * Complain and return FALSE if there's a problem.
 */
{
	return read_numbers_and_label(file, (int *)xy, 2, label);
}

Boolean read_int_and_label(Line_file *file, int *result, char *label)
/*
 * Read in a line of form:
 *		NN label
 * into *result.
 * Complain and return FALSE if there's a problem.
 */
{
	return read_numbers_and_label(file, result, 1, label);
}

Boolean read_name_and_label(Line_file *file, char *name, int name_size
, char *label)
/*
 *	Read in a line of form:
 *		name label
 *  into name.
 */
{
	char *buf = file->line_buf;

	if (!must_read_line(file))
		return FALSE;
	if (!next_string(file, &buf, name, name_size))
		{
		expecting_got(file, "a name", "<cr>");
		return FALSE;
		}
	return verify_label(file, buf, label);
}

Boolean read_font_line(Line_file *file, Font_style *fs, char *label)
{
	char *buf = file->line_buf;

	if (!must_read_line(file))
		return FALSE;
	if (!next_string(file, &buf, fs->name, sizeof(fs->name)))
		{
		expecting_got(file, "font name", "<cr>");
		return FALSE;
		}
	if (!next_number(file, &buf, &fs->size))
		return FALSE;
	if (!next_number(file, &buf, &fs->spacing))
		return FALSE;
	if (!next_number(file, &buf, &fs->leading))
		return FALSE;
	return verify_label(file, buf, label);
}

Boolean inside_read_slide_style(Slide_style *sf, Line_file *file)
/*
 * Read slide file.  Complain if there's a problem.
 */
{
	if (!must_read_line(file))
		return FALSE;
	if (strcmp(file->line_buf, slide_style_magic) != 0)
		{
		Qtext("%s is not a Bullet Slide Style file.", file->file_name);
		return FALSE;
		}
	if (!read_rgb(file, &sf->background_color, "Background Color"))
		return FALSE;
	if (!read_name_and_label(file
	,  sf->background_image, sizeof(sf->background_image)
	,  "Background Image"))
		return FALSE;
	if (!read_rgb(file, &sf->title_color, "Title Color"))
		return FALSE;
	if (!read_font_line(file, &sf->title_font, "Title Font"))
		return FALSE;
	if (!read_int_and_label(file
	,   &sf->title_justification, "Title Justification"))
		return FALSE;
	if (!read_xy(file, &sf->title_position, "Title Position"))
		return FALSE;
	if (!read_rgb(file, &sf->item_color, "Item Color"))
		return FALSE;
	if (!read_font_line(file, &sf->item_font, "Item Font"))
		return FALSE;
	if (!read_name_and_label(file
	,	sf->bullet_image, sizeof(sf->bullet_image),	"Bullet Image"))
		return FALSE;
	if (!read_name_and_label(file
	,	sf->logo_image, sizeof(sf->logo_image),	"Logo Image"))
		return FALSE;
	if (!read_xy(file, &sf->logo_position, "Logo Position"))
		return FALSE;
	if (!read_int_and_label(file
	, 	&sf->antialias, "AntiAliased Text and Logo"))
   		return FALSE;
	{
	char *buf = file->line_buf;

	/* Read inline of format NN NN NN Text Animation Mode */
	if (!must_read_line(file))
		return FALSE;
	if (!next_number(file, &buf, &sf->animode))
		return FALSE;
	if (!next_number(file, &buf, &sf->aniframes))
		return FALSE;
	if (!next_number(file, &buf, &sf->anispeed))
		return FALSE;
	if (!verify_label(file, buf, "Text Animation Mode"))
		return FALSE;
	}
}

Boolean read_slide_style(Slide_style *sf, char *file_name)
/*
 * Open slide style file and read it.  Complain if there's 
 * a problem.
 */
{
	int ok = FALSE;
	Line_file file;
	char buf[256];

	if (line_file_open(&file, file_name, buf, sizeof(buf)))
		{
		ok = inside_read_slide_style(sf, &file);
		line_file_close(&file);
		}
	return ok;
}

//-------------------------------------------------------------------------
// Some Paragraph oriented stuff - to read in blank line separated sections
// of a text file.
//-------------------------------------------------------------------------

typedef struct paragraph
	{
	char **lines;
	int line_count;
	int line_alloc;
	} Paragraph;

Boolean init_paragraph(Paragraph *p)
/*
 * Set up empty paragraph.
 */
{
	p->line_alloc = 50;
	p->line_count = 0;
	if ((p->lines = need_memory(p->line_alloc * sizeof(char *))) == NULL)
		{
		return FALSE;
		}
	return TRUE;
}

void free_paragraph(Paragraph *p)
/*
 * Free all dynamic memory associated with paragraph.
 */
{
	int i;

	if (p->lines != NULL)
		{
		for (i=0; i<p->line_count; ++i)
			{
			if (p->lines[i] != NULL)
				free(p->lines[i]);
			}
		free(p->lines);
		p->lines = NULL;
		}
}

Boolean paragraph_add_line(Paragraph *p, char *line)
/*
 * Add a line to paragraph.
 */
{
	if (p->line_count < p->line_alloc)
		{
		if ((p->lines[p->line_count] = strdup(line)) == NULL)
			{
			Qtext("Not enough memory for %s", line);
			return FALSE;
			}
		else
			{
			++p->line_count;
			return TRUE;
			}
		}
	else
		{
		Qtext("Too many lines in paragraph\n");
		return FALSE;
		}
}

Boolean read_paragraph(Paragraph *p, Line_file *file)
/*
 * Read file until next blank line into paragraph.
 */
{
	/* First skip over any blank lines. */
	for (;;)
		{
		if (!read_line(file))
			return FALSE;
		if (skip_space(file->line_buf) != NULL)
			break;
		}
	/* Now go to next blank line or EOF. */
	for (;;)
		{
		if (!paragraph_add_line(p, file->line_buf))
			return FALSE;
		if (!read_line(file))
			return TRUE;
		if (skip_space(file->line_buf) == NULL)
			return TRUE;
		}
}


//-------------------------------------------------------------------------
//				Global Variables
//-------------------------------------------------------------------------
char persistant_text[] = "=:bullet.txt";
char persistant_style[] = "=:bullet.sty";
int screen_width, screen_height;
int shadow_xoff, shadow_yoff;


//-------------------------------------------------------------------------
//	Drawing routines
//-------------------------------------------------------------------------

typedef struct
/* Keep track of the color registers we want to draw in
 * (as opposed to the RGB values)
 */
	{
	int title;
	int item;
	} Drawing_colors;


void find_drawing_colors(Drawing_colors *dc, Slide_style *sf)
/*
 * Find colors to draw slide in from RGB values in Slide_style. 
 */
{
	dc->title = ClosestColorInScreen(GetPicScreen()
	, sf->title_color.r, sf->title_color.g, sf->title_color.b);
	dc->item = ClosestColorInScreen(NULL
	, sf->item_color.r, sf->item_color.g, sf->item_color.b);
}

static int find_intermediate_value(double percent, int start, int end)
/*
 *  Return a color percent between start and end.
 */
{
	int diff = end - start;
	return (start + percent*diff);
}

static void find_intermediate_color(RGB *result, double percent
, RGB *start, RGB *end)
/*
 *  Put a color percent between start and end into result
 */
{
	result->r = find_intermediate_value(percent, start->r, end->r);
	result->g = find_intermediate_value(percent, start->g, end->g);
	result->b = find_intermediate_value(percent, start->b, end->b);
}

static void ramp_range(RGB *start_color, RGB *stop_color)
/*
 * Puts a color ramp into the current range.
 */
{
	int *cluster;
	int ccount;
	int i;
	double percent;
	RGB intermediate;
	Errcode err;

	if ((err = GetCluster(&ccount, &cluster)) < Success)
		Qerror(err, "Can't GetCluster");
	else
		{
		for (i=0; i<ccount; ++i)
			{
			percent = (double)i/(double)(ccount-1);
			find_intermediate_color(&intermediate, percent
			,	start_color, stop_color);
			SetColorMap(cluster[i]
			, intermediate.r, intermediate.g, intermediate.b);
			}
		free(cluster);
		}
}

static void set_color_range(int start, int stop
, RGB *start_color, RGB *stop_color)
/*
 *	This puts the colors from start to stop into the cluster.
 *  Then it makes a gradient in those colors from start_color to
 *  stop_color.
 */
{
	int *cluster;
	int i;
	int ccount = stop-start+1;

	if ((cluster = need_memory(ccount * sizeof(int))) != NULL)
		{
		for (i=0; i<ccount; ++i)
			{
			cluster[i] = start+i;
			}
		SetCluster(ccount, cluster);
		free(cluster);
		}
	ramp_range(start_color, stop_color);
}

static Boolean is_solid(char *name)
{
return stricmp(name, "solid") == 0;
}

static Boolean is_gradient(char *name)
{
return stricmp(name, "gradient") == 0;
}

static void preload_background(Slide_style *sf)
/*
 *	Draw the background into swap screen.
 */
{
	char *name = sf->background_image;
	RGB *col = &sf->background_color;
	static RGB black = {0,0,0};

	SetFilled(TRUE);
	if (is_solid(name))
		{
		SetColorMap(0, col->r, col->g, col->b);
		Clear();
		}
	else if (is_gradient(name))
		{
		set_color_range(0, 63,  &black, col);
		SetInk("V Grad");
		Box(0,0,screen_width,screen_height);
		}
	else
		{
		LoadPic(name);
		}
	SwapClip();
}

Boolean draw_logo(Slide_style *sf)
/*
 * Draw the logo
 */
{
	char *name = sf->logo_image;
	XY *pos;
	int logow,logoh;

	if (stricmp(name, "none") == 0)
		return TRUE;
	if (LoadCel(name) >= Success)
		{
		pos = &sf->logo_position;
	    GetScreenSize( GetCelScreen(), &logow, &logoh);
		CelMoveTo(pos->x, pos->y);
		SetInk("opaque");
		CelPaste();
		if (sf->antialias)
			{
			PicDirtied();
			SetInk("unzag");
			CelPaste();
			}
		return TRUE;
		}
	else
		return FALSE;
}

static void set_shadow()
/*
 * Set up ink, etc for shadow.
 */
{
	SetInk("Dark");
	SetInkStrength(50);
}

static int draw_shadow_text( int x_start, int y_start, int xoff, int yoff
, int text_color, char *string, Boolean antialias)
/*
 * Show text with a drop shadow.  Returns the # of lines of text
 * drawn.
 */
{
	int w;
	int lines;

	/* Calculate size of word-wrap box. */
	w = screen_width - x_start;

	/* Draw drop-shadow. */
	set_shadow();
	WordWrap(x_start+xoff, y_start+yoff, w, screen_height, string);

	/* Draw text proper. */
	SetInk("Opaque");
	SetColor(text_color);
	WordWrap(x_start, y_start, w, screen_height, string);

	/* Do anti-aliasing. */
	if (antialias)
		{
		PicDirtied();
		SetInk("unzag");
		WordWrap(x_start, y_start, w, screen_height, string);
		}

	return WordWrapCountLines(w, string);
}

enum bullet_type {BT_NONE, BT_CEL, BT_CIRCLE};
typedef struct 
	{
	enum bullet_type type;	/* Type of bullet. */
	int width, height;		/* Dimensions of bullet. */
	int font_height;		/* Height of font. */
	int font_width;			/* Width of letter x in font. */
	int text_xoff;			/* Space from center of bullet to where 
							 * text starts */
	} Bullet_data;

void find_bullet(Bullet_data *bd, Slide_style *sf)
/*
 * This will load the bullet into the Cel if possible
 * otherwise complain and revert to the circle bullet.
 * Returns type.
 */
{
	bd->font_height = FontHeight();
	bd->font_width = StringWidth("x");
	if (strcmp(sf->bullet_image, "none") == 0)
		{
		bd->width = bd->height = 0;
		bd->text_xoff = 0;
		bd->type = BT_NONE;
		}
	else if (strcmp(sf->bullet_image, "circle") == 0)
		{
		bd->width = bd->height = bd->font_height/2;
		bd->text_xoff = bd->width/2 + bd->font_width;
		bd->type = BT_CIRCLE;
		}
	else
		{
		if (LoadCel(sf->bullet_image) < Success)
			{	/* On error revert to circle. */
			strcpy(sf->bullet_image, "circle");
			find_bullet(bd, sf);
			}
		else
			{
			GetScreenSize(GetCelScreen(), &bd->width, &bd->height);
			bd->text_xoff = bd->width/2 + bd->font_width;
			bd->type = BT_CEL;
			}
		}
}

void draw_bullet(Slide_style *sf, Bullet_data *bd, int xoff, int yoff
, int color)
/*
 * Draw a bullet centered at xoff, yoff.  Should be called shortly after
 * find_bullet() - or at least before you reload the cel.
 */
{
	switch (bd->type)
		{
		case BT_CIRCLE:
			{
			int rad = bd->width/2;
			set_shadow();
			Circle(xoff+shadow_xoff, yoff+shadow_yoff, rad);
			SetInk("Opaque");
			SetColor(color);
			Circle(xoff, yoff, rad);
			}
			break;
		case BT_CEL:
			CelMoveTo(xoff, yoff);
			SetInk("Opaque");
			CelPaste();
			break;
		case BT_NONE:
		default:
			break;
		}
}


static Boolean display_paragraph(Slide_style *sf, Paragraph *pg)
/*
 * This draws a paragraph according to the slide style.
 * Calculates all the x,y positions to draw everything, which
 * is a lot of nitty little work.  Generally the nastiest routine
 * in the module.
 */
{
	Drawing_colors colors;
	Bullet_data bullet;
	int title_font_height;
	int title_height;
	int item_font_height;
	int item_lines;
	int item_count;
	int inter_item_distance;
	int item_total_lines;
	int xoff,yoff;
	int xmargin;
	int empty_height;
	int ok = FALSE;
	int i;

	find_drawing_colors(&colors, sf);
	item_count =  pg->line_count - 1;

	/* Draw background */
	CopyScreen(GetSwapScreen(), GetPicScreen()); 
	PicDirtied();

	/* Draw logo */
	draw_logo(sf);

	/* Draw title. */
	if (item_count >= 0)
		{
		set_font_style(&sf->title_font);
		title_font_height = FontHeight();
		title_height = draw_shadow_text(sf->title_position.x
		, sf->title_position.y
		, shadow_xoff, shadow_yoff, colors.title
		, pg->lines[0], sf->antialias);
		title_height *= title_font_height;
		title_height += sf->title_position.y;
		}

	/* Draw items. */
	if (item_count > 0)
		{
		set_font_style(&sf->item_font);
		item_font_height = FontHeight();
		find_bullet(&bullet, sf);
		xmargin = screen_width/10;

		/* figure empty_height - the amount of the screen that has no text
		 * or title in it. */
		xoff = xmargin + bullet.text_xoff;	/* Left edge of text. */
		item_total_lines = 0;
		for (i=1; i<=item_count; ++i)
			{
			item_total_lines 
			+= WordWrapCountLines(screen_width-xoff, pg->lines[i]);
			}
		empty_height = screen_height - title_height 
		- item_total_lines * item_font_height;

		/* Calculate the inter_item_distance and where to start item text
		 * vertically. 
		 * We'll leave a margin 1/2 again the space between items
		 * between the title and the items. */
		inter_item_distance = (empty_height)/(item_count+2);
		yoff = title_height 
		+ (empty_height - inter_item_distance*(item_count-1))/2;

		/* Draw the bullets and item text. */
		for (i=1; i<=item_count; ++i)
			{
			draw_bullet(sf, &bullet
			, xmargin, yoff+item_font_height/2, colors.item);
			item_lines = draw_shadow_text(xoff, yoff
			, shadow_xoff, shadow_yoff, colors.item
			, pg->lines[i], sf->antialias);
			yoff += inter_item_distance + item_lines*item_font_height;
			}
		}
	return TRUE;
}

static Boolean display_one_slide(Slide_style *sf, Line_file *input)
/*
 * Load in next paragraph from input file and
 * display it.
 */
{
	Paragraph p;
	Boolean ok = FALSE;

	if (init_paragraph(&p))
		{
		if (read_paragraph(&p, input))
			{
			ok = display_paragraph(sf, &p);
			}
		free_paragraph(&p);
		}
	return ok;
}

//-------------------------------------------------------------------------
//   Internal routines.
//-------------------------------------------------------------------------

static Boolean make_sample_file(char *sample_file_name, Slide_style *sf)
/*
 * Make up a little text file that's got a sample of our stuff.
 */
{
FILE *f;
char name_only[PATH_SIZE];

if ((f = must_open(sample_file_name, "w")) == NULL)
	return FALSE;
fprintf(f,"Example Slide\n");
file_name_only(sf->title_font.name, name_only);
fprintf(f,"Title Font is %s\n", name_only);
file_name_only(sf->item_font.name, name_only);
fprintf(f,"Item Font is %s\n", name_only);
if(sf->animode > 0)
   fprintf(f, "Anim FLC with %i frames, at %i jif's \n"
   , sf->aniframes, sf->anispeed);
else
   fprintf(f,"Output still slides \n");
if(sf->antialias == TRUE)
   fprintf(f, "Text/Logo will be antialiased\n");
else
   fprintf(f, "Text/Logo will NOT be antialiased\n");
fclose(f);
return TRUE;
}

static Boolean display_sample(Slide_style *sf)
/*
 * Display current slide style sample on screen.
 */
{
	Line_file file;
	char *temp_name = "#:bullet.tmp";
	char buf[256];

	if (make_sample_file(temp_name, sf))
		{
		if (line_file_open(&file, temp_name, buf, sizeof(buf)))
			{
			display_one_slide(sf, &file);
			line_file_close(&file);
			}
		DosDelete(temp_name);
		}
}


Boolean check_text_exists()
/*
 * Make sure text file exists.  Squawk if it doesn't.
 */
{
	if (!DosExists(persistant_text))
		{
		Qtext("Please select Edit Text or Load Text and try again.");
		return FALSE;
		}
	return TRUE;
}

void init_style(Slide_style *sf)
/*
 * Read in style.  If there's no style file or some other problem
 * then use default style.
 */
{
	memcpy(sf, &default_style, sizeof(*sf));
	if (DosExists(persistant_style))
		read_slide_style(sf, persistant_style);
}


Boolean render_slides(Slide_style *sf, char *script_name)
/*
 * Open up text file and go make as many slides as there are
 * paragraphs.  Write out commands to script too.
 */
{
	Line_file lfile;
	char buf[256];
	FILE *script;
	Boolean ok = FALSE;
	int i;
	char dev[4], dir[70], file[10], suff[5];	/* FNsplit/merge stuff */
	char base_name[PATH_SIZE];					/* name before XX.FLC. */
	char flc_name[PATH_SIZE];
	RGB *col = &sf->background_color;


	/* Figure out base name of numbered flics.  Will convert something
	 * like C:\ANI\1STQUARTR.SCR into C:\ANI\1STQUA  */
	fnsplit(script_name, dev, dir, file, suff);
	file[6] = 0;	/* Leave room for number. */
	sprintf(base_name, "%s%s%s", dev, dir, file);

	if (line_file_open(&lfile, persistant_text, buf, sizeof(buf)))
		{
		if ((script = must_open(script_name, "w")) != NULL)
			{
			for (i=0; ; ++i)	/* Keep count. */
				{
				if (!display_one_slide(sf, &lfile))
					{
					ok = TRUE;
					break;
					}
				sprintf(flc_name, "%s%02d.flc", base_name, i);
				printf("Saving Flic %s", flc_name);
				if (SaveFlic(flc_name) < Success)
					break;
				fnsplit(flc_name, dev, dir, file, suff);
				/* Don't include full path name in script,  just the
				 * file part. */
				fprintf(script
				, "%s%s -p 0 -t fadein color(%d,%d,%d) fadeout color(%d,%d,%d)\n"
				, file, suff
				, col->r/2, col->g/2, col->b/2
				, col->r/2, col->g/2, col->b/2);
				unprintf();
				}
			fclose(script);
			}
		line_file_close(&lfile);
		}
	return ok;
}

Boolean preview_slides(Slide_style *sf)
/*
 * Put up one slide after the other,  pausing for a key press or
 * mouse click between each one.
 */
{
	Line_file lfile;
	char buf[256];
	Boolean ok = FALSE;
	int i;
	int x,y,l,r,key;

	if (line_file_open(&lfile, persistant_text, buf, sizeof(buf)))
		{
		for (i=0; ; ++i)	/* Keep count. */
			{
			if (!display_one_slide(sf, &lfile))
				{
				ok = TRUE;
				break;
				}
WAIT_CLICK:
			WaitClick(&x,&y,&l,&r,&key);
			if (r || (key&0xff) == ESCAPE_KEY)
				{
				if (Qquestion("Abort Preview?"))
					break;
				else
					goto WAIT_CLICK;
				}
			}
		line_file_close(&lfile);
		}
	return ok;
}


//-------------------------------------------------------------------------
//	Routines that interact with User
//-------------------------------------------------------------------------
Boolean css_menu(Slide_style *sf)
/*
 *	Interpret the create slide show menu.
 */
{
int choice;
static int cursor_pos, line_pos;
static char text_name[PATH_SIZE] = "bullet.txt";
static char scr_name[PATH_SIZE] = "bullet.scr";

for (;;)
	{
	choice = Qmenu(css_choices, Array_els(css_choices), css_header);
	switch(choice)
		{
		case CSS_HELP:
			Qtext(css_help);
			break;
		case CSS_EDIT:
			QeditFile(persistant_text, &cursor_pos, &line_pos);
			break;
		case CSS_LOAD:
			if (Qfile(".TXT", "Load", text_name, text_name
			, FALSE, "Load Slide Text File"))
				copy_file(text_name, persistant_text);
			break;
		case CSS_SAVE:
			if (check_text_exists())
				{
				if (Qfile(".TXT", "Save", 	text_name, text_name
				, TRUE,	"Save Slide Text File"))
					if (overwrite_ok(text_name))
						if (copy_file(persistant_text, text_name))
							Qtext("Saved Text %s", text_name);
				}
			break;
		case CSS_PREVIEW:
			if (check_text_exists())
				{
				preview_slides(sf);
				}
			break;
		case CSS_RENDER:
			if (check_text_exists())
				{
				if (Qfile(".SCR", "Render", scr_name, scr_name
				, TRUE, "Render to Script"))
					{
					if (overwrite_ok(scr_name))
						{
						if (render_slides(sf, scr_name))
							return FALSE;	/* Get out of program! */
						}
					}
				}
			break;
		default:
			return TRUE;
		}
	}
}


#ifdef XXX
void xyz_menu(Slide_style *sf)
/*
 * Interpret xyz menu
 */
{
	int choice;
	Boolean is_changed;

	for (;;)
		{
		is_changed = FALSE;
		choice = Qmenu(xyz_choices, Array_els(xyz_choices), xyz_header);
		switch(choice)
			{
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}
#endif XXX

Boolean load_new_font(Font_style *fs)
/*
 * Load font and record the name and size.
 */
{
	Font_style new_style;
	char full_font_name[PATH_SIZE];

	/* Load up the current selection */
	set_font_style(fs);
	/* Go to font requestor. */
	Qfont();
	get_font_style(&new_style);
	/* Return whether it's a new one */
	if (memcmp(fs, &new_style, sizeof(new_style)) != 0)
		{
		memcpy(fs, &new_style, sizeof(*fs));
		return TRUE;
		}
	else
		return FALSE;
}

void title_menu(Slide_style *sf)
/*
 * Interpret title menu
 */
{
	int choice;
	Boolean is_changed;
	int color;
	int x,y,w,h;

	for (;;)
		{
		is_changed = FALSE;
		choice = Qmenu(title_choices, Array_els(title_choices), title_header);
		switch(choice)
			{
			case TITLE_COLOR:
				if ((color = Qcolor()) >= Success)
					{
					translate_to_rgb(color, &sf->title_color);
					is_changed = TRUE;
					}
				break;
			case TITLE_POSITION:
				TitleSetText("Example Slide");
				set_font_style(&sf->title_font);
				TitleSetPosition(sf->title_position.x, sf->title_position.y
				,	screen_width,  FontHeight());
				TitleEdit();
				TitleGetPosition(&x,&y,&w,&h);
				if (x != sf->title_position.x || y != sf->title_position.y)
					{
					sf->title_position.x = x;
					sf->title_position.y = y;
					is_changed = TRUE;
					}
				break;
			case TITLE_FONT:
				is_changed = load_new_font(&sf->title_font);
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}

void item_menu(Slide_style *sf)
/*
 * Interpret item menu
 */
{
	int choice;
	Boolean is_changed;
	int color;

	for (;;)
		{
		choice = Qmenu(item_choices, Array_els(item_choices), item_header);
		switch(choice)
			{
			case ITEM_COLOR:
				if ((color = Qcolor()) >= Success)
					{
					translate_to_rgb(color, &sf->item_color);
					is_changed = TRUE;
					}
				break;
			case ITEM_FONT:
				is_changed = load_new_font(&sf->item_font);
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}

void bullet_menu(Slide_style *sf)
/*
 * Interpret bullet menu
 */
{
	int choice;
	Boolean is_changed;
	char header[80];
	char file_name[32];
	char *bullet_name = sf->bullet_image;

	for (;;)
		{
		file_name_only(bullet_name, file_name);
		sprintf(header, "%s (%s)", bullet_header, file_name);
		is_changed = FALSE;
		choice = Qmenu(bullet_choices, Array_els(bullet_choices), header);
		switch(choice)
			{
			case BULLET_CIRCLE:
				strcpy(bullet_name, "circle");
				is_changed = TRUE;
				break;
			case BULLET_USE_CEL:
				if (Qfile(".CEL;.FL?", "Load"
				, bullet_name, bullet_name
				, FALSE,	"Load Bullet Image"))
					{
					is_changed = TRUE;
					}
				break;
			case BULLET_NONE:
				strcpy(bullet_name, "none");
				is_changed = TRUE;
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}  

void background_menu(Slide_style *sf)
/* 
 *	Interpret background menu.
 */
{
	int choice;
	char file_name[32];
	char header[80];
	int color;
	Boolean is_changed;

	for (;;)
		{
		file_name_only(sf->background_image, file_name);
		sprintf(header, "%s (%s)", background_header, file_name);
		is_changed = FALSE;
		choice = Qmenu(background_choices
		, Array_els(background_choices), header);
		switch(choice)
			{
			case BACKGROUND_GET_COLOR:
				if ((color = Qcolor()) >= Success)
					{
					translate_to_rgb(color, &sf->background_color);
					if (is_solid(sf->background_image)
					||  is_gradient(sf->background_image))
						is_changed = TRUE;
					}
				break;
			case BACKGROUND_SOLID:
				strcpy(sf->background_image, "solid");
				is_changed = TRUE;
				break;
			case BACKGROUND_GRADIENT:
				strcpy(sf->background_image, "gradient");
				is_changed = TRUE;
				break;
			case BACKGROUND_USE_PIC:
				{
				char buf[PATH_SIZE];
				if (Qfile(".GIF;.FL?;.PCX", "Load"
				, sf->background_image, buf
				, FALSE,	"Load Background Image"))
					{
					if (LoadPic(buf) >= Success)
						{
						strcpy(sf->background_image, buf);
						SwapClip();
						display_sample(sf);
						}
					}
				}
				break;
			default:
				return;
			}
		if (is_changed)
			{
			preload_background(sf);
			display_sample(sf);
			}
		}
}

void logo_menu(Slide_style *sf)
/*
 * Interpret logo menu
 */
{
	int choice;
	Boolean is_changed;
	char header[80];
	char file_name[32];
	char *logo_name = sf->logo_image;
	int choice_count;

	for (;;)
		{
		file_name_only(logo_name, file_name);
		sprintf(header, "%s (%s)", logo_header, file_name);
		is_changed = FALSE;
		choice = Qmenu(logo_choices, Array_els(logo_choices), header);
		switch(choice)
			{
			case LOGO_USE_CEL:
				if (Qfile(".CEL;.FL?", "Load"
				, logo_name, logo_name
				, FALSE,	"Load Logo Image"))
					{
					if (LoadCel(logo_name) >= Success)
						{
						double angle;

						CelWhere(&sf->logo_position.x, &sf->logo_position.y
						, &angle);
						}
					is_changed = TRUE;
					}
				break;
			case LOGO_NONE:
				strcpy(logo_name, "none");
				is_changed = TRUE;
				break;
			case LOGO_POSITION:
				{
				if (strcmp(logo_name, "none") != 0)
					{
					if (LoadCel(logo_name) >= Success)
						{
						int x,y,w,h;

						GetScreenSize(GetCelScreen(), &w, &h);
						x = sf->logo_position.x - w/2;
						y = sf->logo_position.y - h/2;
						if (DragBox(&x,&y,&w,&h))
							{
							sf->logo_position.x = x + w/2;
							sf->logo_position.y = y + h/2;
							is_changed = TRUE;
							}
						}
					}
				}
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}


void ssf_menu(Slide_style *sf)
/*
 * Set Slide Style menu.
 */
{
int choice;
static char file_name[PATH_SIZE] = "bullet.bsm";
static char *off_on[2] = {"OFF", "ON"};
char anti_line[40];

for (;;)
	{
	if (sf->antialias)		 /* Make sure value is TRUE or FALSE */
		sf->antialias = TRUE;
	sprintf(anti_line, "Antialias is %s", off_on[sf->antialias]);
	ssf_choices[SSF_ANTIALIAS-1] = anti_line;
	choice = Qmenu(ssf_choices, Array_els(ssf_choices), ssf_header);
	switch(choice)
		{
		case SSF_HELP:
			Qtext(ssf_help);
			break;
		case SSF_TITLE:
			title_menu(sf);
			break;
		case SSF_ITEMS:
			item_menu(sf);
			break;
		case SSF_BULLET:
			bullet_menu(sf);
			break;
		case SSF_BACKGROUND:
			background_menu(sf);
			break;
		case SSF_LOGO:
			logo_menu(sf);
			break;
		case SSF_ANTIALIAS:
			sf->antialias = !sf->antialias;
			display_sample(sf);
			break;
		case SSF_LOAD:
			if (Qfile(".BSS", "Load", 	file_name, file_name
			, TRUE,	"Load Bullets Slide Style"))
				read_slide_style(sf, file_name);
			display_sample(sf);
			break;
		case SSF_SAVE:
			if (Qfile(".BSS", "Save", 	file_name, file_name
			, TRUE,	"Save Bullets Slide Style"))
				if (overwrite_ok(file_name))
					if (write_slide_style(sf, file_name))
						Qtext("Saved Style %s", file_name);
			break;
		default:
			return;
		}
	}
}

void mm_menu(Slide_style *sf)
/*
 * Interpret the top level menu.
 */
{
int choice;

for (;;)
	{
	choice = Qmenu(mm_choices, Array_els(mm_choices), mm_header);
	switch(choice)
		{
		case MAIN_HELP:
			Qtext(mm_help);
			break;
		case MAIN_CREATE:
			if (!css_menu(sf))
				return;
			break;
		case MAIN_FORMAT:
			ssf_menu(sf);
			break;
		default:
			return;
		}
	}
}
	

main()
{
	static Slide_style style;		// ~~~ Poco crashes without static !?

	if (ignore_changes())
		{
		GetSize(&screen_width, &screen_height);
		shadow_xoff = screen_width/160;
		shadow_yoff = screen_height/100;
		SetFrameCount(1);
		init_style(&style);
		preload_background(&style);
		display_sample(&style);
		mm_menu(&style);
		write_slide_style(&style, persistant_style);
		}
}

