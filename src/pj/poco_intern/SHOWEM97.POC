// Show'em.poc - A program which makes fancy bulleted text slide presentations
// out of simple text files.	This POCO routine can be used with Autodesk's
// Animator Pro Version 1.3 or higher.
//
// Copyright 1992 Michael Edmonds and Dancing Flame
// This file may be copied, used, and modified by legal license holders of
// the Autodesk Animator Pro.


// Need to make sure we're running the right version of Animator Pro.
#if __POCO__ < 181
	#error "You must upgrade to Animator Pro 1.3 or later to run this program"
#endif

#include <stdio.h>
#include <ctype.h>
#include <optics.h>

//-------------------------------------------------------------------------
//	 Defines and stuff you know and love
//-------------------------------------------------------------------------
#define TRUE 1
#define FALSE 0
#define Success 0
#define EOS 0
#define ESCAPE_KEY 0x1b
static char *off_on[2] = {"OFF", "ON"};

typedef struct 
	{
	int r,g,b;
	} RGB;

typedef struct
	{
	int x,y;
	} XY;

//-------------------------------------------------------------------------
//			 Global Variables
//-------------------------------------------------------------------------

char persistant_text[] = "=:show'em.txt";
char persistant_style[] = "=:show'em.sty";
int slide_width, slide_height;
int shadow_xoff, shadow_yoff;
FILE *script;
Boolean script_empty;


//-------------------------------------------------------------------------
//			 Menu Definitions
//-------------------------------------------------------------------------

static char mm_header[] = "Show'em 1.0";
static char *mm_choices[] = 
	{
	"Help",
	"Create Slide Show",
	"Set Slide Style",
	"Exit",
	};
static enum { MAIN_EXIT, MAIN_HELP, MAIN_CREATE, MAIN_FORMAT};

static char mm_help1[] =
"Show'em creates a slide presentation from simple text input. "
"All slides in a presentation share a background, logo, title, and "
"bullet style.  You can specify the fonts, colors, and styles with "
"the Set Slide Style menu. Then, from the Create Slide Show menu, "
"you define the text, preview the slides, and render them. "
	;

static char mm_help2[] =
"Show'em creates a numbered series of pictures, animated images, "
"Autodesk Animator Pro Player scripts, and a batch file to play the "
"scripts.  To present a slide show in its final form, select "
"Create Slide Show and then Render Slides. Then, exit Animator Pro "
"and use the batch file created with Show'em to run it.  The batch file "
"uses Aniplay and the scripts and images produced by Show'em to run "
"your slide show. "
	 ;

static char *mm_help[] = {mm_help1, mm_help2};

static char css_header[] = "Create Slide Show";
static char *css_choices[] =
	{
	"Help",
	"Edit Text",
	"Load Text",
	"Save Text",
	"New Text",
	"Preview",
	"Render Slides",
	"Return",
	};
static enum {CSS_EXIT, CSS_HELP, CSS_EDIT, CSS_LOAD, CSS_SAVE, CSS_DEL
, CSS_PREVIEW, CSS_RENDER};

static char *css_help[] = {
"To create a slide show, you define the text for each slide.  You can "
"load the slide text from an ascii text file or you can enter the text "
"directly by selecting Edit Text. Each paragraph of text (separated "
"by a blank line) creates one slide. The first line of each paragraph "
"becomes the title.  Subsequent lines become bullet items."
,
"There are also a few commands you can put in the text that allow "
"you to (1) eliminate the pause between items in an animated slide; "
"(2) include clips like business charts, AutoCAD slides, and scanned "
"images right on your slides; (3) show any animation or picture within "
"your presentation; and (4) place an interactive demo in the middle of "
"your presentation and return to your presentation automatically. "
,
"You can insert the following commands in your input text. "
"They must be in lower case and on a line by themselves. "
"\n\n"
"\"-nopause\" Suppress the pause that Show'em puts between animated "
"items on a slide. "
"\n\n" 
"\"-i ...\" Follow this by the file name of a cel you want pasted on a slide. "
"\n\n" 
"\"-x ...\" Follow this with any Animator Pro Player script "
"command.  This must be in its own single line paragraph. "
"\n\n" 
"\"-b ...\" Follow this with any valid DOS command.  "
"This must be in it's own single line paragraph.  "
};

static char ssf_header[] = "Set Slide Style";
static char *ssf_choices[] =
	{
	"Help",
	"Title",
	"Items",
	"Bullet",
	"Background",
	"Logo",
	"Output",
	"Load Style",
	"Save Style",
	"Return",
	};
static enum {SSF_EXIT, SSF_HELP, SSF_TITLE, SSF_ITEMS, SSF_BULLET
, SSF_BACKGROUND, SSF_LOGO, SSF_OUTPUT, SSF_LOAD, SSF_SAVE};
static char ssf_help[] =
"This menu controls the slide style.\n"
"\n" 
"Title - Set the title color, font,\n"
"   position, and justification.\n"
"Items - Set the item color and font.\n"
"Bullet - Set bullet color, use a circle\n"
"   bullet, load a cel to use as the\n"
"   bullet, or use no bullet.\n"
"Background - Set the background color,\n"
"   solid or gradient, or load an image\n"
"   to use as background.\n"
"Logo - Load a cel to use as logo,\n"
"   position it, or don't use a logo.\n"
"Output - Set slides as still images or\n"
"   animated with scrolling or fading;\n"
"   turn antialiasing on and off; turn\n"
"   safe titling on and off; get help.\n"
"Load Style - Load a style file.\n"
"Save Style - Save a style file.\n"
	;

static char title_header[] = "Title Style";
static char *title_choices[] =
	{
	"Title Color",
	"Title Font",
	"Position Title",
	"Justify Title",
	"Return",
	};
static enum {TITLE_EXIT, TITLE_COLOR, TITLE_FONT, TITLE_POS, TITLE_JUST};
static char title_just_header[] = "Title Justification";
static char *title_just_choices[] =
	{
	"Left",
	"Right",
	"Center",
	"Fill",
	"Return",
	};

static char item_header[] = "Item Style";
static char *item_choices[] =
	{
	"Item Color",
	"Item Font",
	"Return",
	};
static enum {ITEM_EXIT, ITEM_COLOR, ITEM_FONT};

static char bullet_header[] = "Set Bullet Image";
static char *bullet_choices[] =
	{
	"Set Bullet Color",
	"Use a Circle for Bullets",
	"Load a Cel for Bullets",
	"Don't use Bullets",
	"Return",
	};
static enum {BULLET_EXIT
, BULLET_COLOR, BULLET_CIRCLE, BULLET_USE_CEL, BULLET_NONE};

static char background_header[] = "Set Background Image";
static char *background_choices[] =
	{
	"Set Background Color",
	"Use a Solid Background",
	"Use a Gradient Background",
	"Load Background Image",
	"Return",
	};
static enum {BACKGROUND_EXIT, BACKGROUND_GET_COLOR
, BACKGROUND_SOLID, BACKGROUND_GRADIENT, BACKGROUND_USE_PIC};

static char logo_header[] = "Logo Style";
static char *logo_choices[] =
	{
	"Load a Logo Cel",
	"Position Logo Cel",
	"Don't use a Logo",
	"Return",
	};
static enum {LOGO_EXIT, LOGO_USE_CEL, LOGO_POSITION, LOGO_NONE};

static char out_header[] = "Set Output Style";
static char *out_choices[] =
	{
	"Help",
	"Still Images",
	"Scrolling",
	"Fading",
	NULL, //* Antialias line in menu!
	NULL, //* Safe Title line in menu!
	"Return",
	};
static enum {OUT_EXIT, OUT_HELP
, OUT_STILL, OUT_SCROLL, OUT_FADE, OUT_ANTIALIAS, OUT_SAFE_TITLE};
static char out_help1[] =
"The output menu contains these options:\n"
"\n"
"Still Images - The bullet items are not\n"
"   animated.  Slides are written as \n"
"   single frame flic files.\n"
"Scrolling - The bullet items are\n"
"   animated, scrolling onto the screen\n"
"   from the right.  The slides are saved\n"
"   in a combination of Flic files.\n"
"Fading - The bullet items are animated,\n"
"   fading onto the screen. The slides\n"
"   are saved in a combination of Flic\n"
"   files.\n"
"Antialias - Toggles smoothing of jagged\n"
"   edges on and off. When on the images\n"
"   render slower but look a bit better.\n"
"Safe Title - Toggles the reduction of\n"
"   the slide size on the screen so your\n"
"   titles are fully visible when shown\n"
"   on a TV.\n"
	;



//-------------------------------------------------------------------------
//	 Some Utility Routines maybe we'll use in  another poco program too
//-------------------------------------------------------------------------

Boolean ignore_changes()
/*
 *	 If have made changes to flic make sure it's ok to ignore them.
 */
{
	int changes;
	static char replace_changes_prompt[]  
	= "Okay to discard current flic?\n"
	"(You have unsaved changes)";

	if ((changes = GetChangeCount()) != 0)
		return Qquestion(replace_changes_prompt);
	else
		return TRUE;
}

Boolean overwrite_ok(char *file_name)
/*
 *	 If file exists make sure it's ok to overwrite it.
 */
{
	if (DosExists(file_name))
		return Qquestion("Write over old %s", file_name);
	else
		return TRUE;
}

FILE *must_open(char *file_name, char *mode)
/*
 * Open file to read.  Complain if can't.
 */
{
	FILE *f;
	char c = tolower(mode[0]);

	if ((f = fopen(file_name, mode)) == NULL)
		{
		if (c == 'w')
			Qtext("Can't create %s, sorry\n", file_name);
		else
			Qtext("Can't find %s, sorry\n", file_name);
		}
	return f;
}

void *need_memory(unsigned size)
/*
 * Request memory.  Squawk if can't get it.
 */
{
	void *pt;

	if ((pt = malloc(size)) == NULL)
		Qtext("Couldn't find %d bytes of free memory, sorry", size);
	return pt;
}

Boolean copy_file(char *source, char *dest)
/*
 * Copy one file to another. 
 */
{
	FILE *s, *d;
	int c;
	Boolean ok = FALSE;

	if ((s = must_open(source, "rb")) != NULL)
		{
		if ((d = must_open(dest, "wb")) != NULL)
			{
			while ((c = getc(s)) != EOF)
				{
				if (putc(c, d) == EOF)
					{
					Qtext("Couldn't copy %s to %s,  %s truncated"
					, source, dest, dest);
					break;
					}
				}
			fclose(d);
			}
		fclose(s);
		ok = TRUE;
		}
	return ok;
}


char *skip_space(char *pt)
/*
 * Return first non-space character in string, or NULL if all spaces
 *  until end.
 */
{
	if (pt == NULL)
		return NULL;
	while (isspace(*pt))
		++pt;
	if (*pt == EOS)
		return(NULL);
	return(pt);
}

char *skip_to_space(char *pt)
/*
 * Return first space character (or EOS) character in string. 
 */
{
	char c;

	for (;;)
		{
		c = *pt;
		if (isspace(c) || c == EOS)
			break;
		++pt;
		}
	return(pt);
}

void file_name_only(char *path, char *file_only)
/*
 * Extract just the file name from a path.	That is
 *  convert C:\ANI\DUCKY.FLI  to	DUCKY.FLI
 */
{
char dev[4], dir[70], file[10], suff[5];  /* FNsplit/merge stuff */

fnsplit(path,dev,dir,file,suff);
sprintf(file_only, "%s%s", file, suff);
}

void translate_to_rgb(int index, RGB *color)
/*
 * Look up color map index and store it in color
 */
{
	GetColorMap(index, &color->r, &color->g, &color->b);
}

void multi_screen_help(char *screens[], int screen_count)
/*
 * Put up multiple screens of help.  Pass in an array of strings, one
 * for each string.  This will put up a series of dialogs, one for each
 * screen,  and let the user navigate back and forth between them.
 * Returns when user selects "done" or right clicks out.
 */
{
static char prev_string[] = "Previous";
static char next_string[] = "Next";
static char done_string[] = "Done";
static char *done[1] = {done_string};
static char *done_next[2] = {done_string, next_string};
static char *prev_done_next[3] = {prev_string, done_string, next_string};
static char *prev_done[2] = {prev_string, done_string};

if (screen_count == 1)
	Qchoice(done, Array_els(done), screens[0]);
else
	{
	int screen_index = 0;
	int choice;
	for (;;)
		{
		if (screen_index == 0)
			{
			choice = Qchoice(done_next, Array_els(done_next)
			, screens[screen_index]);
			switch (choice)
				{
				case 2:
					++screen_index;
					break;
				default:
					return;
				}
			}
		else if (screen_index == screen_count - 1)
			{
			choice = Qchoice(prev_done, Array_els(prev_done)
			, screens[screen_index]);
			switch (choice)
				{
				case 1:
					--screen_index;
					break;
				default:
					return;
				}
			}
		else
			{
			choice = Qchoice(prev_done_next, Array_els(prev_done_next)
			, screens[screen_index]);
			switch (choice)
				{
				case 1:
					--screen_index;
					break;
				case 3:
					++screen_index;
					break;
				default:
					return;
				}
			}
		}
	}
}


//-------------------------------------------------------------------------
// Some font related stuff.
//-------------------------------------------------------------------------

void full_font_name(char *name, char *path)
/*
 * This removes any existing directory info from name and replaces it
 * with the current font directory.  The result is in path.
 */
{
char name_only[PATH_SIZE];

GetFontDir(path);
file_name_only(name, name_only);
strcat(path, name_only);
}

ErrCode load_font(char *name)
/*
 * Load font, looking if necessary in the font directory for it.
 * Also keep last font name used for reference to prevent unnecessary
 * reloading of font.
 */
{
char fdir[80];
ErrCode err;
static char last_font_name[PATH_SIZE];


if (strcmp(last_font_name, name) == 0)
	return Success;
if ((err = LoadFont(name)) < Success)
	{
	full_font_name(name, fdir);
	err =  Qerror(LoadFont(fdir), "Loading font %s", fdir);
	}
strcpy(last_font_name, name);
return err;
}


typedef struct
/*
 * Holds all pertinant info about type face - font size spacing data.
 */
	{
	char name[PATH_SIZE];
	int size, spacing, leading;
	} Font_style;

void get_font_style(Font_style *fs)
/*
 * Get current status of font into Font_style
 */
{
	GetFontName(fs->name);
	fs->spacing = GetFontSpacing();
	fs->leading = GetFontLeading();
	fs->size = FontHeight() - fs->leading;
}

Boolean set_font_style(Font_style *fs)
/*
 * Set font from Font_style
 */
{
	if (load_font(fs->name) < Success)
		return FALSE;
	ScaleFont(fs->size);
	SetFontSpacing(fs->spacing);
	SetFontLeading(fs->leading);
	return TRUE;
}


//-------------------------------------------------------------------------
// Some stuff to read a file a line at a time and report errors.
//-------------------------------------------------------------------------
typedef struct 
/* This structure keeps track of where we are in a file. */
	{
	FILE *f;
	char *file_name;
	char *line_buf;
	int buf_size;
	int current_line;
	char x_call[256];
	char bat_call[256];
	} Line_file;

Boolean line_file_open(Line_file *f, char *file_name, char *buf, int buf_size)
/*
 * Open up a file and set up structure to read it one line at a time
 */
{
	if ((f->f = must_open(file_name, "r")) == NULL)
		return FALSE;
	f->file_name = file_name;
	f->line_buf = buf;
	f->buf_size = buf_size;
	f->current_line = 0;
	strcpy(f->x_call, "none");
	strcpy(f->bat_call, "none");
	return TRUE;
}

void line_file_close(Line_file *f)
/*
 * Close a line file.
 */
{
	if (f->f != NULL)
		{
		fclose(f->f);
		f->f = NULL;
		}
}


Boolean read_line(Line_file *file)
/* 
 * Read a line from file.  Return FALSE at EOF.
 */
{
	char *pt;

	pt = file->line_buf;
	pt = fgets(pt, file->buf_size, file->f);
	++file->current_line;
	return (pt != NULL);
}

Boolean must_read_line(Line_file *file)
/* 
 * Read a line from file 
 * complain if it's not there.
 */
{
	if (!read_line(file))
		{
		Qtext("%s %d:  file too short\n"
		,  file->file_name, file->current_line);
		return FALSE;
		}
	return TRUE;
}

void expecting_got(Line_file *file, char *expecting, char *got)
/*
 * Print "expecting/got" error message
 */
{
	if (got == NULL)
		got = "(NULL)";
	if (skip_space(got) == NULL)
		got = "<cr>";
	Qtext("%s line %d:\nExpecting %s got %s"
	, file->file_name, file->current_line
	, expecting, got);
}


Boolean next_string(Line_file *file, char **input,  char *result, int max_size)
/*
 * Get next space separated token from input (and advance input).
 */
{
	char *start;
	char *end;
	int size;

	if ((start = skip_space(*input)) == NULL)
		return FALSE;
	end = skip_to_space(start);
	size = end - start;
	if (size >= max_size)
		{
		Qtext("%s %d:\nToken \"%s\" too long.\nCan only handle %d characters\n"
		,  file->file_name, file->current_line, start, max_size-1);
		*input = NULL;
		return FALSE;
		}
	strncpy(result, start, size);
	result[size] = EOS;
	*input = end;
	return TRUE;
}

Boolean next_number(Line_file *file, char **input, int *result)
/*
 * Get next number from string.  
 *  Put numerical result in *result.  Complain if it's not a number.
 */
{
	char num_buf[64]; /* Long enough for any reasonable integer! */

	if (!next_string(file, input, num_buf, sizeof(num_buf)))
		{
		expecting_got(file, "number", "<cr>");
		return FALSE;
		}
	if (!isdigit(num_buf[0]))
		{
		expecting_got(file, "number", num_buf);
		return FALSE;
		}
	*result = atoi(num_buf);
	return TRUE;
}


//-------------------------------------------------------------------------
//	 Style data structure.
//-------------------------------------------------------------------------
	/* Give names to various text justify modes. */
enum Justify {JUST_LEFT, JUST_RIGHT, JUST_CENTER, JUST_FILL};
	/* Give names to various animation modes. */
enum AnimMode {AM_STILL, AM_SCROLL, AM_FADE};


typedef struct 
/* This guy holds our slide style. */
	{
	RGB background_color;
	char background_image[PATH_SIZE];
	RGB title_color;
	Font_style title_font;
	enum Justify title_justification;
	XY title_position;
	int title_width;
	RGB item_color;
	Font_style item_font;
	char bullet_image[PATH_SIZE];
	RGB bullet_color;
	char logo_image[PATH_SIZE];
	XY logo_position;
	int antialias;
	int safe_title;
	enum AnimMode animode;
	int aniframes;
	int anispeed;
	} Slide_style;

Slide_style default_style =
	{
	{100, 40, 255},					/* Background Color. */
	"gradient",						 /* Background Name */
	{204, 108, 12,},				  /* Title Color */
	{"SERB10.FNT", 67, 0, 0},	  /* Title font, size, spacing, leading */
	JUST_LEFT,						  /* Title justify */
	{0,0,},							  /* Title position */
	0,								  /* Title width */
	{60, 156, 156,},				  /* Item color */
	{"SERB08.FNT", 48, 0, 0},	  /* Item font, size, spacing, leading */
	"circle",							/* Bullet name */
	{60, 156, 156,},				  /* Bullet color */
	"none",							  /* Logo name */
	{590, 50},						  /* Logo position */
	FALSE,								/* Antialias toggle*/
	FALSE,								/* Safe Title toggle
	AM_STILL,							/* Anim_mode */
	0,									 /* Anim frames */
	0,									 /* Anim speed (milliseconds) */
	};

void set_default_style(Slide_style *sf)
/* 
 * Set style to default. 
 */
{
	int sw,sh;
	GetSize(&sw,&sh);
	memcpy(sf, &default_style, sizeof(*sf));	/* Do most of the work here. */
	sf->title_width = sw;
	full_font_name("SERB10.FNT", sf->title_font.name);
	full_font_name("SERB08.FNT", sf->item_font.name);
}


//-------------------------------------------------------------------------
//	 Style File Save Routines
//-------------------------------------------------------------------------

static char slide_style_magic[] = "Show'em Slide Style:\n";

static Boolean write_rgb(FILE *f, RGB *rgb, char *label)
/*
 * Write out RGB triples and label to file.
 */
{
	return (fprintf(f, "%d %d %d %s\n", rgb->r, rgb->g, rgb->b, label) > 0);
}

static Boolean write_xy(FILE *f, XY *xy, char *label)
/*
 * Write out XY pair and label to file.
 */
{
	return (fprintf(f, "%d %d %s\n", xy->x, xy->y, label) > 0);
}

static Boolean write_font_style(FILE *f, Font_style *font, char *label)
/*
 * Write out a Font style and label to file.
 */
{
	return (fprintf(f, "%s %d %d %d %s Font, Size, Spacing, Leading\n",
	font->name, font->size, font->spacing, font->leading, label) > 0);
}

Boolean inside_write_slide_style(Slide_style *sf, FILE *f)
/*
 * Write slide style file.  Return FALSE if there's a problem.
 */
{
	if (fputs(slide_style_magic, f) < Success)
		return FALSE;
	if (!write_rgb(f, &sf->background_color, "Background Color"))
		return FALSE;
	if (fprintf(f, "%s Background Image\n", sf->background_image) <= 0)
		return FALSE;
	if (!write_rgb(f, &sf->title_color, "Title Color"))
		return FALSE;
	if (!write_font_style(f, &sf->title_font, "Title"))
		return FALSE;
	if (fprintf(f, "%d Title Justification\n", sf->title_justification) <= 0)
		return FALSE;
	if (!write_xy(f, &sf->title_position, "Title Position"))
		return FALSE;
	if (fprintf(f, "%i  Title Width\n", sf->title_width) <= 0)
		return FALSE;
	if (!write_rgb(f, &sf->item_color, "Item Color"))
		return FALSE;
	if (!write_font_style(f, &sf->item_font, "Item"))
		return FALSE;
	if (fprintf(f, "%s Bullet Image\n", sf->bullet_image) <= 0)
		return FALSE;
	if (!write_rgb(f, &sf->bullet_color, "Bullet Color"))
		return FALSE;
	if (fprintf(f, "%s Logo Image\n", sf->logo_image) <= 0)
		return FALSE;
	if (!write_xy(f, &sf->logo_position, "Logo Position"))
		return FALSE;
	if (fprintf(f,"%i  AntiAliased Text and Logo (0 = off, 1 = on)\n"
	, sf->antialias) <= 0)
			return FALSE;
	if (fprintf(f,"%i  Safe Titling (0 = off, 1 = on)\n"
	, sf->safe_title) <= 0)
			return FALSE;
	if (fprintf(f,"%i  %i  %i  Text Animation Mode\n"
	,  sf->animode, sf->aniframes, sf->anispeed) <= 0)
		return FALSE;
	return TRUE;
}


Boolean write_slide_style(Slide_style *sf, char *file_name)
/*
 * Open slide style file and write it out.  Delete file and complain
 * if there's a problem.
 */
{
	FILE *f;
	Boolean ok = FALSE;

	if ((f = must_open(file_name, "w")) != NULL)
		{
		ok = inside_write_slide_style(sf, f);
		fclose(f);
		if (!ok)
			{
			Qtext("Couldn't write slide style to %s, sorry", file_name);
			DosDelete(file_name);
			}
		}
	return ok;
}

//-------------------------------------------------------------------------
//	 Style File Load Routines
//-------------------------------------------------------------------------

Boolean verify_label(Line_file *file, char *buf, char *label)
/*
 * Verify that buf contains label.
 */
{
	if (stristr(buf, label) == NULL)
		{
		expecting_got(file, label, buf);
		return FALSE;
		}
	return TRUE;
}

Boolean read_numbers_and_label(Line_file *file
, int *nums, int num_count, char *label)
/*
 * Read in a line of form:
 *	 NN ... NN label
 * into nums.	This is the basis for read_rgb and read_xy.
 * Complain and return FALSE if there's a problem.
 */
{
	char *buf = file->line_buf;

	if (!must_read_line(file))
		return FALSE;
	while (--num_count >= 0)
		{
		if (!next_number(file, &buf, nums))
			return FALSE;
		++nums;
		}
	return verify_label(file, buf, label);
}

Boolean read_rgb(Line_file *file, RGB *rgb, char *label)
/*
 * Read in a line of form:
 *	 NN NN NN label
 * into an RGB triple.
 * Complain and return FALSE if there's a problem.
 */
{
	return read_numbers_and_label(file, (int *)rgb, 3, label);
}

Boolean read_xy(Line_file *file, XY *xy, char *label)
/*
 * Read in a line of form:
 *	 NN NN label
 * into an XY pair.
 * Complain and return FALSE if there's a problem.
 */
{
	return read_numbers_and_label(file, (int *)xy, 2, label);
}

Boolean read_int_and_label(Line_file *file, int *result, char *label)
/*
 * Read in a line of form:
 *	 NN label
 * into *result.
 * Complain and return FALSE if there's a problem.
 */
{
	return read_numbers_and_label(file, result, 1, label);
}

Boolean read_name_and_label(Line_file *file, char *name, int name_size
, char *label)
/*
 * Read in a line of form:
 *	 name label
 *  into name.
 */
{
	char *buf = file->line_buf;

	if (!must_read_line(file))
		return FALSE;
	if (!next_string(file, &buf, name, name_size))
		{
		expecting_got(file, "a name", "<cr>");
		return FALSE;
		}
	return verify_label(file, buf, label);
}

Boolean read_font_line(Line_file *file, Font_style *fs, char *label)
{
	char *buf = file->line_buf;

	if (!must_read_line(file))
		return FALSE;
	if (!next_string(file, &buf, fs->name, sizeof(fs->name)))
		{
		expecting_got(file, "font name", "<cr>");
		return FALSE;
		}
	if (!next_number(file, &buf, &fs->size))
		return FALSE;
	if (!next_number(file, &buf, &fs->spacing))
		return FALSE;
	if (!next_number(file, &buf, &fs->leading))
		return FALSE;
	return verify_label(file, buf, label);
}

Boolean inside_read_slide_style(Slide_style *sf, Line_file *file)
/*
 * Read slide file.  Complain if there's a problem.
 */
{
	if (!must_read_line(file))
		return FALSE;
	if (strcmp(file->line_buf, slide_style_magic) != 0)
		{
		Qtext("%s is not a Show'em Slide Style file.", file->file_name);
		return FALSE;
		}
	if (!read_rgb(file, &sf->background_color, "Background Color"))
		return FALSE;
	if (!read_name_and_label(file
	,  sf->background_image, sizeof(sf->background_image)
	,  "Background Image"))
		return FALSE;
	if (!read_rgb(file, &sf->title_color, "Title Color"))
		return FALSE;
	if (!read_font_line(file, &sf->title_font, "Title Font"))
		return FALSE;
	if (!read_int_and_label(file
	, &sf->title_justification, "Title Justification"))
		return FALSE;
	if (!read_xy(file, &sf->title_position, "Title Position"))
		return FALSE;
	if (!read_int_and_label(file, &sf->title_width, "Title Width"))
		return FALSE;
	if (!read_rgb(file, &sf->item_color, "Item Color"))
		return FALSE;
	if (!read_font_line(file, &sf->item_font, "Item Font"))
		return FALSE;
	if (!read_name_and_label(file
	,  sf->bullet_image, sizeof(sf->bullet_image),  "Bullet Image"))
		return FALSE;
	if (!read_rgb(file, &sf->bullet_color, "Bullet Color"))
		return FALSE;
	if (!read_name_and_label(file
	,  sf->logo_image, sizeof(sf->logo_image),	"Logo Image"))
		return FALSE;
	if (!read_xy(file, &sf->logo_position, "Logo Position"))
		return FALSE;
	if (!read_int_and_label(file
	,  &sf->antialias, "AntiAliased Text and Logo"))
			return FALSE;
	if (!read_int_and_label(file
	,  &sf->safe_title, "Safe Titling"))
			return FALSE;
	{
	char *buf = file->line_buf;

	/* Read inline of format NN NN NN Text Animation Mode */
	if (!must_read_line(file))
		return FALSE;
	if (!next_number(file, &buf, &sf->animode))
		return FALSE;
	if (!next_number(file, &buf, &sf->aniframes))
		return FALSE;
	if (!next_number(file, &buf, &sf->anispeed))
		return FALSE;
	if (!verify_label(file, buf, "Text Animation Mode"))
		return FALSE;
	}
}

Boolean read_slide_style(Slide_style *sf, char *file_name)
/*
 * Open slide style file and read it.  Complain if there's 
 * a problem.
 */
{
	int ok = FALSE;
	Line_file file;
	char buf[256];

	if (line_file_open(&file, file_name, buf, sizeof(buf)))
		{
		ok = inside_read_slide_style(sf, &file);
		line_file_close(&file);
		}
			
	return ok;
}

//-------------------------------------------------------------------------
// Some Paragraph oriented stuff - to read in blank line separated sections
// of a text file.
//-------------------------------------------------------------------------

typedef struct paragraph
	{
	char **lines;
	int line_count;
	int line_alloc;
	int xmargin;
	int xoff;
	int yoff;
	int font_width;
	int font_height;
	int title_height;
	int in_item_dist;
	Boolean line_token;
	Boolean nopause;
	char clip_name[PATH_SIZE];
	} Paragraph;

Boolean init_paragraph(Paragraph *p)
/*
 * Set up empty paragraph.
 */
{
	p->line_alloc = 50;
	p->line_count = 0;
	p->xmargin = 0;
	p->xoff = 0;
	p->yoff = 0;
	p->font_width = 0;
	p->font_height = 0;
	p->title_height = 0;
	p->in_item_dist = 0;
	p->line_token = FALSE;
	p->nopause = FALSE;
	strcpy(p->clip_name,"none");
	
	if ((p->lines = need_memory(p->line_alloc * sizeof(char *))) == NULL)
		{
		return FALSE;
		}
	return TRUE;
}

void free_paragraph(Paragraph *p)
/*
 * Free all dynamic memory associated with paragraph.
 */
{
	int i;

	if (p->lines != NULL)
		{
		for (i=0; i<p->line_count; ++i)
			{
			if (p->lines[i] != NULL)
				free(p->lines[i]);
			}
		free(p->lines);
		p->lines = NULL;
		}
}

Boolean paragraph_add_line(Paragraph *p, char *line)
/*
 * Add a line to paragraph.
 */
{


	if (p->line_count < p->line_alloc)
		{
		if (p->line_token == FALSE)
			{
			if ((p->lines[p->line_count] = strdup(line)) == NULL)
				{
				Qtext("Not enough memory for %s", line);
				return FALSE;
				}
			else
				{
				++p->line_count;
				return TRUE;
				}
			}
		else
			{
			return TRUE;
			}
		}
	else
		{
		Qtext("Too many lines in paragraph");
		return FALSE;
		}
}



Boolean line_is_token(Paragraph *p, char *input, Line_file *file)
/*
 * Check line for a token
 */
{
	char *token;
	char *token_line;
	char *temp;
	char *line;

	int i;
	Boolean another_token;

	p->line_token = FALSE;

	if ((token = strdup(input)) == NULL)
		{
		Qtext("Not enough memory for %s", input);
		return FALSE;
		}

	if ((temp = strdup(input)) == NULL)
		{
		Qtext("Not enough memory for %s", input);
		return FALSE;
		}

	if (next_string(file, &temp, token, strlen(temp)+1))
		{
		++temp;
		if ((token_line = strdup(temp)) == NULL)
			{
			Qtext("Not enough memory for %s", temp);
			return FALSE;
			}
		if (strlen(token_line) > 0)
			token_line[strlen(token_line)-1] = EOS;
		if (stricmp(token,"-nopause") == 0)
			{
			p->nopause = TRUE;
			p->line_token = TRUE;
			}
		if (stricmp(token, "-i") == 0)
			{
			strcpy(p->clip_name, token_line);
			p->line_token = TRUE;
			}
		if (stricmp(token, "-x") == 0)
			{
			strcpy(file->x_call, token_line);
			p->line_token = TRUE;
			}
		if (stricmp(token, "-b") == 0)
			{
			if (strlen(token_line) > 0)  //* Batch call must exist!
				strcpy(file->bat_call, token_line);
			p->line_token = TRUE;
			}
		return TRUE;
		}
	return FALSE;
}


Boolean read_paragraph(Paragraph *p, Line_file *file)
/*
 * Read file until next blank line into paragraph.
 */
{
	/* First skip over any blank lines. */
	for (;;)
		{
		if (!read_line(file))
			return FALSE;
		if (skip_space(file->line_buf) != NULL)
			break;
		}
	/* Now go to next blank line or EOF. */
	for (;;)
		{
		if (!line_is_token(p, file->line_buf, file))
			return TRUE;
		if (!paragraph_add_line(p, file->line_buf))
			return TRUE;
		if (!read_line(file))
			return TRUE;
		if (skip_space(file->line_buf) == NULL)
			return TRUE;
		}
}


//-------------------------------------------------------------------------
// Drawing routines
//-------------------------------------------------------------------------

typedef struct
/* Keep track of the color registers we want to draw in
 * (as opposed to the RGB values)
 */
	{
	int title;
	int item;
	int bullet;
	} Drawing_colors;


void find_drawing_colors(Drawing_colors *dc, Slide_style *sf)
/*
 * Find colors to draw slide in from RGB values in Slide_style. 
 */
{
	dc->title = ClosestColorInScreen(GetPicScreen()
	, sf->title_color.r, sf->title_color.g, sf->title_color.b);
	dc->item = ClosestColorInScreen(NULL
	, sf->item_color.r, sf->item_color.g, sf->item_color.b);
	dc->bullet = ClosestColorInScreen(NULL
	, sf->bullet_color.r, sf->bullet_color.g, sf->bullet_color.b);
}

static int find_intermediate_value(double percent, int start, int end)
/*
 *  Return a color percent between start and end.
 */
{
	int diff = end - start;
	return (start + percent*diff);
}

static void find_intermediate_color(RGB *result, double percent
, RGB *start, RGB *end)
/*
 *  Put a color percent between start and end into result
 */
{
	result->r = find_intermediate_value(percent, start->r, end->r);
	result->g = find_intermediate_value(percent, start->g, end->g);
	result->b = find_intermediate_value(percent, start->b, end->b);
}

static void ramp_range(RGB *start_color, RGB *stop_color)
/*
 * Puts a color ramp into the current range.
 */
{
	int *cluster;
	int ccount;
	int i;
	double percent;
	RGB intermediate;
	Errcode err;

	if ((err = GetCluster(&ccount, &cluster)) < Success)
		Qerror(err, "Can't GetCluster");
	else
		{
		for (i=0; i<ccount; ++i)
			{
			percent = (double)i/(double)(ccount-1);
			find_intermediate_color(&intermediate, percent
			,  start_color, stop_color);
			SetColorMap(cluster[i]
			, intermediate.r, intermediate.g, intermediate.b);
			}
		free(cluster);
		}
}

static void set_color_range(int start, int stop
, RGB *start_color, RGB *stop_color)
/*
 * This puts the colors from start to stop into the cluster.
 *  Then it makes a gradient in those colors from start_color to
 *  stop_color.
 */
{
	int *cluster;
	int i;
	int ccount = stop-start+1;

	if ((cluster = need_memory(ccount * sizeof(int))) != NULL)
		{
		for (i=0; i<ccount; ++i)
			{
			cluster[i] = start+i;
			}
		SetCluster(ccount, cluster);
		free(cluster);
		}
	ramp_range(start_color, stop_color);
}

static Boolean is_solid(char *name)
{
return stricmp(name, "solid") == 0;
}

static Boolean is_gradient(char *name)
{
return stricmp(name, "gradient") == 0;
}

static void preload_background(Slide_style *sf)
/*
 * Draw the background into swap screen.
 */
{
	char *name = sf->background_image;
	RGB *col = &sf->background_color;
	static RGB black = {0,0,0};
	int phy_width, phy_height;
	int back_color_index;
	static struct optPos op;

	GetPhysicalSize(&phy_width, &phy_height);
	if (sf->safe_title == TRUE)
		{
	  slide_width = phy_width*0.9;
	  slide_height = phy_height*0.9;
		}
	else
		{
		if ((phy_width > slide_width) || (phy_height > slide_height))
			{
			ResizeReset(phy_width, phy_height);
			slide_width = phy_width;
			slide_height = phy_height;
			}
		}

	SetFilled(TRUE);

	if (is_solid(name))
		{
		if (sf->safe_title == TRUE)
			ResizeReset(slide_width, slide_height);
		else
			{
			GetPhysicalSize(&phy_width, &phy_height);
			ResizeReset(phy_width, phy_height);
			}
		Clear();
		back_color_index = ClosestColorInScreen(NULL, 
		 sf->background_color.r, sf->background_color.g, sf->background_color.b);
		SetColor(back_color_index);
		SetInk("Opaque");
		Box(0, 0, slide_width, slide_height);
		}
	else if (is_gradient(name))
		{
		if (sf->safe_title == TRUE)
			ResizeReset(slide_width, slide_height);
		else
			{
			GetPhysicalSize(&phy_width, &phy_height);
			ResizeReset(phy_width, phy_height);
			}
		set_color_range(0, 63,  &black, col);
		SetInk("V Grad");
		Box(0, 0, slide_width, slide_height);
		}
	else
		{
		if (sf->safe_title == TRUE)		 //* Shrink the visible screen by 90%
			{
			GetPhysicalSize(&phy_width, &phy_height);
			ResizeReset(phy_width, phy_height);
			LoadPic(name);
			OptClearPos();
			OptDefaultCenters();
			OptGetPos(&op);
			op.bp = 90;			 //* new size to be 90% of original
			op.bq = 100;
			OptSetPos(&op);
			OptSetElement(EL_SCREEN);
			OptToFrame(1);
			CelClip();
			ResizeReset(slide_width, slide_height);
			CelMoveTo(slide_width/2, slide_height/2);
			CelPaste();
			}
		else
			{
			LoadPic(name);
			}
		}
	SwapClip();
}

static Boolean draw_clip(Paragraph *p)
/*
 * Draw the clip
 */
{
	int x,y,clipw,cliph;

	if (stricmp(p->clip_name, "none") == 0)
		return TRUE;
	if (LoadCel(p->clip_name) >= Success)
		{
		GetScreenSize( GetCelScreen(), &clipw, &cliph);
		x = clipw/2 + (slide_width - clipw)/2;
		y = p->title_height + cliph/2 + 
		(slide_height - p->title_height - cliph)/2;
		CelMoveTo(x, y);
		SetInk("opaque");
		CelPaste();
		return TRUE;
		}
	else
		{
		Qtext("Could not load clip file:n\"%s\"", p->clip_name); 
		return FALSE;
		}
}

static Boolean draw_logo(Slide_style *sf)
/*
 * Draw the logo
 */
{
	XY *pos;
	int logow,logoh;

	if (stricmp(sf->logo_image, "none") == 0)
		return TRUE;
	if (LoadCel(sf->logo_image) >= Success)
		{
		pos = &sf->logo_position;
		GetScreenSize( GetCelScreen(), &logow, &logoh);
		CelMoveTo(pos->x, pos->y);
		SetInk("opaque");
		CelPaste();
		if (sf->antialias)
			{
			PicDirtied();
			SetInk("unzag");
			CelPaste();
			}
		return TRUE;
		}
	else
		return FALSE;
}


static void set_shadow(int strength)
/*
 * Set up ink, etc for shadow.
 */
{
	SetInk("Dark");
	SetInkStrength(strength);
}

enum bullet_type {BT_NONE, BT_CEL, BT_CIRCLE};
typedef struct 
	{
	enum bullet_type type;  /* Type of bullet. */
	RGB bullet_color;		 /* Bullet Color. */
	int width, height;		/* Dimensions of bullet. */
	int text_xoff;			 /* Space from center of bullet to where 
									 * text starts */
	} Bullet_data;

void find_bullet(Bullet_data *bd, Slide_style *sf, Paragraph *pb)
/*
 * This will load the bullet into the Cel if possible
 * otherwise complain and revert to the circle bullet.
 * Returns type.
 */
{
	if (stricmp(sf->bullet_image, "none") == 0)
		{
		bd->width = bd->height = 0;
		bd->text_xoff = 0;
		bd->type = BT_NONE;
		}
	else if (stricmp(sf->bullet_image, "circle") == 0)
		{
		bd->width = bd->height = pb->font_height/2;
		bd->text_xoff = bd->width/2 + pb->font_width;
		bd->type = BT_CIRCLE;
		}
	else
		{
		if (Success > LoadCel(sf->bullet_image))
			{  /* On error revert to circle. */
			strcpy(sf->bullet_image, "circle");
			find_bullet(bd, sf, pb);
			}
		else
			{
			GetScreenSize(GetCelScreen(), &bd->width, &bd->height);
			bd->text_xoff = bd->width/2 + pb->font_width;
			bd->type = BT_CEL;
			}
		}
}

void draw_bullet(Slide_style *sf, Bullet_data *bd, int xoff, int yoff
, int color)
/*
 * Draw a bullet centered at xoff, yoff.  Should be called shortly after
 * find_bullet() - or at least before you reload the cel.
 */
{
	switch (bd->type)
		{
		case BT_CIRCLE:
			{
			int rad = bd->width/2;
			set_shadow(50);
			Circle(xoff+shadow_xoff, yoff+shadow_yoff, rad);
			SetInk("Opaque");
			SetColor(color);
			Circle(xoff, yoff, rad);
			if (sf->antialias)
				{
				PicDirtied();
				SetInk("unzag");
				Circle(xoff, yoff, rad);
				}
			}
			break;
		case BT_CEL:
			CelMoveTo(xoff, yoff);
			SetInk("Opaque");
			CelPaste();
			if (sf->antialias)
				{
				PicDirtied();
				SetInk("unzag");
				CelPaste();
				}
			break;
		case BT_NONE:
		default:
			break;
		}
}

static int draw_still_text( int x_start, int y_start, int w, int text_color
, char *string, int justification, Boolean antialias)
/*
 * Show text with a drop shadow.  Returns the # of lines of text
 * drawn.
 */
{
	int lines;
	SetJustify(justification);
	/* Draw drop-shadow. */
	set_shadow(50);
	WordWrap(x_start+shadow_xoff, y_start+shadow_yoff, w, slide_height, string);

	/* Draw text proper. */
	SetInk("Opaque");
	SetColor(text_color);
	WordWrap(x_start, y_start, w, slide_height, string);

	/* Do anti-aliasing. */
	if (antialias)
		{
		PicDirtied();
		SetInk("unzag");
		WordWrap(x_start, y_start, w, slide_height, string);
		}

	return WordWrapCountLines(w, string);
}

static int draw_scroll_text( int x_start, int y_start, int w
, int xoff, int yoff, int text_color, char *string, Boolean antialias
, int frate)
/*
 * Show text with a drop shadow.  Returns the # of lines of text
 * drawn.
 */
{
	int dist;							//* animation offset distance
	int dx;							  //* incremental distance per frame
	int nf;							  //* frame index

	/* Calculate size of word-wrap box. */
	w = slide_width*0.95 - x_start;

	/* Draw text proper. */

	SetJustify(0);
	dist = w;
	dx = dist / frate;
	for(nf=0;nf<frate; nf++)
		{
		dist -= dx;
		NextFrame();
		set_shadow(50);
		WordWrap(x_start+xoff+dist, y_start+yoff, w, slide_height, string);

		SetInk("opaque");
		SetColor(text_color);
		WordWrap(x_start+dist, y_start, w, slide_height, string);

		/* Do anti-aliasing. */
		if (antialias)
			{
			PicDirtied();
			SetInk("unzag");
			WordWrap(x_start+dist, y_start, w, slide_height, string);
			}
		}
	return WordWrapCountLines(w, string);
}

static int draw_fade_text( int x_start, int y_start, int w, int xoff, int yoff
, int text_color, char *string, Boolean antialias, int frate)
/*
 * Show text with a drop shadow.  Returns the # of lines of text
 * drawn.
 */
{
	int trans;						  //* ink strength for glass ink
	int tx;							  //* ink strength increment per frame
	int nf;							  //* frame index

	/* Draw text proper. */

SetJustify(0);
tx = 100 / frate;
trans = 0;
for(nf=0;nf<frate; nf++)
	{
	trans += 100/frate;
	NextFrame();
	set_shadow(trans/2);
	WordWrap(x_start+xoff, y_start+yoff, w, slide_height, string);

	SetInk("glass");
	SetInkStrength(trans);
	SetColor(text_color);
	WordWrap(x_start, y_start, w, slide_height, string);

	/* Do anti-aliasing. */
	if (antialias)
		{
		PicDirtied();
		SetInk("unzag");
		WordWrap(x_start, y_start, w, slide_height, string);
		}
	}
	return WordWrapCountLines(w, string);
}

static Boolean draw_still_items(Slide_style *sf, Drawing_colors *ci
, Paragraph *pi, Bullet_data *bi, Boolean save, char *base_name)
{
Boolean ok = TRUE;
int i;
int actual_lines;
char save_file[PATH_SIZE];
RGB *col = &sf->background_color;
int x,y,l,r,key;
static struct optPos op;

SetJustify(0);


for (i=1; i<=pi->line_count-1; ++i)
  {
  if ((pi->nopause == FALSE) && (sf->animode != AM_STILL) 
  && (save == FALSE))
	 {
	 printf("Any key, or click to continue, escape for next slide");
	 WaitClick(&x,&y,&l,&r,&key);
	 if (r || (key&0xff) == ESCAPE_KEY)
		if (Qquestion("Skip to next slide?"))
		{
		unprintf();
			break;
		}
	 unprintf();
	 }

  draw_bullet(sf, bi
  , pi->xmargin, pi->yoff+pi->font_height/2, ci->bullet);
  actual_lines = draw_still_text(pi->xoff, pi->yoff
  , slide_width*0.95 - pi->xoff, ci->item, pi->lines[i]
  , 0 , sf->antialias);
  pi->yoff += pi->in_item_dist + actual_lines*pi->font_height;
  }
if(save)
  {
  sprintf(save_file, "%s0a.FLC", base_name);
  printf("Saving file %s to disk", save_file);
  fprintf(script
  , "%s -p 0 -t fadein color(%d,%d,%d) fadeout color(%d,%d,%d)\n"
  , save_file
  , col->r/2, col->g/2, col->b/2
  , col->r/2, col->g/2, col->b/2);
  script_empty = FALSE;
  if (SaveFlic(save_file) < Success)
  	ok = FALSE;
  unprintf();
  }
return ok;
}

static Boolean draw_anim_items(Slide_style *sf, Drawing_colors *ci
, Paragraph *pi, Bullet_data *bi, Boolean save, char *base_name)
{
int i = 0;
char ox[2];
int actual_lines;
int item_count;
char save_file[PATH_SIZE];
RGB *col = &sf->background_color;
static struct optPos op;
int screen_width, screen_height;

item_count = pi->line_count;

if(save)
  {
  ox[0] = 65 + i;
  sprintf(save_file, "%s%s.FLC", base_name, ox);
  printf("Saving %s to disk",save_file);
  if (SaveFlic(save_file) < Success)
  	return FALSE;
  unprintf();

  if((item_count == 1) && (pi->nopause == TRUE))
	 fprintf(script
	 , "%s -p 1 -t fadein color(%d,%d,%d) fadeout color(%d,%d,%d)\n"
	 , save_file
	 , col->r/2, col->g/2, col->b/2
	 , col->r/2, col->g/2, col->b/2);
  else if((item_count == 1) && (pi->nopause == FALSE))
	 fprintf(script
	 , "%s -p 0 -t fadein color(%d,%d,%d) fadeout color(%d,%d,%d)\n"
	 , save_file
	 , col->r/2, col->g/2, col->b/2
	 , col->r/2, col->g/2, col->b/2);
  else if((item_count > 1) && (pi->nopause == TRUE))
	 fprintf(script
	 , "%s -p 1 -t fadein color(%d,%d,%d) \n"
	 , save_file
	 , col->r/2, col->g/2, col->b/2);
  else if((item_count > 1) && (pi->nopause == FALSE))
	 fprintf(script
	 , "%s -p 0 -t fadein color(%d,%d,%d)\n"
	 , save_file
	 , col->r/2, col->g/2, col->b/2);

  script_empty = FALSE;
  }


for (i=1; i<=item_count-1; i++)
  {
  draw_bullet(sf, bi
  , pi->xmargin, pi->yoff+pi->font_height/3, ci->bullet);
  InsertFrames(sf->aniframes);

  if(sf->animode == AM_SCROLL)
	 {
	 actual_lines = draw_scroll_text(pi->xoff, pi->yoff
	 , slide_width*0.95 - pi->xoff
	 , shadow_xoff, shadow_yoff, ci->item
	 , pi->lines[i], sf->antialias, sf->aniframes);
	 pi->yoff += pi->in_item_dist + actual_lines*pi->font_height;
	 }

  if(sf->animode == AM_FADE)
	 {
	 actual_lines = draw_fade_text(pi->xoff, pi->yoff
	 , slide_width*0.95 - pi->xoff
	 , shadow_xoff, shadow_yoff, ci->item
	 , pi->lines[i], sf->antialias, sf->aniframes);
	 pi->yoff += pi->in_item_dist + actual_lines*pi->font_height;
	 }

  if (save)
	 {
	 ox[0] = 65+i;
	 sprintf(save_file, "%s%s.FLC", base_name, ox);
	 printf("Saving flic %s to disk",save_file);
	 if (SaveFlic(save_file) < Success)
		return FALSE;
	 NextFrame();
	 DeleteFrames(sf->aniframes);		  //* delete previous frames 
	 BackFrame();						//* now return to the last frame

	 if(i == item_count-1)
		fprintf(script
		, "%s -p 0 -s %i -t fadeout color(%d,%d,%d)\n"
		, save_file, sf->anispeed
		, col->r/2, col->g/2, col->b/2);
	 else if((i != item_count-1) && (pi->nopause == TRUE))
		fprintf(script
		, "%s -s %i \n"
		, save_file, sf->anispeed);
	 else if((i != item_count-1) && (pi->nopause == FALSE))
		fprintf(script
		, "%s -p 0 -s %i \n"
		, save_file, sf->anispeed);
	 script_empty = FALSE;
	 unprintf();

	 }
  }
return TRUE;
}

static Boolean draw_one_slide(Slide_style *sf, Line_file *file
, Boolean save, char *base_name)
/*
 * This draws a paragraph according to the slide style.
 * Calculates all the x,y positions to draw everything, and draws
 * the standard slide, with the title.
 */
{
	Paragraph p;
	Boolean ok = FALSE;
	Drawing_colors colors;
	Bullet_data b;
	int title_font_height;
	int item_total_lines;
	int empty_height;
	int i;

	/*
	 * Load in next paragraph from input file and
	 * display it.
	 */

	
	find_drawing_colors(&colors, sf);
	if (init_paragraph(&p))
		{
		if (read_paragraph(&p, file))
			{
			if (p.line_count >= 1)
				{

				/* Draw background */
				CopyScreen(GetSwapScreen(), GetPicScreen()); 
				PicDirtied ();
				
				set_font_style(&sf->title_font);
				title_font_height = FontHeight();
				p.title_height = WordWrapCountLines(sf->title_width, p.lines[0]);
				p.title_height *=title_font_height;
				p.title_height +=sf->title_position.y;

				draw_clip(&p);
				draw_logo(sf);

				draw_still_text(sf->title_position.x
				, sf->title_position.y, sf->title_width, colors.title
				, p.lines[0], sf->title_justification, sf->antialias);

				set_font_style(&sf->item_font);
				p.font_height = FontHeight();
				p.font_width = StringWidth("x");
				p.xmargin = slide_width/10;
				
				find_bullet(&b, sf, &p);

				/* figure empty_height - the amount of the screen that has no text
				 * or title in it. */
				p.xoff = p.xmargin + b.text_xoff;  /* Left edge of text. */
				item_total_lines = 0;
				for (i=1; i<=p.line_count-1; ++i)
					{
					item_total_lines 
					+= WordWrapCountLines(slide_width*0.95-p.xoff, p.lines[i]);
					}
				empty_height = (slide_height*0.95) - p.title_height 
				- item_total_lines * p.font_height;

				/* Calculate the inter_item_distance and where to start item text
				 * vertically. 
				 * We'll leave a margin 1/3 again the space between items
				 * between the title and the items. */
				p.in_item_dist = (empty_height)/(p.line_count+1);
				p.yoff = p.title_height 
				+ (empty_height - p.in_item_dist*(p.line_count-2))/3;

				if(save)
					{
					switch(sf->animode)
						{
						case AM_STILL:
							if(!draw_still_items(sf, &colors, &p, &b, save, base_name))
								return FALSE;
							break;
						case AM_SCROLL:
							if(!draw_anim_items(sf, &colors, &p, &b, save, base_name))
								return FALSE;
							break;
						case AM_FADE:
							if(!draw_anim_items(sf, &colors, &p, &b, save, base_name))
								return FALSE;
							break;
						}
					}
				else
					{
					if(!draw_still_items(sf, &colors, &p, &b, save, base_name))
						return FALSE;
					}
				}
			ok = TRUE;	
			}
		free_paragraph(&p);
		}
	return ok;
}

//-------------------------------------------------------------------------
//	Internal routines.
//-------------------------------------------------------------------------

static Boolean make_sample_file(char *sample_file_name, Slide_style *sf)
/*
 * Make up a little text file that's got a sample of our stuff.
 */
{
FILE *f;
char name_only[PATH_SIZE];

if ((f = must_open(sample_file_name, "w")) == NULL)
	return FALSE;
fprintf(f, "-nopause\n");
fprintf(f,"Example Slide\n");
file_name_only(sf->title_font.name, name_only);
fprintf(f,"Title Font is %s\n", name_only);
file_name_only(sf->item_font.name, name_only);
fprintf(f,"Item Font is %s\n", name_only);
switch(sf->animode)
	{
	case AM_STILL:
		fprintf(f,"Output will be still images \n");
		break;
	case AM_SCROLL:
		fprintf(f, "Items will scroll across %i frames, at %i jiffies \n"
		, sf->aniframes, sf->anispeed);
		break;
	case AM_FADE:
		fprintf(f, "Items will fade through %i frames, at %i jiffies \n"
		, sf->aniframes, sf->anispeed);
		break;
	default:
		fprintf(f,"Output will be still images \n");
		break;
	}  
	
fprintf(f,  "Output Antialiasing is %s \n", off_on[sf->antialias]);
fclose(f);
return TRUE;
}

static Boolean display_sample(Slide_style *sf)
/*
 * Display current slide style sample on screen.
 */
{
	Line_file file;
	char *temp_name = "#:show'em.tmp";
	char buf[256];

	if (make_sample_file(temp_name, sf))
		{
		if (line_file_open(&file, temp_name, buf, sizeof(buf)))
			{
			draw_one_slide(sf, &file, FALSE, NULL);
			line_file_close(&file);
			}
		DosDelete(temp_name);
		}
}


Boolean check_text_exists()
/*
 * Make sure text file exists.  Squawk if it doesn't.
 */
{
	if (!DosExists(persistant_text))
		{
		Qtext("Please select Edit Text or Load Text and try again.");
		return FALSE;
		}
	return TRUE;
}

static void init_style(Slide_style *sf)
/*
 * Read in style.  If there's no style file or some other problem
 * then use default style.
 */
{
	set_default_style(sf);
	if (DosExists(persistant_style))
		read_slide_style(sf, persistant_style);
}


static Boolean render_slides(Slide_style *sf, char *batch_name)
/*
 * Open up text file and go make as many slides as there are
 * paragraphs.  Write out commands to script too.
 */
{
Boolean ok = TRUE;
int i;
Line_file lfile;
char buf[256];
FILE *batch;
int script_num;
char script_name[PATH_SIZE];
char slide_name[PATH_SIZE];
char dev[4], dir[PATH_SIZE], file[10], suff[5];
char base_name[PATH_SIZE];
static char temp_dir[PATH_SIZE];
static char ani_dir[PATH_SIZE];
ok = FALSE;
	
/* Figure out base name of numbered flics.  Will convert something
 * like C:\ANI\1STQUARTR.SCR into C:\ANI\1STQ  */

fnsplit(batch_name, dev, dir, file, suff);
file[4] = 0;	/* Leave room for number. */
sprintf(base_name, "%s%s%s", dev, dir, file);

//* GetProgramDir(ani_dir);
GetDir(ani_dir);
GetResourceDir(temp_dir);
SetDir(temp_dir);
SetDir("..");
strcpy(temp_dir, ani_dir);
GetDir(ani_dir);
SetDir(temp_dir);

	if (line_file_open(&lfile, persistant_text, buf, sizeof(buf)))
		{
		if ((batch = must_open(batch_name, "w")) != NULL)
			{
			fprintf(batch, "@echo off \n");
			sprintf(script_name, "%s%04d.scr", base_name, script_num);
			if ((script = must_open(script_name, "w")) != NULL)
				{
				for (i=0; ; ++i)  /* Keep count. */
					{
					strcpy(lfile.x_call, "none");
					strcpy(lfile.bat_call, "none");
					sprintf(slide_name, "%s%02d", base_name, i);
					if(draw_one_slide(sf, &lfile, TRUE, slide_name))
						{
						if (strcmp(lfile.x_call, "none") != 0)
							{
							fprintf(script, "%s \n", lfile.x_call);
							script_empty = FALSE;
							strcpy(lfile.x_call, "none");
							}
						if (strcmp(lfile.bat_call, "none") != 0)
							{
							if(!script_empty)
								{
								fprintf(script,"Exittodos \n");
								fprintf(batch,"%sANIPLAY -AUTO -CFG %sAA.CFG %s \n", 
										  ani_dir, ani_dir, script_name);
								}
							fprintf(batch,"%s \n",lfile.bat_call);
							fclose(script);
							script_num = script_num +1;
							sprintf(script_name, "%s%04d.scr", base_name, script_num);
							if((script = must_open(script_name,"w")) == NULL)
								{
								ok = FALSE;
								break;
								}
							script_empty = TRUE;
							strcpy(lfile.bat_call, "none");
							}
						}
				else
					  {
					ok = TRUE;
				  break;
				  }
					}
				fclose(script);
				if(!script_empty)
					{
					fprintf(batch,"%sANIPLAY -AUTO -CFG %sAA.CFG %s \n",
							  ani_dir, ani_dir, script_name);
					}
				else
					DosDelete(script_name);
				}
			fclose(batch);
			}
		line_file_close(&lfile);
		}
	return ok;
}

static Boolean preview_slides(Slide_style *sf)
/*
 * Put up one slide after the other,  pausing for a key press or
 * mouse click between each one.
 */
{
	Line_file lfile;
	char buf[256];
	Boolean ok = FALSE;
	Boolean go_on;
	int i;
	int x,y,l,r,key;
	int phy_width, phy_height;

	GetPhysicalSize(&phy_width, &phy_height);

	if (line_file_open(&lfile, persistant_text, buf, sizeof(buf)))
		{
		for (i=0; ; ++i)  /* Keep count. */
			{
			strcpy(lfile.x_call, "none");
			strcpy(lfile.bat_call, "none");
			if (!draw_one_slide(sf, &lfile, FALSE, NULL))
				break;
			else
				ok = TRUE;
			if (strcmp(lfile.x_call, "none") != 0)
				Qtext("The line...\n\n\"%s\"\n\nwill be written to the script"
				, lfile.x_call);
			if (strcmp(lfile.bat_call, "none") != 0)
				Qtext("The line...\n\n\"%s\"\n\nwill be written to the batch file"
				, lfile.bat_call);
			if (strcmp(lfile.x_call, "none") == 0 &&
				strcmp(lfile.bat_call, "none") == 0)
				{
			 if (i == 0)
				  printf("Any key or click to continue, escape to abort.");
WAIT_INPUT:
				WaitClick(&x,&y,&l,&r,&key);
				if ((key&0xff) == ESCAPE_KEY)
			  {
				  if (Qquestion("Abort Preview?"))
					{
					unprintf();
					break;
					}
			  else
			  	goto WAIT_INPUT;
			  }
				unprintf();
				}
			}
		line_file_close(&lfile);
		}
	return ok;
}


//-------------------------------------------------------------------------
// Routines that interact with User
//-------------------------------------------------------------------------
Boolean css_menu(Slide_style *sf)
/*
 * Interpret the create slide show menu.
 */
{
int choice;
static int cursor_pos, line_pos;
static char text_name[PATH_SIZE] = "show'em.txt";
static char bat_name[PATH_SIZE] = "show'em.scr";
FILE *empty_text;

for (;;)
	{
	choice = Qmenu(css_choices, Array_els(css_choices), css_header);
	switch(choice)
		{
		case CSS_HELP:
			multi_screen_help(css_help, Array_els(css_help));
			break;
		case CSS_EDIT:
			QeditFile(persistant_text, &cursor_pos, &line_pos);
			break;
		case CSS_LOAD:
			if (Qfile(".TXT", "Load", text_name, text_name
			, FALSE, "Load Slide Text File"))
				copy_file(text_name, persistant_text);
			break;
		case CSS_SAVE:
			if (check_text_exists())
				{
				if (Qfile(".TXT", "Save",  text_name, text_name
				, TRUE,  "Save Slide Text File"))
					if (overwrite_ok(text_name))
						copy_file(persistant_text, text_name);
				}
			break;
		case CSS_DEL:
			if (Qquestion("This will erase the text buffer,\nand you will "
						"lose any unsaved text.\n\nOkay to Erase?"))
				{
				if ((empty_text = fopen(persistant_text, "w")) == NULL)
					Qtext("Cannot flush the text file");
				else
				fclose(empty_text);
				}
			break;
		case CSS_PREVIEW:
			if (check_text_exists())
				preview_slides(sf);
			break;
		case CSS_RENDER:
			if (check_text_exists())
				if (Qfile(".BAT", "Output", bat_name, bat_name
				, TRUE, "Output to Batch File"))
					{
					if (overwrite_ok(bat_name))
						{
						if (render_slides(sf, bat_name))
							return FALSE;  /* Get out of program! */
						}
					}
			break;
		default:
			return TRUE;
		}
	}
}


Boolean load_new_font(Font_style *fs)
/*
 * Load font and record the name and size.
 */
{
	Font_style new_style;
	char full_font_name[PATH_SIZE];

	/* Load up the current selection */
	set_font_style(fs);
	/* Go to font requestor. */
	Qfont();
	get_font_style(&new_style);
	/* Return whether it's a new one */
	if (memcmp(fs, &new_style, sizeof(new_style)) != 0)
		{
		memcpy(fs, &new_style, sizeof(*fs));
		return TRUE;
		}
	else
		return FALSE;
}

void title_menu(Slide_style *sf)
/*
 * Interpret title menu
 */
{
	int choice;
	int just_choice;
	Boolean is_changed;
	int color;
	int x,y,w,h;

	for (;;)
		{
		is_changed = FALSE;
		choice = Qmenu(title_choices, Array_els(title_choices), title_header);
		switch(choice)
			{
			case TITLE_COLOR:
				if ((color = Qcolor()) >= Success)
					{
					translate_to_rgb(color, &sf->title_color);
					is_changed = TRUE;
					}
				break;
			case TITLE_POS:
				TitleSetText("Example Slide");
				set_font_style(&sf->title_font);
				SetJustify(sf->title_justification);
				TitleSetPosition(sf->title_position.x, sf->title_position.y
				,  sf->title_width,  FontHeight());
				TitleEdit();
				TitleGetPosition(&x,&y,&w,&h);
				if (x != sf->title_position.x || y != sf->title_position.y ||
					w != sf->title_width)
					{
					sf->title_position.x = x;
					sf->title_position.y = y;
					sf->title_width = w;
					is_changed = TRUE;
					}
				break;
			case TITLE_JUST:
				if (just_choice = Qmenu(title_just_choices
								, Array_els(title_just_choices)
								, title_just_header));
					if (just_choice-1 != sf->title_justification
						&& just_choice != 0)
						{
						sf->title_justification = just_choice-1;
						is_changed = TRUE;
						}
				break;
			case TITLE_FONT:
				is_changed = load_new_font(&sf->title_font);
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}

void item_menu(Slide_style *sf)
/*
 * Interpret item menu
 */
{
	int choice;
	Boolean is_changed;
	int color;

	for (;;)
		{
		choice = Qmenu(item_choices, Array_els(item_choices), item_header);
		switch(choice)
			{
			case ITEM_COLOR:
				if ((color = Qcolor()) >= Success)
					{
					translate_to_rgb(color, &sf->item_color);
					is_changed = TRUE;
					}
				break;
			case ITEM_FONT:
				is_changed = load_new_font(&sf->item_font);
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}

void bullet_menu(Slide_style *sf)
/*
 * Interpret bullet menu
 */
{
	int choice;
	Boolean is_changed;
	char header[80];
	char file_name[32];
	char bullet_name[PATH_SIZE];
	int color;
	
	strcpy(bullet_name, sf->bullet_image);

	for (;;)
		{
		file_name_only(sf->bullet_image, file_name);
		sprintf(header, "%s (%s)", bullet_header, file_name);
		is_changed = FALSE;
		choice = Qmenu(bullet_choices, Array_els(bullet_choices), header);
		switch(choice)
			{
			case BULLET_COLOR:
				if ((color = Qcolor()) >= Success)
					{
					translate_to_rgb(color, &sf->bullet_color);
					strcpy(sf->bullet_image, "circle");
					is_changed = TRUE;
					}
				break;
			case BULLET_CIRCLE:
				if (!stricmp(sf->bullet_image, "circle") == 0)
					{
					strcpy(sf->bullet_image, "circle");
					is_changed = TRUE;
					}
				break;
			case BULLET_USE_CEL:
				if (Qfile(".CEL;.FL?", "Load"
				, bullet_name, bullet_name
				, FALSE, "Load Bullet Image"))
					if (LoadCel(bullet_name) >= Success)
						{
						strcpy(sf->bullet_image, bullet_name);
						is_changed = TRUE;
						}
				break;
			case BULLET_NONE:
				if (!stricmp(sf->bullet_image, "none") == 0)
					{
					strcpy(sf->bullet_image, "none");
					is_changed = TRUE;
					}
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
	}
}  

void background_menu(Slide_style *sf)
/* 
 * Interpret background menu.
 */
{
	int choice;
	char file_name[32];
	char header[80];
	int color;
	char background_name[PATH_SIZE];
	Boolean is_changed;

	strcpy(background_name, sf->background_image);

	for (;;)
		{
		file_name_only(sf->background_image, file_name);
		sprintf(header, "%s (%s)", background_header, file_name);
		is_changed = FALSE;
		choice = Qmenu(background_choices
		, Array_els(background_choices), header);
		switch(choice)
			{
			case BACKGROUND_GET_COLOR:
				if ((color = Qcolor()) >= Success)
					{
					translate_to_rgb(color, &sf->background_color);
				if (is_solid(sf->background_image)
				||  is_gradient(sf->background_image))
					 is_changed = TRUE;
					}
				break;
			case BACKGROUND_SOLID:
			if (!is_solid(sf->background_image))
					{
					strcpy(sf->background_image, "solid");
					is_changed = TRUE;
					}
				break;
			case BACKGROUND_GRADIENT:
			if (!is_gradient(sf->background_image))
					{
					strcpy(sf->background_image, "gradient");
					is_changed = TRUE;
					}
				break;
			case BACKGROUND_USE_PIC:
				if (Qfile(".GIF;.FL?;.PCX", "Load"
				, background_name, background_name
				, FALSE, "Load Background Image"))
					if (LoadPic(background_name) >= Success)
						{
				  strcpy(sf->background_image, background_name);
				  SwapClip();
				  display_sample(sf);
						}
				break;
			default:
				return;
			}
		if (is_changed)
			{
			preload_background(sf);
			display_sample(sf);
			}
		}
}

void logo_menu(Slide_style *sf)
/*
 * Interpret logo menu
 */
{
	int choice;
	Boolean is_changed;
	char header[80];
	char file_name[32];
	char logo_name[PATH_SIZE];
	int choice_count;

	strcpy(logo_name, sf->logo_image);
	
	for (;;)
		{
		file_name_only(sf->logo_image, file_name);
		sprintf(header, "%s (%s)", logo_header, file_name);
		is_changed = FALSE;
		choice = Qmenu(logo_choices, Array_els(logo_choices), header);
		switch(choice)
			{
			case LOGO_USE_CEL:
				if (Qfile(".CEL;.FL?", "Load"
				, logo_name, logo_name
				, FALSE, "Load Logo Image"))
					{
					if (LoadCel(logo_name) >= Success)
						{
						strcpy(sf->logo_image, logo_name);
						is_changed = TRUE;
						}
					}
				break;
			case LOGO_POSITION:
				{
				if (stricmp(sf->logo_image, "none") != 0)
					{
					if (LoadCel(sf->logo_image) >= Success)
						{
						int x,y,w,h;

						GetScreenSize(GetCelScreen(), &w, &h);
						x = sf->logo_position.x - w/2;
						y = sf->logo_position.y - h/2;
						if (DragBox(&x,&y,&w,&h))
							{
							sf->logo_position.x = x + w/2;
							sf->logo_position.y = y + h/2;
							is_changed = TRUE;
							}
						}
					}
				}
				break;
			case LOGO_NONE:
				if (!stricmp(sf->logo_image, "none") == 0)
					{
					strcpy(sf->logo_image, "none");
					is_changed = TRUE;
					}
				break;
			default:
				return;
			}
		if (is_changed)
			display_sample(sf);
		}
}

static Boolean ani_settings(Slide_style *sf)
{
	Boolean ok = FALSE;
	int i;
	int x;
	char prompt[80];

	sprintf(prompt,"Select number of frames per item, currently %i"
	,  sf->aniframes);
	i = sf->aniframes;
	Qnumber(&i, 1, 100, prompt);
	if(i < 100 || i > 0)
		{
		sprintf(prompt, "Select playback speed, currently %i"
		, sf->anispeed);
		x = sf->anispeed;
		Qnumber(&x, 0, 100, prompt);
		if(x > 0 || x < 100)
			{
			sf->aniframes = i;
			sf->anispeed = x;
			ok = TRUE;
			}
		else
			Qtext("Speed must be between 1, and 100");
		}
	else
		Qtext("Frames per item must be between 1, and 100");

return ok;
}

void out_menu(Slide_style *sf)
/* 
 * Interpret output menu.
 */
{
	int choice;
	char anti_line[40];
	char safe_line[40];
	Boolean is_changed = FALSE;

	for (;;)
		{
		if (sf->antialias)		 /* Make sure value is TRUE or FALSE */
			sf->antialias = TRUE;
		sprintf(anti_line, "Antialiasing is %s", off_on[sf->antialias]);
		out_choices[OUT_ANTIALIAS-1] = anti_line;

		if (sf->safe_title)		 /* Make sure value is TRUE or FALSE */
			sf->safe_title = TRUE;
		sprintf(safe_line, "Safe Titling is %s", off_on[sf->safe_title]);
		out_choices[OUT_SAFE_TITLE-1] = safe_line;

		choice = Qmenu(out_choices, Array_els(out_choices), out_header);
		switch(choice)
			{
			case OUT_HELP:
				Qtext(out_help1);
				break;
			case OUT_STILL:
				if(!sf->animode == AM_STILL)
					{
					sf->animode = AM_STILL;
					display_sample(sf);
					}
				break;
			case OUT_SCROLL:
				if(!sf->animode == AM_SCROLL || (ani_settings(sf)))
					{
					sf->animode = AM_SCROLL;
					display_sample(sf);
					}
				break;
			case OUT_FADE:
				if(!sf->animode == AM_FADE || (ani_settings(sf)))
					{
					sf->animode = AM_FADE;
					display_sample(sf);
					}
				break;
			case OUT_ANTIALIAS:
				sf->antialias = !sf->antialias;
				display_sample(sf);
				break;
			case OUT_SAFE_TITLE:
				sf->safe_title = !sf->safe_title;
				preload_background(sf);
				display_sample(sf);
				break;
			default:
				return;
			}
		}
	return;
}

void ssf_menu(Slide_style *sf)
/*
 * Set Slide Style menu.
 */
{
int choice;
static char file_name[PATH_SIZE] = "show'em.sss";
char anti_line[40];

for (;;)
	{
	choice = Qmenu(ssf_choices, Array_els(ssf_choices), ssf_header);
	switch(choice)
		{
		case SSF_HELP:
			Qtext(ssf_help);
			break;
		case SSF_TITLE:
			title_menu(sf);
			break;
		case SSF_ITEMS:
			item_menu(sf);
			break;
		case SSF_BULLET:
			bullet_menu(sf);
			break;
		case SSF_BACKGROUND:
			background_menu(sf);
			break;
		case SSF_LOGO:
			logo_menu(sf);
			break;
		case SSF_OUTPUT:
			out_menu(sf);
			break;
		case SSF_LOAD:
			if (Qfile(".SSS", "Load",  file_name, file_name
			, TRUE,  "Load Show'em Slide Style"))
				{
				read_slide_style(sf, file_name);
				preload_background(sf);
				display_sample(sf);
				}
			break;
		case SSF_SAVE:
			if (Qfile(".SSS", "Save",  file_name, file_name
			, TRUE,  "Save Show'em Slide Style"))
				if (overwrite_ok(file_name))
					if (!write_slide_style(sf, file_name))
						Qtext("Could not save Style %s", file_name);
			break;
		default:
			return;
		}
	}
}



void mm_menu(Slide_style *sf)
/*
 * Interpret the top level menu.
 */
{
int choice;

for (;;)
	{
	choice = Qmenu(mm_choices, Array_els(mm_choices), mm_header);
	switch(choice)
		{
		case MAIN_HELP:
			multi_screen_help(mm_help, Array_els(mm_help));
			break;
		case MAIN_CREATE:
			if (!css_menu(sf))
				return;
			break;
		case MAIN_FORMAT:
			ssf_menu(sf);
			break;
		default:
			return;
		}
	}
}
	

main()
{
	static Slide_style style;	  //* Must be static!

	if (ignore_changes())
		{
		GetSize(&slide_width, &slide_height);
		shadow_xoff = slide_width/200;
		shadow_yoff = slide_height/150;
		SetFrameCount(1);
		init_style(&style);
		preload_background(&style);
		display_sample(&style);
		mm_menu(&style);
		write_slide_style(&style, persistant_style);
		}
}

