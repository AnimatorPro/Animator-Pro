

          Notes on implementing a display driver for PJ

I. Overview

     PJ display drivers let PJ run on a variety of video display
cards.  Most hardware with a byte-a-pixel architecture can
support a PJ display driver.

     Currently we've written drivers for standard VGA in 320x200
mode 13H, and a number of different resolutions for IBM 8514/A
register-compatible cards and Video 7 VRAM cards.  The source
code to these drivers is in the PJ developer's kit.  The Video 7
VRAM driver is a good starting point for other Super VGA cards.

     There are 5 stages of writing a PJ display driver:

     1.   Get familiar with the Phar Lap DOS-extender 386    
          programming environment.  The sample drivers compile
          with Watcom 386 or High C and Phar Lap's assembler and
          linker.  With some adaptation you should be able to
          build a driver using other 386 development tools.

     2.   Learn the interface between PJ and the display    
          driver.  Build the sample NULL driver and verify it
          with the driver test programs.

     3.   Build a dot-speed driver.  At this stage you'll only
          implement three functions that talk to the display
          hardware -- put_dot(), get_dot(), and set_colors()
          (which sets the color map of the display).   This will
          produce a working, albeit very slow, driver. 

     4.   Build a paint-speed driver.  Here you'll fill in all
          the driver functions except those directly concerned
          with playing back animations.  Necessary functions are:
               o -- draw a solid horizontal line
               o -- move a horizontal line of pixels to and from
                    memory.
               o -- text-blit (moving from a single bit-plane of
                    memory to video card where 0's in bit-plane
                    are skipped, and 1's are set to a color.) 
          Other functions less necessary but which will speed up
          the paint functions and the menuing system are:
               o -- blit from memory to display card (no logic,
                    just move pixels).
               o -- blit from display card to memory
               o -- blit within display card
               o -- set a solid rectangle
               o -- Transparent blit from memory to display card. 
                    Like blit  but pixels in the transparent
                    color in the source are not copied to the
                    destination.
               o -- if the card has non-display memory, provide a
                    function  to allow PJ to use this memory for
                    off-screen graphics buffers.
          At this point your driver will play back animations at
          about 1/2 speed, and otherwise seem like a 'real'
          driver.

     5.   Build an animation-speed driver.  This requires two
          routines:
               o -- run-length-decompression (which is used for
                    the first frame of a flic)
               o -- delta-decompression (used for other frames). 

          These are the most complex routines in the driver, but
          still are not too bad.  On the average about 2-3K of
          code seems to do the job.

          Optionally an animation speed driver can implement
          color palette animation and Animator 1.0-compatible
          decompression routines.

     Someone already familiar with the display hardware and the
Phar Lap/Watcom 386 environment might find two weeks sufficient
to write a PJ display driver.  About 1/2 this time would likely
be spent understanding the PJ/driver interface, and a good deal
of the rest of the time implementing the decompression routines.

II. The Phar Lap programming environment.

     The first thing you'll need to do is make sure you have the
necessary hardware and software to program in this environment.
You'll need:

     o -- An IBM PC compatible computer with a 80386 compatible
          processor and 4 meg of RAM.
     o -- A copy of the Phar Lap DOS extender (run386.exe).
     o -- The Phar Lap 386 Linker and Assembler (usually sold
          with the  DOS extender above).
     o -- The Phar Lap 386 Symbolic Debugger (not required but
          definitely recommended).
     o -- The Watcom 386 C or MetaWare High C MS/DOS386
     o -- The PJ developer's kit.
     o -- A copy of PJ.

     Building a PJ display driver is a medium-sized programming
project.  As an example the Video 7 VRAM driver contains:

     14 .asm files ranging from 27 to 213 lines each, but mostly 
on the short side.
     2 .c files of 226 and 265 lines for the driver itself. 
     4 .c files to provide a test scaffolding for the driver  
before trying to link it into PJ.
     8 header files for the C and assembler.  2 of these are
short and specific to the VRAM driver.  The others are longer (up
to 400 lines) and detail the PJ/driver interface.

     Though the executable part of the VRAM driver is just shy of
5k, it is not a small project.  It would be a good idea to build
a small demo graphics program for your display card involving
both C and assembler under Phar Lap before diving into the sample
driver sources.
III.  Devices and Rasters.

     The driver consists of two classes of object -- device and
raster.  The display object is responsible for:
          o -- checking if the display hardware is in place.
          o -- telling PJ what display modes and resolutions it's
               capable of supporting
          o -- switching the display to a graphics mode.
          o -- restoring the start-up display.
          o -- creating the primary raster object associated with
               the display.
          o -- (optionally) creating off-screen raster objects. 
     A raster object is responsible for the graphics aspect of
the driver.  In the NULL driver the three required raster methods
do nothing but count the number of times they are called.  They
are:
          o -- void put_dot(Raster *r,Pixel color,Coor x,Coor y)
          o -- Pixel get_dot(Raster *r, Coor x, Coor y)
          o -- set_cmap(Raster *r, char colors[][3], int start,
               int color_count) 
     The final method prints the number of times the other
functions are called:
          o -- close_raster(Raster *r) 

     To make it easier to develop drivers we've implemented a set
of "generic methods" which are called in place of unimplemented
methods in the driver.  A method in this sense is nothing more
than a jump-table associated with the raster object.  NULLs in
the jump table will be directed to a PJ-supplied generic.

     The generics are arranged in a hierarchy.  At the lowest 
level are the dot-at-time pixel access routines.  The
generic draw_horizontal_line() routine could be simply: 
  draw_horizontal_line(Raster *r, Pixel color, 
              Coor x, Coor y, Ucoor width)
  {
      while (--width >= 0)
          r->lib->put_dot(r, color, x++, y);
  }

     Similarly:
  draw_rectangle(Raster *r,Pixel color,
          Coor x, Coor y, Ucoor width, Ucoor height)  
  {
      while (--height >= 0)
          r>lib>draw_horizontal_line(r,color,x,y++,width);
  }

     You need not worry about the details of this for now. If
you're curious take a look at the file generic.c to see how the
decompression routines can be implemented in C in terms of
horizontal lines and line blits.
IV.  Standard Types in the Driver Kit.

PJ uses a number of variable types in addition to the usual C
short long and int's.  Here's a brief run-down of the standard PJ
types.
     int       32 bit.  (All Phar Lap compatible compilers seem
               to adhere to this.)
     BYTE      signed char
     UBYTE     unsigned char
     USHORT    unsigned short
     ULONG     unsigned long
     Boolean   int.  By convention Boolean is either TRUE (1) or
               FALSE (0)
     Errcode   int.  By convention returned by a function that
               could fail.  Errcode >= Success (0) indicates all
               is well.  Otherwise Errcode is some negative value
               from the file errcodes.h.
     Dfile     Unbuffered file handle.
     Coor      int.  By convention a pixel coordinate.
     Ucoor     unsigned int.  By convention a pixel width/height.
     Pixel     unsigned char. 
     Vdevice   struct vdevice.  Main data structure for the
               device oriented part of driver. (Describe fully in
               next section).
     Raster    struct raster.  Main data structure for the raster
               oriented part of the driver.       

V.  The PJ/driver interface.

     A driver is not a standalone program.  It does not have a
main() procedure.  It is not bracketed by the usual program
start-up and exit code.  A driver can't use the standard C
function libraries.   Some drivers won't need to do memory
allocation or file input/output.  Those that do can access these
routines via the "syslib" pointer in the vdevice structure.  (See
the section on functions provided by PJ below for details.)

     The driver is loaded by PJ, and control is transfered to the
first instruction in the file.  This is contained in entry.asm,
which should always be linked first.   The code in entry.asm does 
nothing but jump to a function called disp_entry() which is in
device.c.  (entry.asm also contains a small dummy stack segment
to satisfy the linker.  In run time the driver uses the same
stack as PJ, which is guaranteed to have 4K left for the driver's
use.)

     The display entry function is prototyped as follows
          int entry(
              struct vdevice *dev;  /* device pointer. */
              int pjfamily,   /* Always 0x1AA2 */
              int pjprog,     /* 0xAA20 if called from PJ, 0xAB20 if
                              from Crop */ 
              int pjrev)      /* 0 for pj1.0. */
entry returns an error code.  0 if successful.  The display driver fills
in parts of the structure pointed to by dev (see below).  The driver
should verify that pjfamily is set to the correct magic number, and
return Err_wrong_family immediately if it's not.   pjprog should ideally
not be looked at, but if for some reason you need to use different
strategies when running under different programs (Crop uses 256K less
memory for example) it is here.  pjrev is not important now.  If a later
driver needs to make sure it's running on a later PJ, or perhaps limit
itself if not, this is here.  

The main thing the driver entry function does is fill in the
parts of the vdevice structure commented "set by driver" below. 
     typedef struct vdevice {
     USHORT struct_size; /* sizeof struct vdcb for future
                         compatibility.  Set by PJ */
     USHORT id;        /* set to VDL_DRIVER_MAGIC by driver */
     USHORT version;   /* for future compatibility. Set by PJ. */
     USHORT reserved0;   /* set to 0 by PJ. */
     struct vdevice_lib *lib; /* device library - set by driver*/
     USHORT dev_lib_count;    /* # of functions in device library
                                        - set by driver */
     USHORT rast_lib_count;   /* # of functions in raster library
                                        - set by driver */
     USHORT first_rtype;  /* first raster type allocated to this
                                        driver set by PJ */
     USHORT mode_count;  /* Number of major graphics modes 
                                        - set by driver */
     Errcode (*entry)(struct vdevice *dev, int family, int
          program, int version); /* entry point for loaded
                                   drivers.  Set by PJ.*/
     struct syslib *syslib;   /* file io and memory library. Set
                                        by PJ. */
     struct rastlib *grclib;  /* 'generic' raster library. Set by
                                        PJ. */
     LONG reserved[8];
} Vdevice;



   VI. The Vdevice_lib - Device Oriented Functions Provided by the Driver

   The vdevice_lib structure contains nothing but function pointers.  It is
   place where most of the device oriented code for the driver lives.  Here is
   the declaration of the structure with brief comments followed by a more
   verbose description of each function in the vdevice_lib.

   typedef struct vdevice_lib {
        /* init - function called immediately after loading driver. */
        Errcode (*init)(Vdevice *vd);
        /* cleanup - function called to close up library right before it's
        code space is freed */
        Errcode (*cleanup)(Vdevice *vd);
        /* detect - is our hardware attatched? */
        Errcode (*detect)(Vdevice *vd);
        /* get_modes - get information about modes supported by device. */
        Errcode (*get_modes)(Vdevice *vd, USHORT mode, Vmode_info *pvm);
        /* mode_text - get extended text description of mode */
        char * (*mode_text)(Vdevice *vd, USHORT mode);
        /* set_max_height - for a set width return max height can support */ 
        int (*set_max_height)(Vdevice *vd, Vmode_info *vm);
        /* open_graphics - Open up primary screen. */
        Errcode (*open_graphics)(Vdevice *vd, USHORT mode, 
             Raster *r, LONG width, LONG height);
        /* close_graphics - go back to text mode */
        Errcode (*close_graphics)(Vdevice *vd);
        /* open_cel - try to get secondary graphics buffer from the card.  May
        be a non-displayable buffer (as in the undo-buffer), or displayable if
        the card supports double-buffering.  */
        Errcode (*open_cel)(Vdevice *vd, USHORT mode, 
             Raster *r, LONG width, LONG height, UBYTE displayable);
        /* show_rast - Display a different screen (used mostly when
        double-buffering) */
        Errcode (*show_rast)(Vdevice *vd, Raster *r);
        /* wait_vblank - wait for vertical blank.   */
        Errcode (*wait_vblank)(Vdevice *vd, Raster *r);
   } Vdevice_lib;

   Errcode init(struct vdevice *vd); 
   Function:           This function is called by PJ (or a PJ family program)
                       immediatedly after the driver is loaded.  If init
                       returns a negative value PJ will abort the driver.
   Parameters:         struct vdevice *vd       Device pointer.
   Return Value:       Errcode                  0 if initialization was
                                                successful, otherwise a
                                                negative Errcode (see
                                                errcodes.h).
   Implementation:     Optional

   Errcode cleanup(struct vdevice *vd);
   Function:           This function is called by PJ (or a PJ family program)
                       right before the driver's code space is freed.  It
                       should free up any memory allocated by the driver and
                       close any open files.
   Parameters:         struct vdevice *vd       Device pointer
   Return Value:       Errcode                  0 if cleanup was successful,
                                                otherwise a negative Errcode
                                                (see errcodes.h).
   Implementation:     Optional

   Errcode detect(struct vdevice *vd);
   Function:           Finds out whether hardware is attatched.  detect() must
                       not use ports or write to memory specific to the card
                       as it may be called when the card is not attatched. 
                       This function can switch video modes but must restore
                       video state on exit.  detect() is used by the PJ
                       configuration program but not PJ itself. 
   Parameters:         struct vdevice *vd       Device pointer.
   Return Value:       Errcode                  0 if hardware was detected,
                                                otherwise a negative Errcode
                                                (see errcodes.h).
   Implementation:     Highly recommended.  Your driver will require special
                       attention during configuration if this is not present.

   Errcode get_modes(struct vdevice *vd, USHORT mode, Vmode_info *pvm);
   Function:           Gets information about a graphics mode supported by the
                       driver.  The pvm parameter returns such information as
                       resolution, number of graphics pages, amount of
                       graphics memory, and the name of the mode.
   Parameters:         struct vdevice *vd       Device pointer.
                       USHORT mode              Index of mode.  Mode will be
                                                greater or equal to zero and
                                                less than vd->mode_count.
                       Vmode_info *pvm          Points to an info structure
                                                for driver to fill in.
   Return Value:       Errcode                  
   Implementation:     Required.

   Errcode char *mode_text(struct vdevice *vd, USHORT mode); 
   Function:           Gets extended text description of a graphics mode.
   Parameters:         struct vdevice *vd       Device pointer.
                       USHORT mode              Index of mode.  Mode will be
                                                greater than or equal to zero
                                                and less than vd->mode_count.
   Return Value:       char *                   ASCII string description of
                                                mode.  Should be 512 bytes or
                                                less.
   Implementation:     Optional.

   long max_height(struct vdevice *vd, USHORT mode, LONG width);
   Function:           If the mode supports variable resolution, this function
                       returns the maximum height that can be displayed for a
                       given width.

   Parameters:         struct vdevice *vd       Device pointer.
                       USHORT mode              Index of mode.
                       LONG width               A width that is within the
                                                range of widths permissible in
                                                this mode.               
   Return Value:       long                     Maximum height that can be
                                                displayed at width.
   Implementation:     Required if driver supports modes with variable
                       resolution (That is if the get_modes() call for this
                       mode says vmode_info->width.min != vmode_info-
                       >width.max or likewise for height).

   Errcode open_graphics(struct vdevice *vd, USHORT mode, Raster *r, 
        LONG width, LONG height);
   Function:           Puts display hardware into a graphics mode and
                       initializes raster associated with graphics screen.
   Parameters:         struct vdevice *vd       Device pointer.
                       USHORT mode              Index of mode.
                       Raster *r                Driver fills this in with
                                                raster associated with
                                                graphics screen. r->lib is
                                                where the drawing/animation
                                                routines for the display
                                                driver are located.
                       LONG width               Width of graphics screen.
                       LONG height              Height of graphics screen.
   Return Value:       Errcode                  Returns 0 if hardware is
                                                attatched and could get a
                                                graphics screen, otherwise an
                                                Errcode (see errcodes.h).
   Implementation:     Required.

   Errcode close_graphics(struct vdevice *vd);
   Function:           Undoes whatever open_graphics() did.  Typically returns
                       display to text mode.
   Parameters:         struct vdevice *vd       Device pointer.
   Return Value:       Errcode                  0 if no problem, else negative
                                                value (see errcodes.h).
   Implementation:     Required.

   Errcode open_cel(struct vdevice *vd, USHORT mode, 
        Raster *r, LONG width, LONG height, UBYTE displayable);
   Function:           Tries to get a secondary screen/cel from the display
                       driver.  This function is optional.  If present PJ 
                       will use it to store the undo buffer, swap screen, cel,
                       and other graphics buffers that would otherwise have to
                       be stored in 80386 memory or on the disk.  Currently PJ
                       will always pass in a 0 for the displayable parameter,
                       but future programs supporting double buffering
                       displays for smoother animation playback might pass in
                       a 1.
   Parameters:         struct vdevice *vd       Device pointer.
                       USHORT mode              Mode index.
                       Raster *r                Put resulting raster here.
                       LONG width               Width of requested cel.
                       LONG height              Height of requested cel.
                       UBYTE displayable        Do we need to be able to
                                                display this cel?
   Return Value:       Errcode                  0 on success, negative Errcode
                                                on failure.
   Implementation:     Optional.  Implementing this will give PJ more memory
                       to work with.  Also, if the card can move pixels
                       internally faster than pixels can be moved to and from
                       the card, this can speed up PJ significantly.

   Errcode show_rast(struct vdevice *vd, Raster *r);
   Function:           Displays raster (for devices that support more than one
                       display page).
   Parameters:         struct vdevice *vd       Device pointer.
                       Raster *r                Raster to show.
   Return Value:       Errcode                  0 on success.
   Implementation:     Optional.   Not used by this version of PJ, but may be
                       used extensively by future products.

   Errcode wait_vblank(struct vdevice *vd, Raster *r);
   Function:           Waits until the monitor is in vertical blank.  If
                       available PJ will call this to minimize tear during
                       animation replay.  This function is also used if
                       display hardware can only set color palette during
                       vertical blank (like VGA).
   Parameters:         struct vdevice *vd       Device pointer.
                       Raster *r                Display raster pointer.
   Return Value:       Errcode                  0 on success.
   Implementation:     Recommended.  Lets PJ syncronize its drawing with the
                       display to minimize visible screen tear during
                       animation playback.

  VII.  Raster Oriented Functions
        
   A raster is not much more than a rectangular array of pixels and a set of
   functions to access these pixels.   The raster structure is divided into
   two main parts: a part that contains data common to all rasters and  a part
   specific to a particular type of raster (ie local to the driver).   From
   display.h we have the declaration:
        typedef struct raster {
             SHORT type; /* each mode of the driver has a different type */
             SHORT pdepth;  /* Pixel depth.  8 in all cases for driver. */
             struct rastlib *lib;  /* drawing function library */
             SHORT aspect_dx, aspect_dy;   /* aspect ratio */
             SHORT reserved[2];       /* for the future... */
             USHORT width, height;    /* pixel width and height */
             SHORT x, y;         /* screen position.  Ignored by driver. */
             union raster_hw hw; /* hardware specific part.  16 bytes */
        } Raster;
   The most interesting part of the raster is the lib, which contains the
   following functions:

   void put_dot(Raster *r,Pixel color,Coor x,Coor y);
   Function:           Sets a single pixel guaranteed to be within the bounds
                       of the raster:
                       0 <= x < r->width and 0 <= y < r->height
   Parameters:         Raster *r           Raster pointer.
                       Pixel color         Color of the pixel.
                       Coor x              X position.
                       Coor y              Y position.
   Return Value:       void
   Implementation:     Required.  Extremely speed critical overall.

   void clip_put_dot(Raster *r,Pixel color,Coor x,Coor y);
   Function:           Sets a single pixel if it is within bounds of the
                       raster.  If the pixel is outside the bounds of the
                       raster be sure not to crash!  This function and
                       clip_get_dot are the only places where the driver might
                       be asked to draw offscreen.
   Parameters:         Raster *r           Raster pointer.
                       Pixel color         Color of the pixel.
                       Coor x              X position (from left to right).
                       Coor y              Y position (from top to bottom).
   Return Value:       Errcode
   Implementation:     Optional.  If the driver can handle point clipping
                       efficiently this will speed up spray and other
                       intensive point-at-a-time functions.

   Pixel get_dot(Raster *r,Coor x,Coor y);
   Function:           Returns the color of a pixel guaranteed to be within
                       bounds of the raster.
   Parameters:         Raster *r           Raster pointer.
                       Coor x              X position.
                       Coor y              Y position.
   Return Value:       Pixel               Color of the pixel.
   Implementation:     Required.  Extremely speed critical overall.

   Pixel clip_get_dot(Raster *r,Coor x,Coor y);
   Function:           Returns the color of a pixel that may not be inside of
                       screen.  If pixel is outside the raster returns 0.
   Parameters:         Raster *r           Raster pointer.
                       Coor x              X position of pixel.
                       Coor y              Y position of pixel.
   Return Value:       Pixel               Color of pixel.
   Implementation:     Optional.  If the driver can handle point clipping
                       efficiently this will speed up spray and other
                       intensive point-at-a-time functions.              

   void put_hseg(Raster *r,void *pixbuf,Ucoor x,Ucoor y,Ucoor w);
   Function:           Moves pixels in pixbuf to a horizontal line segment w
                       pixels wide on raster r starting at x,y.  
   Parameters:         Raster *r           Raster pointer.
                       void *pixbuf        Array of pixels in memory.
                       Ucoor x             X coordinate of left end of
                                           segment.
                       Ucoor y             Y coordinate of segment.
                       Ucoor w             Width of segment.
   Return Value:       void                     
   Implementation:     Most highly recommended.  This function is heavily used
                       and should be as fast as possible.

   void get_hseg(Raster *r,void *pixbuf,Ucoor x,Ucoor y,Ucoor w);
   Function:           Moves pixels in a horizontal line segment w pixels wide
                       on raster r starting a x,y to pixbuf.
   Parameters:         Raster *r           Raster pointer.
                       void *pixbuf        Memory buffer which will contain
                                           pixels.
                       Ucoor x             X coordinate of left end of
                                           segment.
                       Ucoor y             Y coordinate of segment.
                       Ucoor w             Width of segment.
   Return Value:       void                     
   Implementation:     Most highly recommended.  This function is heavily used
                       and should be as fast as possible.

   void put_vseg(Raster *r,void *pixbuf,Ucoor x,Ucoor y,Ucoor h);
   Function:           Moves pixels from pixbuf to a vertical line segment h
                       pixels high on raster r starting at x,y.
   Parameters:         Raster *r           Raster pointer.
                       void *pixbuf        Source pixel array in memory.
                       Ucoor x             X coordinate of segment.
                       Ucoor y             Y coordinate of top of segment.
                       Ucoor h             Height of segment.
   Return Value:       void                     
   Implementation:     Optional.  Not very speed critical currently.

   void get_vseg(Raster *r,void *pixbuf,Ucoor x,Ucoor y,Ucoor h);
   Function:           Moves pixels in vertical segment h pixels high on
                       raster r starting a x,y to pixbuf.
   Parameters:         Raster *r           Raster pointer.
                       void *pixbuf        Destination pixel array in memory.
                       Ucoor x             X coordinate of segment.
                       Ucoor y             Y coordinate of top of segment.
                       Ucoor h             Height of segment.
   Return Value:       void                     
   Implementation:     Recommended.  Cel clip and trace/clip changes will be
                       slow if this function is not supplied.

   void put_rectpix(Raster *r,void *pixbuf,Coor x,Coor y,Ucoor w,Ucoor h);
   Function:           Moves pixels from a memory buffer to a rectangle in
                       raster r.  The memory buffer should be a two-
                       dimensional array of pixels with the top horizontal
                       line of pixels first and the bottom horizontal line of
                       pixels last.
   Parameters:         Raster *r           Raster pointer.
                       void *pixbuf        Source pixels.
                       Coor x              Left edge of rectangle.
                       Coor y              Top edge of rectangle.
                       Ucoor w             Width of rectangle.
                       Ucoor h             Height.
   Return Value:       void                     
   Implementation:     Recommended.   This call is used heavily, but it
                       becomes less necessary to implement if put_hseg() is
                       fast enough.

   void get_rectpix(Raster *r,void *pixbuf,Coor x,Coor y,Ucoor w,Ucoor h);
   Function:           Moves pixels from a rectangle of a raster to a memory
                       buffer.  The memory buffer is organized as two-
                       dimensional array with the same format used by
                       put_rectpix.
   Parameters:         Raster *r           Raster pointer.
                       void *pixbuf        Destination memory buffer.
                       Coor x              Left edge of rectangle.
                       Coor y              Top edge.
                       Ucoor w             Width.
                       Ucoor h             Height.
   Return Value:       void                     
   Implementation:     Recommended.   This call is used heavily, but it
                       becomes less necessary to implement if get_hseg() is
                       fast enough.

   void set_hline(Raster *r,Pixel color,Coor x,Coor y,Ucoor w);
   Function:           Draws a solid horizontal line segment.
   Parameters:         Raster *r           Raster pointer.
                       Pixel color         Color of segment.
                       Coor x              Left end of segment.
                       Coor y              Y coordinate of segment.
                       Ucoor w             Width of segment.
   Return Value:       void                     
   Implementation:     Most highly recommended. This function is heavily used
                       and should be as fast as possible.

   void set_vline(Raster *r,Pixel color,Coor x,Coor y,Ucoor h);
   Function:           Draws a solid vertical line segment.
   Parameters:         Raster *r           Raster pointer.
                       Pixel color         Color of segment.
                       Coor x              X coordinate of segment.
                       Coor y              Top end of segment.
                       Ucoor h             Height.
   Return Value:       void                     
   Implementation:     Optional.  Menus and rubberband boxes will be faster if
                       this is present.

   void set_rect(Raster *r,Pixel color,Coor x,Coor y,Ucoor w,Ucoor h);
   Function:           Draws a solid color rectangle on raster r with the
                       upper left corner at x,y and the dimensions w by h.
   Parameters:         Raster *r           Raster pointer.
                       Pixel color         Color of rectangle.
                       Coor x              Left edge.
                       Coor y              Top edge.
                       Ucoor w             Width.
                       Ucoor h             Height.
   Return Value:       void                
   Implementation:     Recommended.   This call is used heavily, but it
                       becomes less necessary to implement if d_hline() is
                       fast enough.

   void set_rast(Raster *r,Pixel color);
   Function:           Sets an entire raster to a solid color.
   Parameters:         Raster *r           Raster pointer.
                       Pixel color         Color.
   Return Value:       void      
   Implementation:     Optional.  PJ will call set_rect() on the full raster
                       if this is not present.            

   void xor_rect(Raster *r,Pixel color,Coor x,Coor y,Ucoor w,Ucoor h);
   Function:           Exclusive ors a rectangle in a raster with a solid
                       color.   
   Parameters:         Raster *r           Raster pointer.
                       Pixel color         Color to xor rectangle with.
                       Coor x              Left edge.
                       Coor y              Top edge.
                       Ucoor w             Width.
                       Ucoor h             Height.
   Return Value:       void                
   Implementation:     Optional.  Used for text cursor and to display inverted
                       video on some menus.

   void icon_blit(UBYTE *mbytes, Coor mbpr, Coor mx, Coor my,
                     Raster *r, Coor rx, Coor ry, Ucoor width, Ucoor height,
                     Pixel oncolor );
   Function:           Expands a rectangle from a bitplane in memory to a
                       full-pixel image on raster.  0's in bitplane are left
                       unchanged on raster and 1's in bitplane are changed to
                       oncolor.
   Parameters:         UBYTE *bitplane          Pointer to a block of memory 
                                                arranged as a two-dimensional
                                                bitplane.  To toggle a bit in
                                                this bitplane use the
                                                following formula:
                                                     mbytes[y*mbpr+(x>>3)] ^=
                                                     0x80>>(x&7); 
                       Coor mbpr                The number of bytes between
                                                lines of the bitplane.
                       Coor mx                  mx,my are the coordinates of
                                                the upper-left corner of the
                                                area to expand in the
                                                bitplane.
                       Coor my                  
                       Raster *r                Destination raster pointer.
                       Coor rx                  rx,ry are the coordinates of
                                                the upper-left corner of the
                                                destination rectangle to be 
                                                expanded in raster r.
                       Coor ry        
                       Ucoor width              Width of rectangle to expand.
                       Ucoor height             Height of rectangle to expand.
                       Pixel oncolor            1's in source bitplane get
                                                mapped to oncolor in
                                                destination raster.
   Return Value:       void                     
   Implementation:     Highly recommended.  Used to display text and icons. 
                       Moderately speed critical.

   void text_blit(UBYTE *bitplane, Coor mbpr, Coor mx, Coor my,
                     Raster *r, Coor rx, Coor ry, Ucoor width, Ucoor height,
                     Pixel oncolor, Pixel offcolor );
   Function:           Moves a rectangle from a memory bitplane to a hardware
                       raster.  This function is similar to icon_blit.  0's in
                       the bitplane are mapped to offcolor in raster and 1's
                       are mapped to oncolor.
   Parameters:         UBYTE *bitplane          Pointer to a block of memory
                                                arranged as a two-dimensional
                                                bitplane.   To toggle a bit in
                                                this bytemap use the following
                                                formula:
                                                     mbytes[y*mbpr+(x>>3)] ^=
                                                     0x80>>(x&7); 
                       Coor mbpr                The number of bytes between
                                                lines of bitplane.
                       Coor mx                  mx,my are the coordinates of
                                                the upper-left corner of the
                                                area to expand into the
                                                bitplane.
                       Coor my                  
                       Raster *r                Destination raster pointer.
                       Coor rx                  rx,ry are the coordinates of
                                                the upper-left corner of the
                                                destination rectangle of
                                                expansion in raster r.
                       Coor ry        
                       Ucoor width              Width of rectangle to expand.
                       Ucoor height             Height of rectangle to expand.
                       Pixel oncolor            1's in source bitplane get
                                                mapped to oncolor in
                                                destination raster.
                       Pixel offcolor           0's in source bitplane get
                                                mapped to offcolor in
                                                destination raster.
   Return Value:       void                     
   Implementation:     Recommended.  Used to display text when rubberbanding
                       objects.

   void blit_in_card(Raster *source, Coor src_x, Coor src_y,
                   Raster *dest, Coor dest_x, Coor dest_y,
                   Coor width, Coor height);
   Function:           Moves a rectangular area from source to dest where
                       source and dest are both the same type of raster
                       managed by this driver.
   Parameters:         Raster *source      Source raster.
                       Coor src_x          Left edge of rectangle to move in
                                           source.
                       Coor src_y          Top edge in source.
                       Raster *dest        Destination raster.
                       Coor dest_x         Left edge of rectangle in
                                           destination.
                       Coor dest_y         Top edge in destination.
                       Coor width          Width of rectangle to move.
                       Coor height         Height.
   Return Value:       void                     
   Implementation:     Highly recommended if card allows secondary rasters.  
                       Among other things it will be used to save the undo
                       buffer while the artist is drawing.  It is also
                       recommended if the card has only the primary graphics
                       raster since it will be used by the move tool.

   void blit_to_ram(Raster *source, Coor src_x, Coor src_y,
                   RamRast *dest, Coor dest_x, Coor dest_y,
                   Coor width, Coor height);
   Function:           Moves a rectangular area from source to dest where
                       source raster is the type managed by driver and
                       destination raster is in RAM.
   Parameters:         Raster *source      Source raster.
                       Coor src_x          Left edge of rectangle to move in
                                           source.
                       Coor src_y          Top edge in source.
                       RamRast *dest       Destination raster.
                       Coor dest_x         Left edge of rectangle in
                                           destination.
                       Coor dest_y         Top edge in destination.
                       Coor width          Width of rectangle to move.
                       Coor height         Height.
   Return Value:       void                     
   Implementation:     Highly recommended.  This function is heavily used even
                       if the card allows secondary graphics rasters.

   void blit_from_ram(RamRast *source, Coor src_x, Coor src_y,
                   Raster *dest, Coor dest_x, Coor dest_y,
                   Coor width, Coor height);
   Function:           Moves a rectangular area from source to dest where
                       source raster is in RAM and destination raster is the
                       type managed by driver.
   Parameters:         Raster *source      Source raster.
                       Coor src_x          Left edge of rectangle to move in
                                           source.
                       Coor src_y          Top edge in source.
                       RamRast *dest       Destination raster.
                       Coor dest_x         Left edge of rectangle in
                                           destination.
                       Coor dest_y         Top edge in destination.
                       Coor width          Width of rectangle to move.
                       Coor height         Height.
   Return Value:       void                     
   Implementation:     Highly recommended.  This function is heavily used even
                       if the card allows secondary graphics rasters.

   void swap_in_card(Raster *ra, Coor ax, Coor ay,
                    Raster *rb, Coor bx, Coor by, Coor width, Coor height);
   Function:           Exchanges a rectangular area between two rasters of the
                       type handled by card.  ra and rb may point to the same
                       raster, but this function need not handle the case
                       where the rectangles defined by ax,ay,width,height and
                       bx,by,width,height overlap.
   Parameters:         Raster *ra          Raster pointer to raster type
                                           handled by driver.
                       Coor ax             Left edge of rectangle in raster
                                           ra.
                       Coor ay             Top edge of rectangle in raster ra.
                       Raster *rb          Raster pointer to raster type
                                           handled by driver.
                       Coor bx             Left edge of rectangle in raster
                                           rb.
                       Coor by             Top edge of rectangle in raster rb.
                       Coor width          Width of rectangle to swap.
                       Coor height         Height of rectangle to swap.
   Return Value:       void                     
   Implementation:     Optional.   If the driver supports secondary buffers
                       this function might be used to swap buffers when the PJ
                       user selects undo.  Potentially used when menus are
                       moved.

   void swap_to_ram(Raster *ra, Coor ax, Coor ay,
                    RamRast *rb, Coor bx, Coor by, Coor width, Coor height);
   Function:           Exchanges a rectangular area between two rasters.  The
                       first raster is the type handled by the driver and the
                       second is a RAM-based raster.  
   Parameters:         Raster *ra          Raster pointer to raster type
                                           handled by driver.
                       Coor ax             Left edge of rectangle in raster
                                           ra.
                       Coor ay             Top edge of rectangle in raster ra.
                       RamRast *rb         Raster pointer to RAM based raster.
                       Coor bx             Left edge of rectangle in raster
                                           rb.
                       Coor by             Top edge of rectangle in raster rb.
                       Coor width          Width of rectangle to swap.
                       Coor height         Height of rectangle to swap.
   Return Value:       void                     
   Implementation:     Optional.  This function might be used to swap buffers
                       when the PJ user selects undo.  Potentially used when
                       menus are moved.

   void swap_from_ram(RamRast *ra, Coor ax, Coor ay,
                    Raster *rb, Coor bx, Coor by, Coor width, Coor height);
   Function:           Exchanges a rectangular area between two rasters.  The
                       first raster is RAM based and the second is the type
                       handled by the driver.  
   Parameters:         RamRast *ra         Raster pointer to RAM based raster. 
                                           (See raster.h and bytemap.i)
                       Coor ax             Left edge of rectangle in raster
                                           ra.
                       Coor ay             Top edge of rectangle in raster ra.
                       Raster *rb          Raster pointer type of raster
                                           handled by card.
                       Coor bx             Left edge of rectangle in raster
                                           rb.
                       Coor by             Top edge of rectangle in raster rb.
                       Coor width          Width of rectangle to swap.
                       Coor height         Height of rectangle to swap.
   Return Value:       void                     
   Implementation:     Optional.  This function might be used to swap buffers
                       when the PJ user selects undo.  It is also potentially
                       used when menus are moved.  It is currently not very
                       speed critical.

   void tblit_in_card(Raster *source, Coor src_x, Coor src_y,
                   Raster *dest, Coor dest_x, Coor dest_y,
                   Coor width, Coor height, Pixel tcolor);
   Function:           Transparently moves a rectangular area from source to
                       dest.  Colors in source that are the same as tcolor are
                       not copied.  Source and dest are both the same type of
                       raster managed by this driver.
   Parameters:         Raster *source      Source raster.
                       Coor src_x          Left edge of rectangle to move in
                                           source.
                       Coor src_y          Top edge in source.
                       Raster *dest        Destination raster.
                       Coor dest_x         Left edge of rectangle in
                                           destination.
                       Coor dest_y         Top edge in destination.
                       Coor width          Width of rectangle to move.
                       Coor height         Height.
                       Pixel tcolor        Transparent color of source.
   Return Value:       void                     
   Implementation:     Highly recommended.  If the card allows multiple
                       secondary buffers to reside on it this function will be
                       called when moving and pasting the cel or swap screen
                       in PJ.  If the card doesn't allow secondary buffers it
                       is still potentially used in compositing operations.

   void tblit_to_ram(Raster *source, Coor src_x, Coor src_y,
                   RamRast *dest, Coor dest_x, Coor dest_y,
                   Coor width, Coor height, Pixel tcolor);
   Function:           Transparently moves a rectangular area from source to
                       dest.  Colors in source that are the same as tcolor are
                       not copied.  The source raster is the type managed by
                       the driver and the destination raster is in RAM.
   Parameters:         Raster *source      Source raster.
                       Coor src_x          Left edge of rectangle to move in
                                           source.
                       Coor src_y          Top edge in source.
                       RamRast *dest       Destination raster.
                       Coor dest_x         Left edge of rectangle in
                                           destination.
                       Coor dest_y         Top edge in destination.
                       Coor width          Width of rectangle to move.
                       Coor height         Height.
                       Pixel tcolor        Transparent color of source.
   Return Value:       void                     
   Implementation:     Recommended.  This function is potentially used during
                       composite operations.

   void tblit_from_ram(RamRast *source, Coor src_x, Coor src_y,
                   Raster *dest, Coor dest_x, Coor dest_y,
                   Coor width, Coor height, Pixel tcolor);
   Function:           Transparently moves a rectangular area from source to
                       dest.  Colors in source that are the same as tcolor are
                       not copied.  The source raster is in RAM and the
                       destination raster is the type managed by driver. 
   Parameters:         Raster *source      Source raster.
                       Coor src_x          Left edge of rectangle to move in
                                           source.
                       Coor src_y          Top edge in source.
                       RamRast *dest       Destination raster.
                       Coor dest_x         Left edge of rectangle in
                                           destination.
                       Coor dest_y         Top edge in destination.
                       Coor width          Width of rectangle to move.
                       Coor height         Height.
                       Pixel tcolor        Transparent color of source.
   Return Value:       void                     
   Implementation:     Most highly recommended.  Heavily used even if card
                       allows secondary rasters.  This function has a direct
                       effect on the overall drawing speed of PJ.  It is also
                       used in compositing and cel operations.

   void xor_in_card(Raster *s, Raster *d);
   Function:           Exclusive or's raster s with raster d, putting result
                       into raster d.  s and d are guaranteed to be the same
                       dimensions.  s and d are both the type of raster
                       handled by the driver.
   Parameters:         Raster *s           Source raster pointer.   
                       Raster *d           Destination raster pointer.
   Return Value:       void                     
   Implementation:     Recommended if card supports secondary rasters.  The
                       speed of this function will impact "Next blue" and
                       "Clip changes" under the "Trace" menu in PJ and not
                       much else.

   void xor_to_ram(Raster *s, RamRast *d);
   Function:           Same as xor_in_card except destination is a RAM raster.
   Parameters:         Raster *s           Source raster pointer.   
                       RamRast *d          Destination raster pointer.
   Return Value:       void                     
   Implementation:     Recommended.  See xor_in_card().

   void xor_from_ram(RamRast *s, Raster *d);
   Function:           Same as xor_in_card except source is a RAM raster.
   Parameters:         RamRast *s          Source raster pointer.   
                       Raster *d           Destination raster pointer.
   Return Value:       void                     
   Implementation:     Recommended.  See xor_in_card().

   void zoom_in_card(Raster *source, Coor src_x, Coor src_y,
                   Raster *dest, Coor dest_x, Coor dest_y,
                   Ucoor width, Ucoor height, LONG zoom_x, LONG zoom_y );
   Function:           Takes a rectangular area of source and moves it to the
                       destination, expanding each pixel into a box that is
                       zoom_x by zoom_y.  Width and height are given in
                       destination coordinates.  It is possible that width
                       will not be an exact multiple of zoom_x and likewise
                       height not an integral multiple of zoom_y.  In this
                       case the expanded pixels on the right and bottom edges
                       must be clipped by the driver.  For example, a call to
                       zoom_in_card(s,0,0,d,0,0,5,5,2,2) using the following
                       image in s:
                                 -*-
                                 ***
                                 -*-
                       would produce this image in d:
                                 --**-
                                 --**-
                                 *****
                                 *****
                                 --**-
   Parameters:         Raster *source           Source raster.  
                       Coor src_x               Left edge of source.
                       Coor src_y               Upper edge of source.
                       Raster *dest             Destination raster.
                       Coor dest_x              Left edge of destination.
                       Coor dest_y              Upper edge of destination.
                       Ucoor width              Width of destination. ...
                                                Width of source is:
                                                      (width+zoom_x-1)/zoom_x
                       Ucoor height             Height of destination.
                       LONG zoom_x              Amount to stretch each pixel
                                                in horizonal direction.
                       LONG zoom_y              Amount to stretch each pixel
                                                in vertical direction.
   Return Value:       void                     
   Implementation:     Recommended.  This function will affect the speed of
                       painting and playback in zoom mode, especially when the
                       card supports multiple secondary rasters.         

   void zoom_to_ram(Raster *source, Coor src_x, Coor src_y,
                   RamRast *dest, Coor dest_x, Coor dest_y,
                   Ucoor width, Ucoor height, LONG zoom_x, LONG zoom_y );
   Function:           Same as zoom_in_card except destination is a RAM raster
                       image.  
   Parameters:         See zoom_in_card().
   Implementation:     Optional.  This function is potentially used when zoom
                       and many other windows are up.  Only mildly speed
                       critical.

   void zoom_from_ram(RamRast *source, Coor src_x, Coor src_y,
                   Raster *dest, Coor dest_x, Coor dest_y,
                   Ucoor width, Ucoor height, LONG zoom_x, LONG zoom_y );
   Function:           Same as zoom_in_card except source is a RAM raster.
   Parameters:         See zoom_in_card().
   Implementation:     Recommended.  This function will affect the speed of
                       painting and playback in zoom mode.  In most
                       situations, especially when the driver doesn't provide
                       multiple secondary rasters, this is the most important
                       of the zoom blits.  Extremely speed critical in zoom.

   void unbrun_rect(Raster *r,void *ucbuf, LONG pixsize,
                        Coor x,Coor y,Ucoor width,Ucoor height);
   Function:           Un-run-length-compresses memory onto rectangle in a 
                       raster. 
   Parameters:         Raster *r           Raster pointer.
                       void *ucbuf         Compressed image data.  See ucbuf
                                           format below for details.
                       LONG pixsize        Size in bytes of a single pixel. 
                                           Always 1 in this version of the
                                           software.
                       Coor x              Left edge of decompression
                                           destination.
                       Coor y              Top edge.
                       Ucoor width         Width of decompression destination.
                       Ucoor height        Height.
   Return Value:       void                     
   Ucbuf format:       This contains byte-run-length compressed data.  Each
                       line is compressed separately.  The first byte in a
                       (compressed) line is the number of compression packets
                       in this line.  This is a hold-over from the low res
                       Animator and should be ignored.  (In higher resolutions
                       it's possible to have more than 256 packets in a line.) 
                       Next there are the packets.  
                            The first byte of a packet is a type/count byte. 
                       If this byte is positive the packet is a compressed
                       run.  The positive first packet byte says how many
                       pixels are in this run.  The following byte is the
                       pixel to color the run.
                            If the first byte of a packet is negative then it
                       is an uncompressed packet.  The negative of this byte
                       is the number of bytes that follow that should be
                       literally copied to the destination. 
                            unbrun_rect should continue processing packets
                       until it detects that it has uncompressed width pixels. 
                       Then it is time to uncompress the next line until it
                       has done height lines. 
                            A C implementation of this uncompression algorithm 
                       is located in the function grc_unbrun_rect() in the
                       file grclib.c.
   Implementation:     Highly recommended.  Used to display first frame of a
                       .FLI file.

   void unlccomp_rect(Raster *r,void *ucbuf, LONG pixsize,
                        Coor x,Coor y,Ucoor width,Ucoor height);
   Function:           Animator 1.0-style delta decompression routine.
   Parameters:         Raster *r           Raster pointer.
                       void *ucbuf         Compressed delta image.  See .FLI
                                           file formats for complete
                                           description.
                       LONG pixsize        Size in bytes of a pixel.  Always 1
                                           for now.
                       Coor x              Left edge of area to decompress
                                           into.
                       Coor y              Top edge.
                       Ucoor width         Width of area to decompress into.
                       Ucoor height        Height.
   Return Value:       void                     
   Ucbuf format:            The first word (16 bits) is the number of lines
                       starting from the top of the screen that are the same
                       as the previous frame. (For example, if there is motion
                       only on the bottom line of 320x200 screen you'd have a
                       199 here.)  The next word is the number of lines that
                       do change.  Next there is the data for the changing
                       lines themselves.  Each line is compressed
                       individually; among other things this makes it much
                       easier to play back the FLI at a reduced size.
                            The first byte of a compressed line is the number
                       of packets in this line.  If the line is unchanged from
                       the last frame this is zero.  The format of an
                       individual packet is:
                            skip_count
                            size_count
                            data
                       The skip count is a single byte.  If more than 255
                       pixels are to be skipped it must be broken into 2
                       packets. The size count is also a byte.  If it is
                       positive, that many bytes of data follow and are to be
                       copied to the screen.  If it's negative a single byte
                       follows, and is repeated -skip_count times.
                            A C implementation of this uncompression algorithm 
                       is located in the function grc_unlccomp_rect() in the
                       file grclib.c.                          
   Implementation:     Recommended.  This is used to display most frames of a
                       Autodesk Animator 1.0-style .FLI file.   It is only
                       speed critical if you need to play back old animations
                       quickly.

   void unss2_rect(Raster *r,void *ucbuf, LONG pixsize,
                          Coor x,Coor y,Ucoor width,Ucoor height);
   Function:           PJ (modern) style delta decompression.  Main
                       decompression routine for PJ's FLI's.
   Parameters:         Raster *r           Raster pointer.
                       void *ucbuf         Compressed delta image.  See .FLI
                                           file formats for complete
                                           description.
                       LONG pixsize        Size in bytes of a pixel.  Always 1
                                           for now.
                       Coor x              Left edge of decompression
                                           destination.
                       Coor y              Top edge.
                       Ucoor width         Width of decompression destination.
                       Ucoor height        Height.
   Return Value:       void                     
   Ucbuf format:       The first word (16 bits) is the line_counter.  Next are
                       the line deltas with the format:
                            op_word  [pixel deltas if any]
                       An op_word is one of three types:
                            * -  If the op_word is negative (hi bit set) the
                                 second highest bit is tested.  If it is also
                                 set (and consequently op_word is a smallish
                                 negative number) -op_word is taken to mean
                                 the number of lines to skip to get to the
                                 next line with delta information. 
                                 line_counter is not decremented after this
                                 op.
                            * -  If the high bit of op_word is set, but the
                                 next bit is clear then the low byte of
                                 op_word contains the last byte of the line. 
                                 (This only occurs if width is odd.) 
                                 line_counter is decremented by one, and if
                                 down to zero we're done with the line delta.
                            * -  If op_word is positive it is followed by
                                 op_word pixel deltas.  Each of these is of
                                 the form:  
                                      skip_byte  op_byte  data_byte(s)
                                 Each pixel delta is decoded like this:
                                      The uncompressor adds skip_byte to it's
                                      current screen position and then tests
                                      the sign of op_byte.  If op_byte is
                                      positive then it is a count of 16-bit
                                      words to move from the compression
                                      stream to the screen.  If it's negative
                                      the next word contains a value to repeat
                                      -op_byte times.  
                                 Finally line_counter is decremented by one,
                                 and if it's down to zero we're done with the
                                 line delta.
                            A C implementation of this uncompression algorithm 
                       is located in the function grc_unss2_rect() in the file
                       grclib.c.                          
   Implementation:     Most highly recommended.  Directly affects animation
                       playback speed.


   void uncc256(Raster *r, void *ucbuf);
   Function:           PJ-style routine to decompress a delta color map.   
                       This routine should not affect the visible color map
                       unless r points to the currently-displayed raster.
   Parameters:         Raster *r           Raster pointer.
                       void *ucbuf         Compressed color data.  See ucbuf
                                           format below for details.
   Return Value:       void                     
   Ucbuf format:       The first word (16 bit) is the number of packets in the
                       cbuf. This is followed directly by the packets.  The
                       first byte of a packet says how many colors to skip. 
                       The next byte says how many colors to change.  If this
                       byte is zero it is interpreted to mean 256.  Next
                       follows 3 bytes for each color to change (one each for
                       red, green and blue).  The red/green/blue bytes are
                       values between 0 and 255.
   Implementation:     Recommended.  Directly effects animation playback
                       speed.  Moderately speed critical for playing back
                       animations.

   void uncc64(Raster *r, void *ucbuf);
   Function:           Old-style routine to decompress a delta color map.  
   Parameters:         Raster *r           Raster pointer.
                       void *ucbuf         Compressed color data.  Same as
                                           ucbuf in uncc256, but the rgb data
                                           ranges from 0-63 (like the VGA
                                           color palette) rather than 0-256.)
   Return Value:       void                     
   Implementation:     Optional.  Used to display most frames of a Autodesk
                       Animator 1.0-style .FLI file.  Only speed critical if
                       you need to play back old animations quickly.

   void set_colors(Raster *r, LONG start, LONG count, void *cbuf);
   Function:           Seta a portion of the color map to the rgb values
                       contained in cbuf.
   Parameters:         Raster *r           Raster pointer.
                       LONG start          Start index in color map between 0
                                           and 255.
                       LONG count          Number of colors to set between 0
                                           and 256.
                       void *cbuf          Pointer to rgb data.  For each
                                           color to be changed there are 3
                                           bytes - one each for red, green and
                                           blue.  The values of these color
                                           components range from 0 to 255.
   Return Value:       void                     
   Implementation:     Required.  Moderately speed critical.

   Errcode close_raster(Raster *r);
   Function:           Closes down a raster opened with open_graphics or
                       open_cel.  If your driver allocates memory or other
                       resources while making a Raster it should free it up
                       here.  See also close_graphics at the device level.
   Parameters:         Raster *r                Raster pointer.
   Return Value:       Errcode                  0 on success.
   Implementation:     Optional.

   
  VI.  Functions provided by PJ for the driver
   
   The driver provides the device and raster libraries to PJ.  In turn PJ
   provides two libraries to the driver, syslib and grclib.   These are
   contained in the vdevice structure filled in by PJ before it calls the
   driver entry point.  Grclib is a pointer to the generic raster library -
   that is the calls which will be used for raster functions not directly
   implemented by the driver.   It is provided here in case your driver can
   implement a raster library function in some but not all circumstances.  In
   this case the driver's function can jump to a generic when it has
   determined it can't handle the function.  Syslib points to a jumptable of
   standard functions concerned with file i/o,  memory allocation and the
   like.  Since the driver can't access the standard C library this pointer
   allows the driver to access the most commonly used functions, albeit
   indirectly.   Here is the syslib structure from display.h:
        typedef struct syslib
             {
             /* memory management */
             void *(*malloc)(unsigned size);    /* uninitialized memory */
             void *(*zalloc)(unsigned size);    /* zero cleared memory */
             void (*free)(void *pt);       /* release memory from above 4 */
             /* dos-file-io (unbuffered) */
             Errcode (*dos_err)(void);     /* get dos file error code */
             Dfile (*dos_open)(char *filename, int mode);
             Dfile (*dos_create)(char *filename, int mode);
             void (*dos_close)(Dfile f);
             long (*dos_read)(Dfile f, void *buf, long size);
             long (*dos_write)(Dfile f, void *buf, long size);
             long (*dos_seek)(Dfile f, long offset, int mode);
             long (*dos_tell)(Dfile f);
             Errcode (*dos_delete)(char *filename);
             Errcode (*dos_rename)(char *oldname, char *newname);
             Errcode (*dos_copyfile)(char*source,char*dest, char **errfile);
             Boolean (*dos_exists)(char *filename);
             /* directory navigation */
             Errcode (*dos_set_dir)(char *dirname);
             Errcode (*dos_get_dir)(char *dirname);
             void (*get_home_dir)(char *dirname);
             void (*get_resource_dir)(char *dirname);
             /* directory searching */
             void (*dos_set_dta)(struct fndata *fn);
             Boolean (*dos_first)(char *pattern, int attributes);
             Boolean (*dos_next)(void);
             /* Might as well let drivers load drivers... */
             Errcode (*load_rex)(char *fname, void **entry);
             void (*free_rex)(void **entry);
             /*  standard C FILE i/o */
             FILE (*fopen)(char *name, char *mode);
             void (*fclose)(FILE *f);
             int (*fread)(void *buf, int size, int count, FILE *f);
             int (*fwrite)(void *buf, int size, int count, FILE *f);
             int (*fprintf)(FILE *f, char *format, ...);
             int (*fseek)(FILE *f, long offset, int mode);
             long (*ftell)(FILE *f);
             int (*fflush)(FILE *f);
             int (*getc)(FILE *f);
             int (*fgetc)(FILE *f);
             int (*putc)(int c, FILE *f);
             int (*fputc)(int c, FILE *f);
             char *(*fgets)(char *s, int maxlen, FILE *f);
             int (*fputs)(char *s, FILE *f);
             /* get message associated with error code */
             int (*get_errtext)(Errcode err, char *buf);
             int (*sprintf)(char *format, ...);
             /* printf should only be used during debugging */
             int (*printf)(char *format, ...);
             } Syslib;

   Here is a more detailed description of the functions in the syslib:

   void *malloc(unsigned size);
   Function:           Return a block of memory from the system heap.  Returns
                       NULL if there is not a block big enough.  Same as
                       standard C malloc.
   Parameters:         unsigned size       size of block of memory.
   Return Value:       void *              Pointer to memory block or NULL if
                                           not enough memory.

   void *zalloc(unsigned size);
   Function:           Return a block of memory cleared to all zero from the
                       system heap.  
   Parameters:         unsigned size       size of block of memory.
   Return Value:       void *              Pointer to memory block or NULL if
                                           not enough memory.

   void free(void *pt);
   Function:           Free a block of memory allocated with malloc, zalloc, A
                       standard C library function.
   Parameters:         void *pt            pointer to memory block to free.
   Return Value:       void

   Errcode dos_err(void);
   Function:           Returns error code (see errcodes.h) that describes the
                       last error.   Useful in functions that indicate failure
                       by returning a NULL or a short count of bytes read. 
   Parameters:         none
   Return Value:       Errcode             last dos Errcode.

   Dfile dos_open(char *filename, int mode);
   Function:           Open a file for unbuffered reading/writing.  Returns a
                       Dfile handle (which is a pointer type) if open
                       succeeds, and NULL if it fails.
   Parameters:         char *filename      Name of file to open.
                       int mode            Determines whether file is opened
                                           to read, to write, or both. 
                                           Acceptable values are:
                                                0  (DREADONLY)
                                                1  (DWRITEONLY)
                                                2  (DREADWRITE)
   Return Value:       Dfile               File handle or NULL.

   Dfile dos_create(char *filename, int mode);
   Function:           Create a new file for unbuffered reading/writing. 
                       Currently in spite of the mode parameter file is always
                       readable and writable.
   Parameters:         char *filename      Name of file to create.
                       int mode            Determines whether file is created
                                           to read, to write, or both. 
                                           Acceptable values are:
                                                0  (DREADONLY)
                                                1  (DWRITEONLY)
                                                2  (DREADWRITE)
   Return Value:       Dfile               File handle or NULL.

   void dos_close(Dfile f);
   Function:           Close a file.
   Parameters:         Dfile f             file handle returned from dos_open
                                           or dos_create.
   Return Value:       void

   long dos_read(Dfile f, void *buf, long size);
   Function:           Read bytes from file into a memory buffer.
   Parameters:         Dfile f             File handle returned from dos_open
                                           or dos_create.
                       void *buf           Memory buffer.  Destination of
                                           read.
                       long size           Number of bytes to read.
   Return Value:       long                Number of bytes actually read in. 
                                           Possibly less than size parameter
                                           if have gone past the end of file
                                           or an error has occured.

   long dos_write(Dfile f, void *buf, long size);
   Function:           Write bytes from a memory buffer into a file.
   Parameters:         Dfile f             File handle returned from dos_open
                                           or dos_create.
                       void *buf           Memory buffer.  Source of write.
                       long size           Number of bytes to write.
   Return Value:       long                Number of bytes actually written
                                           out.  Possibly less than size
                                           parameter if an error has occured.

   long dos_seek(Dfile f, long offset, int mode);
   Function:           Reset file position.
   Parameters:         Dfile f             File handle returned from dos_open
                                           or dos_create.
                       long offset         New file position.  Exact meaning
                                           depends on mode parameter.
                       int mode            Can be one of three values:
                                           0 (DSEEK_START)
                                                offset is distance of file
                                                position from the start of the
                                                file.
                                           1 (DSEEK_REL)
                                                offset is amount to move from
                                                current file position.
                                           2 (DSEEK_END)
                                                offset is distance of file
                                                position from the end of the
                                                file.
   Return Value:       long                File position after seek in bytes
                                           from the beginning of the file. 
                                           Negative Errcode value if an error
                                           occurs.

   long dos_tell(Dfile f);
   Function:           returns current file position in bytes from start of
                       file.
   Parameters:         Dfile f             File handle returned from dos_open
                                           or dos_create.
   Return Value:       long                File position.

   Errcode dos_delete(char *filename);
   Function:           delete a file.
   Parameters:         char *filename      Name of file.  May include path and
                                           directory information.
   Return Value:       Errcode             0 (Success) if file deleted,
                                           otherwise an Errcode that describes
                                           the problem.

   Errcode dos_rename(char *oldname, char *newname);
   Function:           rename a file
   Parameters:         char *oldname       Current file name
                       char *newname       Name to change file to.
   Return Value:       Errcode             0 (Success) if file renamed,
                                           otherwise an Errcode that describes
                                           the problem.

   Errcode dos_copyfile(char*source,char*dest, char **errfile);
   Function:           Create a new file that is an exact copy of an old file.
   Parameters:         char *source        Name of the original file.
                       char *dest          Name of the copy.
                       char **errfile      If there is an error then this will
                                           point to the file where the error
                                           occurred, that is either source or
                                           dest.
   Return Value:       Errcode             0 (Success) if file copied,
                                           otherwise an Errcode that describes
                                           the problem.

   Boolean dos_exists(char *filename);
   Function:           Determine whether a file exists.
   Parameters:         char *filename      Name of file that might exist.
   Return Value:       Boolean             1 (TRUE) if file exists,  0 (FALSE)
                                           if it does not exist.

   Errcode (*dos_set_dir)(char *dirname);
   Function:           Set the current device and directory.
   Parameters:         char *dirname       New device and directory.  Upper
                                           and lower case letters are treated
                                           the same.  Some examples:
                                                C:\BIN
                                           to change the bin directory of
                                           drive C:
                                                D:
                                           change to the current directory of
                                           drive D:
                                                jimstuff\flics
                                           change to a directory named flics
                                           inside of a directory named
                                           jimstuff inside of the current
                                           directory.
                                                ..
                                           change to the parent of current
                                           directory.
   Return Value:       Errcode             0 (Success) if could change to the
                                           new directory.  Otherwise a
                                           negative Errcode (see errcodes.h).

   Errcode (*dos_get_dir)(char *dirname);
   Function:           Find the current directory and drive.
   Parameters:         char *dirname       This must point to an buffer at
                                           least 67 bytes long.  Used to
                                           return the current directory.  The
                                           result will be in the format
                                           device:\dir\  (for example
                                           c:\jimstuff\bigpics\)
   Return Value:       Errcode             This will return 0 (Success) unless
                                           there is no valid current
                                           directory, in which case it will be
                                           negative.

   void (*get_home_dir)(char *dirname);
   Function:           Find the startup directory of PJ or other program using
                       the driver.  The is the preferred place to store
                       configuration files.
   Parameters:         char *dirname       This must point to an buffer at
                                           least 67 bytes long.
   Return Value:       void

   void (*get_resource_dir)(char *dirname);
   Function:           Find the resource directory of PJ or other program
                       using the driver.  This is where read-only files
                       associated with the driver should be located.
   Parameters:         char *dirname       This must point to an buffer at
                                           least 67 bytes long.
   Return Value:       void

   void dos_set_dta(struct fndata *fn);
   Function:           Set the MS-DOS Data Transfer Area.  This function is
                       used with dos_first and dos_next to scan a directory. 
                       A typical calling sequence would be:
                            dos_set_dta(&dta);
                            if (dos_first(name, 0))
                                 do {
                                      some_processing(dta.name);
                                 } while (dos_next())
   Parameters:         struct fndata *fn   pointer to a 128 byte structure
                                           containing the file name, size,
                                           date, and attributes.  See
                                           display.h.
   Return Value:       void

   Boolean dos_first(char *pattern, int attributes);
   Function:           Find first file in current directory that matches a
                       wildcard pattern and has the specified attributes.
   Parameters:         char *pattern       DOS wildcard.  
                       int attributes      DOS file attributes.  This should
                                           be zero for 'normal' files, and 16
                                           for directories.  There are other
                                           attributes values for hidden and
                                           read only files.  See any reference
                                           book on programming under MS-DOS
                                           for more information.
   Return Value:       Boolean             1 (TRUE) if there is a match, 0
                                           (FALSE) otherwise.

   Boolean dos_next(void);
   Function:           Find subsequent files matching wildcard pattern
                       specified by dos_first.
   Parameters:         
   Return Value:       Boolean             1 (TRUE) if there are subsequent
                                           pattern matches.  0 (FALSE) if have
                                           gone through all matches already.

   Errcode load_rex(char *fname, void **entry);
   Function:           Load up a Phar Lap relocatable executable file and
                       return the entry point.   A typical calling sequence
                       would be:
                            if (load_rex("mycode.rex", &entry) >= Success)
                                 {
                                 (*(void (*)())entry)();
                                 free_rex(&entry);
                                 }
                       Custom inks, display drivers, and picture loaders are
                       all REX files.  You may pass whatever parameters you
                       like to entry.
   Parameters:         char *fname         Name of REX file.
                       void **entry        Pointer to a void pointer where the
                                           starting address will be stored.
   Return Value:       Errcode             0 (Success) if REX file loaded ok,
                                           otherwise an Errcode that describes
                                           the problem.


   void free_rex(void **entry);
   Function:           Free up memory etc. used by load_rex.  Needless to say
                       you should not try to call entry after this function!
   Parameters:         void **entry        Same as what you passed to
                                           load_rex.
   Return Value:       void

   FILE fopen(char *name, char *mode);
   Function:           ANSI standard C function.  See your compiler manual.

   void fclose(FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int fread(void *buf, int size, int count, FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int fwrite(void *buf, int size, int count, FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int fprintf(FILE *f, char *format, ...);
   Function:           ANSI standard C function.  See your compiler manual.

   int fseek(FILE *f, long offset, int mode);
   Function:           ANSI standard C function.  See your compiler manual.

   long ftell(FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int fflush(FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int getc(FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int fgetc(FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int putc(int c, FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int fputc(int c, FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   char *fgets(char *s, int maxlen, FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int fputs(char *s, FILE *f);
   Function:           ANSI standard C function.  See your compiler manual.

   int get_errtext(Errcode err, char *buf);
   Function:           Get a text description of an error code.
   Parameters:         Errcode err         Error code to get message about.
                       char *buf           Place to put error message.  Must
                                           be at least 128 bytes long.
   Return Value:       int                 length of error message.

   int sprintf(char *format, ...);
   Function:           ANSI standard C function.  See your compiler manual.

   void printf(char *format, ...);
   Function:           ANSI standard C function.  Since much of the time the
                       driver will be operating when PJ is in graphics mode, 
                       this function can overwrite the user's picture.  Even
                       so when PJ or the driver testers are run with output
                       redirected to a file or the serial port, this can be
                       useful for debugging.   Should not be used in debugged
                       code!

