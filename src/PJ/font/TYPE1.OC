/*

		Read and decrypt an Adobe Type 1 font.
		This code was written originally by John Walker
		using the _Adobe Type 1 Font Format 1.1_ published
		by Addison-Wesley ISBN 0-201-57044-0 as a guide.

		Jim Kent changed it a fair amount,  reformatting the
		indentation and renaming some of the identifiers to
		mix with the local style;  making the output go through
		functions embedded in a structure so the same interpreter 
		could be used for both sizing and drawing the font,  and
		putting in stuff to glue it into Animator Pro's font
		manager.  Also changed from line oriented parsing to token
		oriented parsing to accomodate some PD .PFB files.

		There are four main sections to this file set apart with
		long comment blocks.  One reads the font into memory.
		The second interprets the font language.  The third is concerned
		with directing the output of the interpreter into a form
		useful for PJ.  The final bit is the glue into the PJ
		virtual font system.

*/

#include <string.h>
#include <ctype.h>
#include <math.h>
#include <limits.h>
#include <setjmp.h>
#include "lstdio.h"
#include "token.h"
#include "pjbasics.h"
#include "rastext.h"
#include "fontdev.h"
#include "blockall.h"
#include "render.h"
#include "sdot.h"
#include "linklist.h"
#include "type1.h"


#define EOS     '\0'

#define X   0
#define Y   1

void calc_font_bounds(Type1_font *tcd);
static void free_scale_info(Type1_scale_info *si);

/*********DEBUGGING STUFF********/
FILE *debug_log;
Boolean in_debug = FALSE;

open_debug_log()
{
	if (debug_log == NULL)
		debug_log = fopen("H:\\debug.log", "w");
}

dvprintf(char *fmt, va_list args)
{
open_debug_log();
vfprintf(debug_log,fmt,args);
fflush(debug_log);
}

dlog(char *fmt, ...)
/* Printf to debug file. */
{
va_list argptr;

va_start(argptr, fmt);
dvprintf(fmt,argptr);
va_end(argptr);
}

ddlog(char *fmt, ...)
/* Conditional printf to debug file */
{
va_list argptr;

if (in_debug)
	{
	va_start(argptr, fmt);
	dvprintf(fmt,argptr);
	va_end(argptr);
	}
}

/*****************************************************************************
 *****************************************************************************
 ** The Load Section.  A PostScript Type 1 file is composed of a list of
 ** definitions.  Each definition is a keyword followed by data.  
 ** At the start of the file are a bunch of definitions that are about the
 ** font as a whole.  Then we come to the individual letters,   which are
 ** encrypted and in their own little RPN language.
 **
 ** The load section is concerned with verifying that the file is indeed
 ** a PostScript Type 1,  extracting a few things from the 
 ** pre-letter definitions,  and then decrypting
 ** the individual letters and the subroutines they use and sticking them 
 ** in a couple of arrays for later access.
 *****************************************************************************
 ****************************************************************************/

/*****************************************************************************
 * Let's handle errors (not enough memory, bad data in file, etc.) during
 * reading with a setjmp/longjmp.  The longjmp destination will be the
 * highest level read routine (read_font).
 ****************************************************************************/
static jmp_buf type1_load_errhandler; /* Jump buffer for load errors.	*/

static void type1_load_error(char *fmt, ...)
/*
 * format & output an error message, then longjump to error handler.
 */
{
char	sbuf[512];
va_list args;

va_start(args, fmt);
varg_continu_box(NULL,fmt,args,NULL);
va_end(args);
longjmp(type1_load_errhandler, Err_reported);
}


/*  Sections of the font file.  */
typedef enum { Header, FontInfo, OtherSubrs, Subrs, CharStrings } file_section;
static file_section section;


/*  Map of PostScript character names to ISO 8859-1 Latin 1  */

#define MAP_SIZE 256

static char *isomap[MAP_SIZE] = {
	NULL,				 /*  00 */
	NULL,				 /*  01 */
	NULL,				 /*  02 */
	NULL,				 /*  03 */
	NULL,				 /*  04 */
	NULL,				 /*  05 */
	NULL,				 /*  06 */
	NULL,				 /*  07 */
	NULL,				 /*  08 */
	NULL,				 /*  09 */
	NULL,				 /*  10 */
	NULL,				 /*  11 */
	NULL,				 /*  12 */
	NULL,				 /*  13 */
	NULL,				 /*  14 */
	NULL,				 /*  15 */
	NULL,				 /*  16 */
	NULL,				 /*  17 */
	NULL,				 /*  18 */
	NULL,				 /*  19 */
	NULL,				 /*  20 */
	NULL,				 /*  21 */
	NULL,				 /*  22 */
	NULL,				 /*  23 */
	NULL,				 /*  24 */
	NULL,				 /*  25 */
	NULL,				 /*  26 */
	NULL,				 /*  27 */
	NULL,				 /*  28 */
	NULL,				 /*  29 */
	NULL,				 /*  30 */
	NULL,				 /*  31 */
    "space",             /*  32 */
    "exclam",            /*  33 */
    "quotedbl",          /*  34 */
    "numbersign",        /*  35 */
    "dollar",            /*  36 */
    "percent",           /*  37 */
    "ampersand",         /*  38 */
    "quoteright",        /*  39 */
    "parenleft",         /*  40 */
    "parenright",        /*  41 */
    "asterisk",          /*  42 */
    "plus",              /*  43 */
    "comma",             /*  44 */
    "hyphen",            /*  45 */
    "period",            /*  46 */
    "slash",             /*  47 */
    "zero",              /*  48 */
    "one",               /*  49 */
    "two",               /*  50 */
    "three",             /*  51 */
    "four",              /*  52 */
    "five",              /*  53 */
    "six",               /*  54 */
    "seven",             /*  55 */
    "eight",             /*  56 */
    "nine",              /*  57 */
    "colon",             /*  58 */
    "semicolon",         /*  59 */
    "less",              /*  60 */
    "equal",             /*  61 */
	"greater",           /*  62 */
    "question",          /*  63 */
    "at",                /*  64 */
    "A",                 /*  65 */
    "B",                 /*  66 */
    "C",                 /*  67 */
    "D",                 /*  68 */
    "E",                 /*  69 */
    "F",                 /*  70 */
    "G",                 /*  71 */
    "H",                 /*  72 */
    "I",                 /*  73 */
    "J",                 /*  74 */
    "K",                 /*  75 */
    "L",                 /*  76 */
    "M",                 /*  77 */
    "N",                 /*  78 */
    "O",                 /*  79 */
    "P",                 /*  80 */
    "Q",                 /*  81 */
    "R",                 /*  82 */
    "S",                 /*  83 */
    "T",                 /*  84 */
    "U",                 /*  85 */
    "V",                 /*  86 */
    "W",                 /*  87 */
    "X",                 /*  88 */
    "Y",                 /*  89 */
    "Z",                 /*  90 */
    "bracketleft",       /*  91 */
    "backslash",         /*  92 */
    "bracketright",      /*  93 */
    "asciicircum",       /*  94 */
    "underscore",        /*  95 */
    "grave",             /*  96 */
	"a",                 /*  97 */
    "b",                 /*  98 */
    "c",                 /*  99 */
    "d",                 /* 100 */
    "e",                 /* 101 */
    "f",                 /* 102 */
    "g",                 /* 103 */
    "h",                 /* 104 */
    "i",                 /* 105 */
    "j",                 /* 106 */
    "k",                 /* 107 */
    "l",                 /* 108 */
    "m",                 /* 109 */
    "n",                 /* 110 */
    "o",                 /* 111 */
    "p",                 /* 112 */
    "q",                 /* 113 */
    "r",                 /* 114 */
    "s",                 /* 115 */
    "t",                 /* 116 */
    "u",                 /* 117 */
    "v",                 /* 118 */
    "w",                 /* 119 */
    "x",                 /* 120 */
    "y",                 /* 121 */
    "z",                 /* 122 */
    "braceleft",         /* 123 */
    "bar",               /* 124 */
    "braceright",        /* 125 */
    "asciitilde",        /* 126 */
    NULL,            /* 127 */
    "Ccedilla",            /* 128 */
    "uumlaut",            /* 129 */
    "eacute",            /* 130 */
    "acircumflex",               /* 131 */
	"aumlaut",           /* 132 */
    "agrave",            /* 133 */
    "aring",             /* 134 */
    "ccedilla",          /* 135 */
    "ecircumflex",               /* 136 */
    "eumlaut",           /* 137 */
    "egrave",            /* 138 */
    "iumlaut",           /* 139 */
    "icircumflex",               /* 140 */
    "igrave",            /* 141 */
    "Aumlaut",           /* 142 */
    "Aring",             /* 143 */
    "Eacute",            /* 144 */
    "ae",            /* 145 */
    "AE",        /* 146 */
    "ocircumflex",               /* 147 */
    "oumlaut",           /* 148 */
    "ograve",            /* 149 */
    "ucircumflex",               /* 150 */
    "ugrave",            /* 151 */
    "yumlaut",           /* 152 */
    "Oumlaut",           /* 153 */
    "Uumlaut",           /* 154 */
    "cent",              /* 155 */
    "sterling",          /* 156 */
    "yen",               /* 157 */
    NULL,                /* 158 */
    NULL,                /* 159 */
    "aacute",             /* 160 */
    "iacute",        /* 161 */
    "oacute",              /* 162 */
    "uacute",          /* 163 */
    "ntilde",          /* 164 */
    "Ntilde",               /* 165 */
    NULL,               /* 166 */
	NULL,           /* 167 */
    "questiondown",          /* 168 */
    NULL,         /* 169 */
    NULL,       /* 170 */
    "onehalf",     /* 171 */
    "onequarter",        /* 172 */
    "exclamdown",             /* 173 */
    NULL,        /* 174 */
    NULL,            /* 175 */
    NULL,              /* 176 */
    NULL,         /* 177 */
    NULL,       /* 178 */
    NULL,     /* 179 */
    NULL,             /* 180 */
    NULL,                /* 181 */
    NULL,         /* 182 */
    NULL,    /* 183 */
    NULL,           /* 184 */
    NULL,       /* 185 */
    NULL,      /* 186 */
    NULL,    /* 187 */
    NULL,        /* 188 */
    NULL,           /* 189 */
    NULL,     /* 190 */
    NULL,      /* 191 */
    NULL,            /* 192 */
    NULL,            /* 193 */
    NULL,       /* 194 */
    NULL,            /* 195 */
    NULL,         /* 196 */
    NULL,             /* 197 */
    NULL,                /* 198 */
    NULL,          /* 199 */
    NULL,            /* 200 */
    NULL,            /* 201 */
	NULL,       /* 202 */
    NULL,         /* 203 */
    NULL,            /* 204 */
    NULL,            /* 205 */
    NULL,       /* 206 */
    NULL,         /* 207 */
    NULL,               /* 208 */
    NULL,            /* 209 */
    NULL,            /* 210 */
    NULL,            /* 211 */
    NULL,       /* 212 */
    NULL,            /* 213 */
    NULL,         /* 214 */
    NULL,          /* 215 */
    NULL,            /* 216 */
    NULL,            /* 217 */
    NULL,            /* 218 */
    NULL,       /* 219 */
    NULL,         /* 220 */
    NULL,            /* 221 */
    NULL,             /* 222 */
    NULL,        /* 223 */
    "alpha",            /* 224 */
    "beta",            /* 225 */
    "gamma",       /* 226 */
    "pi",            /* 227 */
    "Sigma",         /* 228 */
    "sigma",             /* 229 */
    "mu",                /* 230 */
    "tau",          /* 231 */
    "Phi",            /* 232 */
    "theta",            /* 233 */
    "omega",       /* 234 */
    "delta",         /* 235 */
    "infinity",            /* 236 */
	"phi",            /* 237 */
    "epsilon",       /* 238 */
    NULL,         /* 239 */
    NULL,               /* 240 */
    "plusminus",            /* 241 */
    NULL,            /* 242 */
    NULL,            /* 243 */
    NULL,       /* 244 */
    NULL,            /* 245 */
    "divide",         /* 246 */
    NULL,            /* 247 */
    "degree",            /* 248 */
    NULL,            /* 249 */
    "bullet",            /* 250 */
    NULL,       /* 251 */
    NULL,         /* 252 */
    "twosuperior",            /* 253 */
    NULL,             /* 254 */
    NULL          /* 255 */
};




static void *loader_alloc(Type1_font *tcd, unsigned nbytes)
/* Alloc some memory for loader.  Bail out if can't. */
{
	char *cp;

	if ((cp = alloc_from_block(&tcd->font_ba, nbytes)) == NULL) {
		type1_load_error("Out of memory.  Couldn't find %d bytes", nbytes);
	}
	return (void *) cp;
}



static char *loader_strdup(Type1_font *tcd, char *s)
/*  STRSAVE  --  Allocate a duplicate of a string.  */
{
	char *c = loader_alloc(tcd, (unsigned) (strlen(s) + 1));

	strcpy(c, s);
	return c;
}


/*****************************************************************************
 * File input.
 ****************************************************************************/

static int (*byte_in)(FILE *fp);

static int hex_byte_in(FILE *fp)
{
    int c, xd = 0, i;

    for (i = 0; i < 2; i++) {
		for (;;) {
			if ((c = getc(fp)) == EOF)
                return c;
            if (isspace(c))
                continue;
            break;
        }
		if (islower(c))
			c = toupper(c);
        if (c >= '0' && c <= '9') {
            c -= '0';
		} else if (c >= 'A' && c <= 'F') {
            c = (c - 'A') + 10;
		} else {
            type1_load_error("Bad hex digit\n");
            return EOF;
        }
        xd = (xd << 4) | c;
    }
    return xd;
}


/*****************************************************************************
 *  DECRYPT  --  Perform running decryption of file.  
 ****************************************************************************/

static unsigned short int cryptR, cryptC1, cryptC2, cryptCSR;

static void crypt_init( unsigned int key)
{
	cryptR = key;
    cryptC1 = 52845;
    cryptC2 = 22719;
}

static unsigned int decrypt(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptR >> 8));

    cryptR = (cipher + cryptR) * cryptC1 + cryptC2;
	return plain;
}

static int decrypt_byte_in(FILE *fp)
{
	int ch;

	if ((ch = (*byte_in)(fp)) == EOF)
		return EOF;
	else
		return decrypt(ch);
}

static void cstrinit(void)
{
    cryptCSR = 4330;
}

static unsigned int decstr(unsigned int cipher)
{
    unsigned int plain = (cipher ^ (cryptCSR >> 8));

    cryptCSR = (cipher + cryptCSR) * cryptC1 + cryptC2;
    return plain;
}

/*****************************************************************************
 *  PARSER  --  Chop up file a line at a time and decide what to put where...
 ****************************************************************************/



typedef enum 
	{
	TTT_EOF,
	TTT_NAME,
	TTT_NUMBER,
	TTT_OTHER,
	TTT_TOO_LONG,
	} T1_token_type;

typedef struct
	{
	T1_token_type type;
	char string[256];
	int pushback;
	FILE *file;
	int (*source)(FILE *f);
	} Type1_token;

void type1_token_init(Type1_token *tok, FILE *file, int (*source)(FILE *f))
{
	clear_struct(tok);
	tok->file = file;
	tok->source = source;
}


static Boolean continue_number(int ch)
/* Return true if character is a digit */
{
	return isdigit(ch);
}

static Boolean continue_name(int ch)
/* Return true if character can be the second or further character in 
 * a name. */
{
	return ch == '_' || isalnum(ch);
}

void type1_get_binary(Type1_token *tok, unsigned char *buf, int size)
/* Read in X number of bytes.  Account for any pushed-back characters. 
 * Bails out if not enough bytes left. */
{
	int ch;
	int i = 0;

	if (tok->pushback != 0)
		{
		*buf++ = tok->pushback;
		i = 1;
		tok->pushback = 0;
		}
	for (; i<size; ++i)
		{
		if ((ch = tok->source(tok->file)) == EOF)
			type1_load_error("Could only read %d of %d bytes.\n", i, size);
		*buf++ = ch;
		}
}

void type1_get_token(Type1_token *token)
/* Read in a token from file and categorize it. 
 * In this case a token is a run of numbers, a letter followed by 
 * letters and numbers, or a single non-alpha-numeric character.  
 * White space serves to separate tokens but is otherwise skipped. 
 * Pass in a "source" function to get next character from file. 
 */
{
	int ch;
	int size = 0;
	T1_token_type retval;
	Boolean (*get_next)(int ch);
	int tok_len = sizeof(token->string);
	char *string = token->string;

	/* Get pushed-back character if any. */
	if (token->pushback == 0)
		ch = token->source(token->file);
	else
		{
		ch = token->pushback;
		token->pushback = 0;
		}
	/* Skip leading spaces. */
	for (;;)
		{
		if (ch == EOF)
			{
			token->type = TTT_EOF;
			strcpy(token->string, "<EOF>");	/* For error reporting. */
			return;
			}
		if (!isspace(ch))
			break;
		ch = token->source(token->file);
		}
	if (isdigit(ch))
		{
		get_next = continue_number;
		token->type = TTT_NUMBER;
		}
	else if (ch == '_' || isalpha(ch))
		{
		get_next = continue_name;
		token->type = TTT_NAME;
		}
	else
		{
		*string++ = ch;
		*string = 0;
		token->type = TTT_OTHER;
		return;
		}
	for (;;)
		{
		if (--tok_len <= 0)
			{
			token->type = TTT_TOO_LONG;
			return;
			}
		*string++ = ch;
		ch = token->source(token->file);
		if (!(*get_next)(ch))
			{
			token->pushback = ch;
			*string = EOS;
			return;
			}
		}
}

void debug_type1_get_token(Type1_token *tok)
{

	type1_get_token(tok);
	switch (tok->type)
		{
		case TTT_EOF:
			dlog("<eof>\n");
			break;
		case TTT_TOO_LONG:
			dlog("<too long>\n");
			break;
		default:
			dlog("\t\"%s\"\n", tok->string);
			break;
		}
}


Errcode type1_check_signature(FILE *fp)
/* This just verifies that the font begins with %!FontType1 or
 * %!PS-AdobeFont-1.0.  We expect this in the first 128 bytes. */
{
	int ch;
	int i;
	char buf[80];
	static char magic1[16] = "PS-AdobeFont-1.0";
	static char magic2[9] = "FontType1";

	for (i=0; i<128; ++i)
		{
		ch = getc(fp);
		if (ch == EOF)
			break;
		if (ch == '%') 
			{
			ch = getc(fp);
            if (ch == EOF)
				break;
            if (ch == '!')
				{
				if (fgets(buf, sizeof(buf), fp) == NULL)
					break;
				if (strncmp(buf, magic1, sizeof(magic1)) == 0
				||	strncmp(buf, magic2, sizeof(magic2)) == 0)
					return Success;
				}
	        }
		}
	return Err_bad_magic;
}

void type1_parse_custom_encoding(Type1_font *tcd, Type1_token *tok, int size)
{
	int char_ix;
	int i;

	dlog("type1_parse_custom_encoding %d entries\n", size);
	tcd->encoding_count = size;
	tcd->encoding = loader_alloc(tcd, size * sizeof(*(tcd->encoding)));
	for (i=0; i<size; ++i)
		{
		type1_get_token(tok);
		if (tok->type == TTT_EOF)
			type1_load_error("Premature end of file in Encoding");
		if (tok->type == TTT_NAME)
			{
			if (strcmp(tok->string, "dup") == 0)
				{
				/* This should be the start of a sequence formmatted:
				 * 		dup NN /name put
				 */
				type1_get_token(tok);			/* get NN into char_ix */
				if (tok->type != TTT_NUMBER)
					goto SYNTAX_ERROR;
				char_ix = atoi(tok->string);
				if (char_ix < 0 || char_ix >= size)
					type1_load_error(
			        "Error parsing encoding vector.\n"
					"Character index %d out of range.\n"
					, char_ix);
				type1_get_token(tok);			/* Skip over /  */
				if (tok->type != TTT_OTHER && tok->string[0] != '/')
					goto SYNTAX_ERROR;
				type1_get_token(tok);			/* Get name into encoding. */
				if (tok->type == TTT_NAME)
					tcd->encoding[char_ix] = loader_strdup(tcd,tok->string);
				type1_get_token(tok);			/* Skip over put */
				//dlog("\tencoding %d %s\n", char_ix, tcd->encoding[char_ix]);
				}
			else if (strcmp(tok->string, "def") == 0)
				return;
			}
		}
	return;
SYNTAX_ERROR:
	type1_load_error("Syntax error in Encoding");
}

void type1_parse_encoding(Type1_font *tcd, Type1_token *tok)
{
	long encode_size;

	type1_get_token(tok);
	if (tok->type == TTT_NAME 
	&& strcmp(tok->string, "StandardEncoding") == 0)
		{
		tcd->encoding = isomap;
		tcd->encoding_count = 256;
		return;
		}
	if (tok->type == TTT_NUMBER)
		{
		encode_size = atoi(tok->string);
		type1_get_token(tok);
		if (tok->type == TTT_NAME 
		&& strcmp(tok->string, "array") == 0)
			{
			type1_parse_custom_encoding(tcd, tok, encode_size);
			return;
			}
		}
	type1_load_error("Strange /Encoding");
}

void type1_parse_public_definition(Type1_font *tcd, Type1_token *tok)
{
	char *string;

	type1_get_token(tok);
	if (tok->type != TTT_NAME)
		return;
	if (strcmp(tok->string, "Encoding") == 0)
		type1_parse_encoding(tcd, tok);
}

void type1_parse_to_eexec(Type1_font *tcd, Type1_token *tok)
{
	for (;;)
		{
		type1_get_token(tok);
		switch (tok->type)
		  {
		  case TTT_EOF:
		    type1_load_error("No eexec in Type1 font file.");
			break;
		  case TTT_NAME:
		    if (strcmp(tok->string, "eexec") == 0)
				return;
			break;
		  case TTT_OTHER:
			if (tok->string[0] == '/')
			    type1_parse_public_definition(tcd, tok);
			break;
		  default:
		  	break;
		  }
		}
}

void type1_find_mode(Type1_font *tcd, FILE *fp)
/* 
   (John Walker's comment on how to tell hex from binary.)
   "Adobe Type 1 Font Format Version 1.1", ISBN 0-201-57044-0 states
   on page 64 that one distinguishes an ASCII from a Hexadecimal
   font file by two tests:

		* The first ciphertext byte must not be an ASCII white space
			  character (blank, tab, carriage return or line feed).
		* At least one of the first 4 ciphertext bytes must not be one
		  of the ASCII hexadecimal character codes (a code for 0-9,
		  A-F, or a-f).  These restrictions can be satisfied by adjusting
		  the random plaintext bytes as necessary.

   Well, notwithstanding this statement, Adobe's own Helvetica Bold
   Narrow Oblique file furnished with Adobe Type Manager for Windows
   has a carriage return as the first byte after the eexec invocation.
   Consequently, I turned off recognition of a hex file by the
   presence of a carriage return. */
{
	char cs[4];
	long encrypt_start;
	int i;

	encrypt_start = ftell(fp);
	cs[0] = getc(fp);


	if (cs[0] == ' ' || cs[0] == '\t' ||
		/* cs[0] == '\r' || */
		cs[0] == '\n') 
		{
		byte_in = hex_byte_in;
		dlog("Hex from the start\n");
        } 
	else 
		{
		for (i = 1; i < 4; i++) 
			{
			cs[i] = getc(fp);
            }
		byte_in = hex_byte_in;
		for (i = 0; i < 4; i++) 
			{
			if (!((cs[i] >= '0' && cs[0] <= '0') ||
				  (cs[i] >= 'A' && cs[0] <= 'F') ||
				  (cs[i] >= 'a' && cs[0] <= 'f'))) 
				{
				byte_in = fgetc;
				break;
                }
            }
		dlog("%s\n", (byte_in == hex_byte_in) ? "Hex" : "Binary");
        }

	fseek(fp, encrypt_start, SEEK_SET);	/* Reread encrypted random bytes as
										 * the decrypter depends on everything
										 * from encrypt_start on going through
										 * byte_in(). */
}

void dump_encrypted_part(Type1_font *tcd, FILE *fp)
{
	FILE *out = fopen("H:decrypt", "wb");
	long encrypt_start = ftell(fp);
	int ch;

    crypt_init(55665);
	while ((ch = decrypt_byte_in(fp)) != EOF)
		putc(ch, out);
	fclose(out);
	fseek(fp, encrypt_start, SEEK_SET);
}

int type1_get_number(Type1_token *tok)
/* Get next token,  make sure it's a number,  and return the
 * atoi'd value of number. */
{
	type1_get_token(tok);
	if (tok->type != TTT_NUMBER)
		type1_load_error("Expecting number got %s\n", tok->string);
	return atoi(tok->string);
}

void type1_force_symbol(Type1_token *tok, char *symbol)
/* Get next token.  Verify that it matches symbol. */
{
	type1_get_token(tok);
	if (tok->type != TTT_NAME || strcmp(tok->string, symbol) != 0)
		type1_load_error("Expecting %s got %s\n", symbol, tok->string);
}

void type1_skip_to(Type1_token *tok, char *symbol)
/* Skip tokens until come to one that matches symbol. */
{
	for (;;)
		{
		type1_get_token(tok);
		if (tok->type == TTT_EOF)
			type1_load_error("End of file looking for %s\n", symbol);
		if (strcmp(tok->string, symbol) == 0)
			return;
		}
}


void type1_force_RD(Type1_token *tok)
/* Make sure that the next bit in the input is either "RD" or "-|" 
 * Also skip the following white space.  */
{
	char buf[4];

	type1_get_token(tok);
	if (strcmp(tok->string, "RD") == 0)
		{
		type1_get_binary(tok, buf, 1);	/* Skip white space. */
		return;
		}
	if (tok->string[0] == '-')
		{
		type1_get_binary(tok, buf, 2);
		if (buf[0] == '|')
			return;
		}
	type1_load_error("Expecting RD or -|\n");
}

void type1_read_encoded_buffer(Type1_token *token
, unsigned char *str, int size)
/* Read in bytes from file and (doubly) decrypt.  
 * You may wonder what happens to any pushed-back characters.
 * Well, this is only called in contexts where there will be no
 * pushbacks. */
{
	int ch;
	int i;

	cstrinit();	/* Initialize string decryption. */
	/* We'll throw out the first 4 characters,  only using them
	 * to cycle the decryptor.  */
	for (i=0; i<4; ++i)	/* Decrypt next three. */
		decstr(token->source(token->file));
	/* Now read in and decrypt (again) the string. */
	while (--size >= 0)
		*str++ = decstr(token->source(token->file));
}

unsigned char *alloc_and_read_RD_string(Type1_font *tcd
,	Type1_token *tok, int binary_size)
{
	unsigned char *buf;

	type1_force_RD(tok);
	buf = loader_alloc(tcd, binary_size);
	type1_read_encoded_buffer(tok, buf, binary_size);
	return buf;
}

void type1_get_subrs(Type1_font *tcd, Type1_token *tok)
{
/* The Subrs format should be of the form:
 *	NN array 
 *		dup NN NN RD xxxxxxx NP
 *				...
 *		dup NN NN RD xxxxxxx NP
 */
	int sub_count;
	int sub_ix;
	int binary_size;
	unsigned char **subrs;
	int i;

	dlog("type1_get_subrs\n");
	tcd->sub_count = sub_count = type1_get_number(tok);
	tcd->subrs = subrs = loader_alloc(tcd, sub_count * sizeof(*subrs));
	type1_force_symbol(tok, "array");
	for (i=0; i<sub_count; ++i)
		{
		type1_skip_to(tok, "dup");
		sub_ix = type1_get_number(tok);
		if (sub_ix < 0 || sub_ix >= sub_count)
			type1_load_error("\nSubr %d out of range (0-%d).\n"
			, sub_ix, sub_count);
		binary_size = type1_get_number(tok) - 4;
		subrs[sub_ix] = alloc_and_read_RD_string(tcd, tok, binary_size);
		}
}

void type1_get_char_strings(Type1_font *tcd, Type1_token *tok)
{
/* The CharStrings format should be of the form:
 *	NN dict dup begin 
 *		/name NN RD xxxxxxx ND
 *				...
 *		/name NN RD xxxxxxx ND
 */
	int letter_count;
	char **letter_names;
	unsigned char **letter_defs;
	int letter_ix = 0;
	Boolean is_dot;
	int binary_size;

	dlog("type1_get_char_strings\n");
	tcd->letter_count = letter_count = type1_get_number(tok);
	tcd->letter_names = letter_names 
	= loader_alloc(tcd, letter_count * sizeof(*letter_names));
	tcd->letter_defs = letter_defs
	= loader_alloc(tcd, letter_count * sizeof(*letter_defs));
	for (;;)
		{
		type1_get_token(tok);
		if (tok->type == TTT_EOF)
			return;		/* Oh heck, probably have most of the font by now. */
		else if (tok->type == TTT_NAME && strcmp(tok->string, "end") == 0)
			return;
		else if (tok->type == TTT_OTHER && tok->string[0] == '/')
			{
			type1_get_token(tok);
			if (tok->string[0] == '.')	
				{
				/* Here hopefully all we are doing is converting
				 * ".notdef" to "notdef" */
				type1_get_token(tok);
				}
			if (tok->type == TTT_NUMBER)
				{	/* bocklin.pfb has a character with a missing name.
					 * Well, I geuss we kludge around it here... */
				letter_names[letter_ix] = loader_strdup(tcd, "");
				binary_size = atoi(tok->string);
				}
			else
				{
				letter_names[letter_ix] = loader_strdup(tcd, tok->string);
				binary_size = type1_get_number(tok);
				}
			//dlog("Letter %s size %d\n", letter_names[letter_ix], binary_size);
			letter_defs[letter_ix] 
			= alloc_and_read_RD_string(tcd, tok, binary_size);
			if (++letter_ix >= letter_count)
				return;
			}
		}
}

void rtype1(Type1_font *tcd, FILE *fp)
/*  RTYPE1  --  Load a type 1 font into memory.  */
{
    char token[256], ltoken[256], stoken[256], ptoken[256];
    char *tokenp;
    int i, dc;
	Errcode err;
	Type1_token tok;

	section = Header;
    ptoken[0] = stoken[0] = ltoken[0] = token[0] = EOS;

	if ((err = type1_check_signature(fp)) < Success)
		type1_load_error("Can't find !%FontType1 in .PFB file.");
	type1_token_init(&tok, fp, fgetc);
	type1_parse_to_eexec(tcd, &tok);
	if (tcd->encoding == NULL)
		type1_load_error("No /Encoding array.");
    for (i = 0; i < 6; i++) 
        (void) getc(fp);              /* Beats me, but there's 6 trash bytes */
	type1_find_mode(tcd, fp);
	dump_encrypted_part(tcd, fp);		/* DEBUG */
    crypt_init(55665);
    /* Now burn the first four plaintext bytes. */
	for (i = 0; i < 4; i++)
		(void) decrypt_byte_in(fp);
	type1_token_init(&tok, fp, decrypt_byte_in);
	for (;;)
		{
		type1_get_token(&tok);
		switch (tok.type)
		  {
		  case TTT_EOF:
			goto DONE;
		  case TTT_OTHER:
		    if (tok.string[0] == '/')
				{
				type1_get_token(&tok);
				if (tok.type == TTT_NAME)
					{
					if (strcmp(tok.string, "Subrs") == 0)
						type1_get_subrs(tcd, &tok);
					else if (strcmp(tok.string, "CharStrings") == 0)
						{
						type1_get_char_strings(tcd, &tok);
						goto DONE;
						}
					}
				}
			break;
		  default:
		    break;
		  }
	}
DONE:
	if (tcd->letter_defs == NULL)
		type1_load_error("No CharStrings!\n");
}

static void tcd_freez(Type1_font **ptcd)
/* Free up memory associated with Type1_font. */
{
Type1_font *tcd;

if (ptcd != NULL && (tcd = *ptcd) != NULL)
	{
	destroy_block_allocator(&tcd->font_ba);
	free_scale_info(&tcd->scale);
	pj_freez(ptcd);
	}
}

static Errcode read_font(FILE *fp, Type1_font **ptcd)
{
Errcode err = Success;
Type1_font *tcd;

if ((tcd = pj_zalloc(sizeof(*tcd))) == NULL)
	err = Err_no_memory;
else
	{
	construct_block_allocator(&tcd->font_ba, 512L, pj_zalloc, pj_free);
	if (Success != (err = setjmp(type1_load_errhandler)))
		{	/* Got here via longjmp. */
		tcd_freez(&tcd);
		}
	else
		{
		rtype1(tcd, fp);
		}
	}
*ptcd = tcd;
return err;
}

static Errcode find_ascii_values(Type1_font *tcd)
/*****************************************************************************
 * Go through and build up an ascii-ordered array of character definitions.
 ****************************************************************************/
{
	char *name;
	unsigned char *def;
	unsigned char *ascii_name;
	unsigned char **map = tcd->encoding;
	char **names = tcd->letter_names;
	unsigned char **defs = tcd->letter_defs;
	int i,ascii_val;
	int def_ix;
	int def_count;
	int matches = 0;

/* The character defs are stored in the font file in *roughly* ascii order.
 * The logic in this routine takes some advantage of this by starting
 * the search for the next letter where the search for the current letter
 * left off. */
	def_ix = 0;		/* Initialize search starting position. */
	def_count = tcd->letter_count;
	for (ascii_val=0; ascii_val<tcd->encoding_count; ++ascii_val)
		{
		if ((ascii_name = *map++) != NULL)
			{
			i = def_count;
			while (--i >= 0)
				{
				if (++def_ix >= def_count)
					def_ix = 0;
				if ((name = names[def_ix]) != NULL)
					{
					if (strcmp(name, ascii_name) == 0)
						{
						tcd->ascii_defs[ascii_val] = defs[def_ix];
						++matches;
						break;
						}
					}
				}
			}
		}
	if (matches > 0)
		return Success;
	else
		{
		return Err_not_found;
		}
}

Errcode type1_load_font(char *file_name, Type1_font **ptcd)
/*****************************************************************************
 * Load a type1 font into memory and do everything short of scaling to
 * prepare it for display.
 ****************************************************************************/
{
FILE *file;
Errcode err;

dlog("%s\n", file_name);
if ((file = fopen(file_name, "rb")) == NULL)
	return(errno);
if ((err = read_font(file, ptcd)) >= Success)
	if ((err = find_ascii_values(*ptcd)) >= Success)
		calc_font_bounds(*ptcd);
fclose(file);
return err;
}



/*****************************************************************************
 *****************************************************************************
 ** The Interpreter Section.  This section deals with interpreting the
 ** little reverse-polish-notation language that describes the letters in
 ** the font.  
 *****************************************************************************
 ****************************************************************************/



enum cscommand {
/*  Charstring command op-codes.  */
	Unused_0,
	Hstem,
	Unused_2,
	Vstem,
	Vmoveto,
	Rlineto,
	Hlineto,
	Vlineto,
	Rrcurveto,
	Closepath,
    Callsubr,
    Return,
    Escape,
    Hsbw,
    Endchar,
    Unused_15,
    Unused_16,
    Unused_17,
    Unused_18,
    Unused_19,
    Unused_20,
    Rmoveto,
	Hmoveto,
    Unused_23,
    Unused_24,
    Unused_25,
    Unused_26,
    Unused_27,
    Unused_28,
    Unused_29,
    Vhcurveto,
    Hvcurveto,

    /* 12 x commands */

    Dotsection,
    Vstem3,
    Hstem3,
    Unused_12_3,
    Unused_12_4,
    Unused_12_5,
    Seac,
    Sbw,
    Unused_12_8,
    Unused_12_9,
    Unused_12_10,
    Unused_12_11,
    Div,
    Unused_12_13,
    Unused_12_14,
    Unused_12_15,
    Callothersubr,
    Pop,
    Unused_12_18,
    Unused_12_19,
    Unused_12_20,
    Unused_12_21,
	Unused_12_22,
    Unused_12_23,
    Unused_12_24,
    Unused_12_25,
    Unused_12_26,
    Unused_12_27,
    Unused_12_28,
    Unused_12_29,
    Unused_12_30,
    Unused_12_31,
    Unused_12_32,
    Setcurrentpoint
};


#define StackLimit  25
#define OtherLimit  10                /* Maximum othersubr return values */

#define Npop(n) sp -= (n)
#define Clear() sp = 0



#define S0  stack[sp - 1]
#define S1  stack[sp - 2]
#define S2  stack[sp - 3]
#define S3  stack[sp - 4]
#define S4  stack[sp - 5]
#define S5  stack[sp - 6]

static long stack[StackLimit];        /* Data stack */
static int sp;                        /* Stack pointer */
static long osres[OtherLimit];        /* Results from othersubrs */
static int orp;                       /* Othersubr result pointer */

#define ReturnStackLimit 10

static unsigned char *rstack[ReturnStackLimit]; /* Return stack */
static int rsp;                       /* Return stack pointer */

static int curx, cury;			      /* The current point */
static int flexing;			          /* If a Flex in progress ? */
static int flexx, flexy;              /* Flex current position */
static Boolean pathopen;                  /* Path open ? */

static int bnum;                  	  /* Line segments per Bezier curve */

static int pcount;

#define AddPoint(output,x,y) {output->shape_point(output,x,y); ++pcount;}
#define ClosePath(output) {if (pcount) output->shape_close(output);pcount=0;}

static void Opath(Type1_output *output)
/*----------------------------------------------------------------------*
 * Start new closed shape if not in the middle of one already.
 *----------------------------------------------------------------------*/
{
        if (!pathopen)
        {
                pathopen = TRUE;
				pcount = 0;
                output->shape_open(output,curx,cury);
        }
}

static void Dpath(Type1_output *output)
/*----------------------------------------------------------------------*
 * Close current shape if any and start a new one.
 *----------------------------------------------------------------------*/
{
		if (pathopen)
        {
                ClosePath(output);
                pathopen = FALSE;
        }
        Opath(output);
}


/*  BEZIER  --  Evaluate a Bezier curve defined by four control
                points.  */


static Errcode draw_bezier(Type1_output *output, long x0, long y0
, long x1, long y1, long x2, long y2, long x3, long y3, int n)
/*----------------------------------------------------------------------*
 *	Draw a bezier curve.
 *----------------------------------------------------------------------*/
{
	int i;
	double ax, bx, cx, ay, by, cy;
	double t, dt = 1.0/n;

	ax = -x0 + 3 * x1 - 3 * x2 + x3;
	bx = 3 * x0 - 6 * x1 + 3 * x2;
	cx = 3 * (x1 - x0);

	ay = -y0 + 3 * y1 - 3 * y2 + y3;
	by = 3 * y0 - 6 * y1 + 3 * y2;
	cy = 3 * (y1 - y0);

	t = dt;
	for (i = 1; i <= n; i++) 
		{
        double vx, vy;

		vx = x0 + t * (cx + t * (bx + t * ax));
		vy = y0 + t * (cy + t * (by + t * ay));
        //vy = ay * t * t * t + by * t * t + cy * t + y0;
        t += dt;
		AddPoint(output,vx,vy);
        }
	curx = x3;
	cury = y3;
	return Success;
}

#ifdef UNUSED
static Errcode null_bezier(Type1_output *output, long x0, long y0
, long x1, long y1, long x2, long y2, long x3, long y3, int n)
/*----------------------------------------------------------------------*
 * Quick return stand in for bezier.
 *----------------------------------------------------------------------*/
{
	return Success;
}
#endif /* UNUSED */

void othersubr(Type1_output *output, int procno, int nargs, int argp)
/*----------------------------------------------------------------------*
 * Interpret an "other subroutine".  I'm not 100% sure what all this
 * can be.  There are some predefined ones for all fonts,  but potentially they
 * can reside in the file too?
 *----------------------------------------------------------------------*/
{
    static int flexp;                 /* Flex argument pointer */
    static int flexarg[8][2];

    orp = 0;                          /* Reset othersubr result pointer */

	switch (procno) {
        case 0:                       /* Flex */
			output->bezier(output,
				   flexarg[0][X], flexarg[0][Y],
				   flexarg[2][X], flexarg[2][Y],
				   flexarg[3][X], flexarg[3][Y],
				   flexarg[4][X], flexarg[4][Y], bnum);
			output->bezier(output,
				   flexarg[4][X], flexarg[4][Y],
				   flexarg[5][X], flexarg[5][Y],
				   flexarg[6][X], flexarg[6][Y],
				   flexarg[7][X], flexarg[7][Y], bnum);
            osres[orp++] = stack[argp + 3];
            osres[orp++] = stack[argp + 2];
			ddlog("End of flex (%d %d %d)\n"
			,	stack[argp+1]
			,	stack[argp+2]
			,	stack[argp+3]);
            flexing = FALSE;          /* Terminate flex */
            break;

        case 1:                       /* Flex start */
            flexing = TRUE;           /* Mark flex underway */
            flexx = curx;
            flexy = cury;
            flexp = 0;
            /* Note fall-through */
        case 2:                       /* Flex argument specification */
            flexarg[flexp][X] = flexx;
            flexarg[flexp++][Y] = flexy;
            break;

        case 3:                       /* Hint replacement */
			osres[orp++] = 3;		  /* This eventually results in
									   * subroutine 3 being called.
									   * Since subroutine 3 does nothing
									   * but return, one can only guess
									   * what Adobe had in mind designing
									   * this. */
            break;

        default:
    /*        fprintf(stderr, "\nCall to undefined othersubr %d\n",
                procno); */
			break;
    }
}


/*  EXCHARS  --  Execute charstring.  */

static Errcode type1_exchars(Type1_font *tcd, int *pwidth
,	Type1_output *output, int bezier_points, unsigned char *cp)
/* Returns Errcode or the width of character. */
{
#define So(n) if ((sp + (n)) > StackLimit) {err = Err_stack; goto ERROR;}
#define Sl(n) if (sp < (n)) {err = Err_stack; goto ERROR;}
	Errcode err = Success;
	int sub;
	int sidebear[2], charwid[2];   /* Character sidebearing and width */

	bnum = bezier_points;			  /* Set how many points in bezier curve. */
	sp = rsp = 0;                     /* Reset stack pointer */
	pathopen = FALSE;
	flexing = FALSE;          

	for (;;)
		{
		int c = *cp++;

		if (c < 32) 
			{
			/* Command */
			if (c == 12) 
				{
				/* Two byte command */
				c = *cp++ + 32;
	            }

			switch (c)
				{
				/* Commands for Starting and Finishing */
				case Endchar:     /* 14: End character */
					Clear();
					goto OUT;
				case Hsbw:        /* 13:  Set horizontal sidebearing */
					Sl(2);
					curx = sidebear[X] = S1;
					cury = sidebear[Y] = 0;
					*pwidth = charwid[X] = S0;
					charwid[Y] = 0;
					Clear();
					break;
				case Seac:        /* 12-6:  Standard encoding accented char */
					Sl(5);
					Clear();
					goto OUT;
				case Sbw:         /* 12-7:  Sidebearing point (x-y) */
					Sl(4);
					curx = sidebear[X] = S3;
					cury = sidebear[Y] = S2;
					*pwidth = charwid[X] = S1;
					charwid[Y] = S0;
					Clear();
					break;

				/* Path Construction Commands */
				case Closepath:       /* 9:  Close path */
					if (!pathopen) 
						{
						err = Err_format;
						goto ERROR;
						} 
					else 
						{
						ClosePath(output);
						}
					pathopen = FALSE;
					Clear();
					break;
				case Hlineto:         /* 6: Horizontal line to */
					Sl(1);
					Opath(output);
					curx = curx + S0;
					AddPoint(output,curx, cury);
					Clear();
					break;
				case Hmoveto:         /* 22:  Horizontal move to */
					Sl(1);
					if (flexing)
						flexx += S0;
					else
						{
						curx += S0;
						Dpath(output);
						}
					Clear();
					break;
				case Hvcurveto:       /* 31:  Horizontal-vertical curve to */
					Sl(4);
					Opath(output);
					output->bezier(output, curx, cury, curx + S3, cury,
					   curx + S3 + S2, cury + S1,
					   curx + S3 + S2, cury + S1 + S0, bnum);
					Clear();
					break;
				case Rlineto:         /* 5:  Relative line to */
					Sl(2);
					Opath(output);
					curx += S1;
					cury += S0;
					AddPoint(output,curx, cury);
					Clear();
					break;
				case Rmoveto:         /* 21:  Relative move to */
					Sl(2);
					if (flexing) 
						{
						flexx += S1;
						flexy += S0;
						}
					else
						{
						curx += S1;
						cury += S0;
						Dpath(output);
						}
					Clear();
					break;
				case Rrcurveto:       /* 8:  Relative curve to */
					Sl(6);
					Opath(output);
					output->bezier(output, curx, cury, curx + S5, cury + S4,
					   curx + S5 + S3, cury + S4 + S2,
					   curx + S5 + S3 + S1, cury + S4 + S2 + S0, bnum);
					Clear();
					break;
				case Vhcurveto:       /* 30:  Vertical-horizontal curve to */
					Sl(4);
					Opath(output);
					output->bezier(output, curx, cury, curx, cury + S3,
					   curx + S2, cury + S3 + S1,
					   curx + S2 + S0, cury + S3 + S1, bnum);
					Clear();
					break;
				case Vlineto:         /* 7:  Vertical line to */
					Sl(1);
					Opath(output);
					cury = cury + S0;
					AddPoint(output,curx,cury);
					Clear();
					break;
				case Vmoveto:         /* 4:  Vertical move to */
					Sl(1);
					if (flexing)
						flexy += S0;
					else
						{
						cury += S0;
						Dpath(output);
						}
					Clear();
					break;

				/*  Hint Commands  */
				case Dotsection:      /* 12-0:  Dot section */
					Clear();
					break;
				case Hstem:           /* 1:  Horizontal stem zone */
					Sl(2);
					Clear();
					break;
				case Hstem3:          /* 12-2:  Three horizontal stem zones */
					Sl(6);
					Clear();
					break;
				case Vstem:           /* 3:  Vertical stem zone */
					Sl(2);
					Clear();
					break;
				case Vstem3:          /* 12-1:  Three vertical stem zones */
					Sl(6);
					Clear();
					break;
				/* Arithmetic command */

				case Div:             /* 12 12:  Divide */
					Sl(2);
					S1 = (S1 + (S0 / 2)) / S0;
					Npop(1);
					break;

				/* Subroutine Commands */
				case Callothersubr:   /* 12 16:  Call other subroutine */
					Sl(2);
					Sl(2 + S1);
					ddlog("Callothersubr %d, S1 = %d\n", S0, S1);
					othersubr(output, S0, S1, sp - (3 + S1));
					Npop(2 + S1);
					break;
				case Callsubr:        /* 10:  Call subroutine */
					Sl(1);
					if (rsp >= ReturnStackLimit) 
						{
						err = Err_stack;
						goto ERROR;
						}
					rstack[rsp++] = cp;
					sub = S0;
					Npop(1);
					if (sub < 0 || sub >= tcd->sub_count) 
						{
						err = Err_function_not_found;
						goto ERROR;
						}
					if (tcd->subrs[sub] == NULL)
						{
						err = Err_null_ref;
						goto ERROR;
						}
					/* Set instruction pointer to subr code */
					cp = tcd->subrs[sub];  
					break;
				case Pop:      /* 12 17:  Return argument from othersubr */
					So(1);
					if (orp <= 0)
						{
						err = Err_stack;
						goto ERROR;
						}
					stack[sp++] = osres[--orp];
					ddlog("Just popped %d\n", osres[orp]);
					break;
				case Return:   /* 11:  Return from subroutine */
					if (rsp < 1) 
						{
						err = Err_stack;
						goto ERROR;
						}
					cp = rstack[--rsp]; /* Restore pushed call address */
					break;
				case Setcurrentpoint: /* 12 33:  Set current point */
					/* Since we only do flexing, which is done elsewhere,
					 * ignore this. */
					Sl(2);
					curx = S1;
					cury = S0;
					ddlog("Setcurrentpoint(%d %d)\n", curx, cury);
					Clear();
					break;
				}
			} 
		else 
			{
			long n;

			if (c <= 246)
				{
				n = c - 139;
				} 
			else if (c <= 250) 
				{
				n = ((c - 247) << 8) + *cp++ + 108;
				} 
			else if (c < 255) 
				{
				n = -((c - 251) << 8) - *cp++ - 108;
				} 
			else 
				{
				char a[4];

				a[0] = *cp++;
				a[1] = *cp++;
				a[2] = *cp++;
				a[3] = *cp++;
				n = (((((a[0] << 8) | a[1]) << 8) | a[2]) << 8) | a[3];
				}
			if (sp >= StackLimit) 
				{
				err = Err_stack;
				goto ERROR;
				} 
			else 
				{
				stack[sp++] = n;
				}
			}
	    }
OUT:
	ClosePath(output);
ERROR:
	return err;
#undef So
}

Errcode type1_interp_char(Type1_font *tcd,	int *pwidth
,	Type1_output *output, int bezier_points, unsigned char *cp)
/* Returns Errcode or the width of character. */
{
	Errcode err,terr;

	if ((err = output->letter_open(output)) >= Success)
		{
		terr = type1_exchars(tcd,pwidth,output,bezier_points,cp);
		if (terr >= Success)
			err = output->letter_close(output);
		if (err >= Success)	/* Give precedence to letter_close error. */
			err = terr;
		}
	return err;
}

/*****************************************************************************
 *****************************************************************************
 * Output section - a couple of ways of using the interpreter above.  One
 * for finding the bounds of characters,  and one for actually drawing them.
 *****************************************************************************
 ****************************************************************************/


/*****************Help figure out how much space letter uses*****************/

static void init_bounding_box(Type1_box *b)
/*----------------------------------------------------------------------*
 * Set up bounding box so that any incoming point will set the
 * min and the max.
 *----------------------------------------------------------------------*/
{
	b->xmin = b->ymin = INT_MAX;
	b->xmax = b->ymax = INT_MIN;
}

static void point_into_bounding_box(Type1_box *b, double x, double y)
/*----------------------------------------------------------------------*
 * Update the bounding box with a new point.
 *----------------------------------------------------------------------*/
{
	if (x < b->xmin)
		b->xmin = x;
	if (x > b->xmax)
		b->xmax = x;
	if (y < b->ymin)
		b->ymin = y;
	if (y > b->ymax)
		b->ymax = y;
}

static void box_into_bounding_box(Type1_box *dest
,	Type1_box *new)
/*----------------------------------------------------------------------*
 * Update the bounding box to include a new box.
 *----------------------------------------------------------------------*/
{
	if (new->xmin < dest->xmin)
		dest->xmin = new->xmin;
	if (new->xmax > dest->xmax)
		dest->xmax = new->xmax;
	if (new->ymin < dest->ymin)
		dest->ymin = new->ymin;
	if (new->ymax > dest->ymax)
		dest->ymax = new->ymax;
}

/*********************Stuff to position font on screen************************/
static int sf_xoff, sf_yoff;		/* Upper left corner of current char. */
static double sf_scalex, sf_scaley;	/* How to scale current character. */
static int sf_bezier_points = 8;	/* How many points to put in bezier. */

#define X_TO_SCREEN(fo,x) (sf_xoff + (int)((x)*sf_scalex))
#define Y_TO_SCREEN(fo,y) (sf_yoff - (int)((y)*sf_scaley))


/*********************Stuff for finding bounds of letter*********************/
static Type1_box bounds_box;
static int bounds_points;

static Errcode bounds_letter_open(Type1_output *fo)
{
	init_bounding_box(&bounds_box);
	return Success;
}

static Errcode bounds_close(Type1_output *fo)
{
	return Success;
}

static Errcode bounds_add_point(Type1_output *fo, double x, double y)
{
	point_into_bounding_box(&bounds_box, x, -y);
	++bounds_points;
	return Success;
}

static Type1_output bounds_output = 
	{
	draw_bezier,
	bounds_letter_open,
	bounds_close, 
	bounds_add_point, 
	bounds_close, 
	bounds_add_point,
	};

static Errcode bounds_interpret(Type1_font *tcd, unsigned char *def
,	Type1_box *bounds)
/************************************************************************
 * 
 ************************************************************************/
{
	int width;

	bounds_points = 0;
	type1_interp_char(tcd, &width, &bounds_output, sf_bezier_points, def);
	if (bounds_points > 0)
		*bounds = bounds_box;
	return width;
}

void calc_font_bounds(Type1_font *tcd)
/************************************************************************
 *  Figure out the (unscaled) size of each letter in font.
 ************************************************************************/
{
	unsigned char **ascii_defs = tcd->ascii_defs;
	Type1_box *pbounds = tcd->letter_bounds;
	int *pwidth = tcd->letter_width;
	int width, widest;
	unsigned char *def;
	int i;

	init_bounding_box(&tcd->font_bounds);
	i = BYTE_MAX;
	widest = 0;
	while (--i >= 0)
		{
		if ((def = *ascii_defs++) != NULL)
			{
			width = *pwidth = bounds_interpret(tcd, def, pbounds);
			if (width > widest)
				widest = width;
			box_into_bounding_box(&tcd->font_bounds, pbounds);
			}
		++pwidth;
		++pbounds;
		}
	tcd->font_widest = widest;

}



/*********************Stuff to draw a filled letter**************************/

static Block_allocator fill_ba;

typedef struct shape_list
	{
	struct shape_list *next;
	LLpoint *points;
	int point_count;
	} Shape_list;

static Shape_list *fill_shape_list;
static Type1_box fill_bounds;


static Errcode fill_point(Type1_output *fo, double x, double y)
/*----------------------------------------------------------------------*
 * Add a point to a filled shape.
 *----------------------------------------------------------------------*/
{
	LLpoint *p;
	int sx,sy;

	if ((p = alloc_from_block(&fill_ba, sizeof(*p))) == NULL)
		return Err_no_memory;
	p->next = fill_shape_list->points;
	fill_shape_list->points = p;
	p->x = sx = X_TO_SCREEN(fo,x);
	p->y = sy = Y_TO_SCREEN(fo,y);
	point_into_bounding_box(&fill_bounds, sx, sy);
	++fill_shape_list->point_count;
	return Success;
}

static Errcode fill_shape_open(Type1_output *fo, double x, double y)
/*----------------------------------------------------------------------*
 * Start a new filled shape.
 *----------------------------------------------------------------------*/
{
	Shape_list *s;

	if ((s = alloc_from_block(&fill_ba, sizeof(*s))) == NULL)
		return Err_no_memory;
	s->next = fill_shape_list;
	s->points = NULL;
	s->point_count = 0;
	fill_shape_list = s;
	return fill_point(fo,x,y);
}

static Errcode fill_shape_close(Type1_output *fo)
/*----------------------------------------------------------------------*
 * Finish up a filled shape.
 *----------------------------------------------------------------------*/
{
	LLpoint *last_point;

	last_point = slist_last(fill_shape_list->points);
	last_point->next = fill_shape_list->points;
	return Success;
}

static Errcode fill_letter_open(Type1_output *fo)
/*----------------------------------------------------------------------*
 * Start a filled letter.
 *----------------------------------------------------------------------*/
{
	fill_shape_list = NULL;
	construct_block_allocator(&fill_ba, 512L, pj_malloc, pj_free);
	init_bounding_box(&fill_bounds);
	return Success;
}


static void find_shape_bounds(Type1_box *bounds, Shape_list *shapes)
/*----------------------------------------------------------------------*
 * Make up a bounding box that contains every point in every shape in
 * the shape list.
 *----------------------------------------------------------------------*/
{
	Type1_box b;
	LLpoint *points;
	int point_count;
	int x,y;

	init_bounding_box(&b);
	while (shapes != NULL)
		{
		/* Ignore dotty input. */
		if ((point_count = shapes->point_count) > 1)
			{
			points = shapes->points;
			while (--point_count >= 0)
				{
				x = points->x;
				y = points->y;
				if (x < b.xmin)
					b.xmin = x;
				if (x > b.xmax)
					b.xmax = x;
				if (y < b.ymin)
					b.ymin = y;
				if (y > b.ymax)
					b.ymax = y;
				points = points->next;
				}
			}
		shapes = shapes->next;
		}
	*bounds = b;
}


static Errcode output_shape_list(Type1_output *fo, Shape_list *shapes)
/*----------------------------------------------------------------------*
 * Render shape list to screen.
 *----------------------------------------------------------------------*/
{
	Poly poly;
	int width,height;
	Type1_box bounds;
	int bpr;
	long size;
	UBYTE *on_off_buf;
	Errcode err;

/* Allocate a single bit-plane buffer big enough for whole shape. */
	find_shape_bounds(&bounds, shapes);
	width = bounds.xmax - bounds.xmin + 1;
	height = bounds.ymax - bounds.ymin + 1;
	bpr = Bitmap_bpr(width);
	size = ((long)bpr*height);
	if ((on_off_buf = pj_zalloc(size)) == NULL)
		return Err_no_memory;

	while (shapes != NULL)
		{
		/* kludge around dotty input. */
		if ((poly.pt_count = shapes->point_count) > 1)
			{
			poly.clipped_list = shapes->points;
			fill_add_shape(&poly, on_off_buf, bpr, bounds.xmin, bounds.ymin);
			err = fo->poly_out.outline(&poly,TRUE,fo->poly_out.data);
			}
		shapes = shapes->next;
		}
	err = fill_on_off(bpr, width, height, bounds.xmin, bounds.ymin
	, on_off_buf, fo->poly_out.hline, fo->poly_out.data);
	pj_free(on_off_buf);
	return err;
}

static Errcode fill_letter_close(Type1_output *fo)
/*----------------------------------------------------------------------*
 * Finish up a filled letter.
 *----------------------------------------------------------------------*/
{
	Errcode err;

		/* Some outline fonts - particularly ashley__.pfb on the letter 9
		 * neglect to close the shape before closing the letter.  Hence
		 * this check. */
	err = output_shape_list(fo, fill_shape_list);
	destroy_block_allocator(&fill_ba);
	fill_shape_list = NULL;
	return err;
}

static Type1_output fill_output = 
	{
	draw_bezier,
	fill_letter_open, 
	fill_letter_close, 
	fill_shape_open, 
	fill_shape_close,
	fill_point,
	};

static int fill_interpret(Type1_font *tcd	/* Font definition */
, unsigned char *def						/* Code to interpret */
, int xoff, int yoff						/* Upper left corner of result */
, Type1_poly_out *poly_out)					/* How to draw lines etc. */
/************************************************************************
 * Call interpreter to actually draw a filled character.
 ************************************************************************/
{
	int width;

	sf_xoff = xoff;
	/* sf_yoff = -tcd->scale.max_bounds.ymin + yoff; */
	sf_yoff = yoff;
	sf_scalex = tcd->scale.scalex;
	sf_scaley = tcd->scale.scaley;
	fill_output.poly_out = *poly_out;
	type1_interp_char(tcd, &width, &fill_output, sf_bezier_points, def);
	return width*tcd->scale.scalex;
}

/*******************Stuff to scale font*******************************/

static void free_scale_info(Type1_scale_info *si)
/*-----------------------------------------------------------------------
 * Free up resources associated with one size of font.
 *----------------------------------------------------------------------*/
{
	destroy_block_allocator(&si->ba);
}

int find_right_overlap(Type1_font *tcd, double scalex)
/*----------------------------------------------------------------------*
 * Find out the maximum difference between the right edge of a letter in
 * font and the width the same letter.  (This will be useful in telling
 * us how far to the right of the ostensible string width we need to
 * erase when undrawing.)
 *----------------------------------------------------------------------*/
{
	int *pwidth = tcd->scale.width;
	Type1_box *pbox = tcd->letter_bounds;
	unsigned char **ascii_defs = tcd->ascii_defs;
	int i = BYTE_MAX;
	int font_right_overlap = 0;
	int char_right_overlap;

	while (--i >= 0)
		{
		if (*ascii_defs++ != NULL)
			{
			if ((char_right_overlap = pbox->xmax * scalex - *pwidth) 
			> font_right_overlap)
				font_right_overlap = char_right_overlap;
			}
		++pwidth;
		++pbox;
		}
	return font_right_overlap;
}

static void scale_box(double scalex, double scaley
, Type1_box *in, Type1_box *out)
{
	out->xmin = in->xmin * scalex;
	out->ymin = in->ymin * scaley;
	out->xmax = in->xmax * scalex;
	out->ymax = in->ymax * scaley;
}

void scale_type1_font(Type1_font *tcd, double scalex, double scaley)
/*----------------------------------------------------------------------*
 *  Set up font for a particular size.
 *----------------------------------------------------------------------*/
{
	unsigned char **ascii_defs = tcd->ascii_defs;
	int *lwidth = tcd->letter_width;
	int *pscaled = tcd->scale.width;
	int i;
	long mem_block_size;

	tcd->scale.scalex = scalex;
	tcd->scale.scaley = scaley;
	tcd->scale.widest = tcd->font_widest * scaley;
	scale_box(scalex, scaley, &tcd->font_bounds, &tcd->scale.max_bounds);
	i = BYTE_MAX;
	while (--i >= 0)
		*pscaled++ = *lwidth++ * scalex;
	tcd->scale.right_overlap = find_right_overlap(tcd, scalex);
	/* Set up # of points in bezier to correspond roughly with
	 * resolution. Also set up memory block size so at small resolutions
	 * we allocate in 512 blocks, but at larger resolutions allocate
	 * for each letter individually. */
	if (scalex < 0.02)
		{
		sf_bezier_points = 4;
		mem_block_size = 512;
		}
	else if (scalex < 0.10)
		{
		sf_bezier_points = 8;
		mem_block_size = 10*1024;
		}
	else
		{
		sf_bezier_points = 16;
		mem_block_size = 64L*1024;
		}
	free_scale_info(&tcd->scale);
	construct_block_allocator(&tcd->scale.ba, mem_block_size
	,	pj_zalloc, pj_free);
	clear_mem(tcd->scale.bits, sizeof(tcd->scale.bits));

}

void set_type1_height(Type1_font *tcd, int height)
/************************************************************************
 *  Scale font so it will be a specific height.  Scale X and Y the same
 *  amount.
 ************************************************************************/
{
	double scale;
	double unscaled_height;

	unscaled_height = tcd->font_bounds.ymax - tcd->font_bounds.ymin + 1;
	scale = (double)height/unscaled_height;
	scale_type1_font(tcd, scale, scale);
}



/*****************************************************************************
 *****************************************************************************
 ** PJ Vfont glue section.  This bit folds the type1 stuff into the
 ** protocol shared by all types of fonts that PJ uses.
 *****************************************************************************
 ****************************************************************************/


/****************************Vfont functions*********************************/

static void attatch_type1_font(Vfont *vfont, Type1_font *tcd);

void vfont_free(Vfont *v)
{
	tcd_freez(&v->font);
}

#ifdef OLD
#endif /* OLD */
static Errcode fast_outline(Poly *poly, Boolean closed, void *data)
{
	int count = poly->pt_count;
	LLpoint *this, *next;

	this = poly->clipped_list;
	while (--count >= 0)
	{
		next = this->next;
		pj_cline(this->x, this->y, next->x, next->y, gl_sdot, data);
		this = next;
	}
	return Success;
}

Errcode fast_hline()
{
	return Success;
}

void type1_debug()	// Just a convenient break-point
{
	in_debug = TRUE;
}

Errcode vfont_gftext(Raster *rast,
			Vfont *v,
			register unsigned char *s,
			int x,int y,
			Pixel color,Text_mode tmode,
			Pixel bcolor)
{
	Type1_font *tcd = v->font;
	unsigned char c;
	unsigned char *def;
	Sdat sdata;
	Type1_poly_out output;

#ifdef SOMEDAY
	if (tmode == TM_RENDER)
		{
		output.hline = render_hline;
		output.outline = render_opoly;
		output.data = rast;
		}
	else
#endif /* SOMEDAY */
		{
		sdata.rast = rast;
		sdata.color = color;
		/* output.hline = gl_shline; */
		output.hline = fast_hline;
		output.outline = fast_outline;
		output.data = &sdata;
		}

	while ((c = *s++) != EOS)
		{
		ddlog("printing letter %c\n", c);
		if ((def = tcd->ascii_defs[c]) != NULL)
			x += fill_interpret(tcd, def, x, y - tcd->scale.max_bounds.ymin
			, &output);
		}
	return Success;
}

#ifdef NEW
void type1_clip(int yoff, int xstart, int xend, Type1_bitplane *bits)
/* Just for debugging.. */
{
	static FILE *f;

	if (f == NULL)
		f = fopen("H:clipme.log", "w");
	fprintf(f, "Clipping %d %d %d  into %dx%d\n"
	, yoff, xstart, xend, bits->width, bits->height);
	fflush(f);
}

/** Stuff to draw onto a bitplane. **/
Errcode type1_bits_hline(int yoff, int xstart, int xend, Type1_bitplane *bits)
{
	if (yoff < 0 || xstart < 0)
		type1_clip(yoff, xstart, xend, bits);
	else if (yoff >= bits->height || xend >= bits->width)
		type1_clip(yoff, xstart, xend, bits);
	else
		set_bit_hline(bits->bits, bits->bpr, yoff, xstart, xend);
	return Success;
}

Errcode type1_bits_dot(int x, int y, Type1_bitplane *bits)
{
	if (x < 0 || y < 0 || x >= bits->width || y >= bits->height)
		type1_clip(y,x,x,bits);
	bits->bits[y*bits->bpr + (x>>3)] |= bit_masks[x&7];
	return Success;
}

Errcode type1_bits_outline(Poly *poly, Boolean closed, Type1_bitplane *bits)
{
	int count = poly->pt_count;
	LLpoint *this, *next;

	this = poly->clipped_list;
	while (--count >= 0)
	{
		next = this->next;
		pj_cline(this->x, this->y, next->x, next->y, type1_bits_dot, bits);
		this = next;
	}
	return Success;
}

Errcode get_bit_image(Type1_font *tcd
, unsigned char letter, Type1_bitplane **pbits)
/*****************************************************************************
 * Returns bitmap for a letter.  If it's already been drawn and is in
 * the cache returns rather quickly.  Otherwise calls
 * PS Type II interpreter to make a bitmap.  
 ****************************************************************************/
{
	static Type1_poly_out output = {type1_bits_hline, type1_bits_outline, NULL};
	int width, height;
	Type1_bitplane *bits;
	Type1_box bounds;
	Errcode err;

	/* If it's already in the cache it's pretty easy. */
	if ((bits = tcd->scale.bits[letter]) != NULL)
		{
		*pbits = bits;
		return Success;
		}
	/* Find dimensions of bit image. */
	scale_box(tcd->scale.scalex, tcd->scale.scaley
	, &tcd->letter_bounds[letter], &bounds);
	/* And allocate bitmap. */
	if ((bits = alloc_from_block(&tcd->scale.ba, sizeof(*bits))) == NULL)
		return Err_no_memory;
	bits->x = bounds.xmin;
	bits->y = bounds.ymin - tcd->scale.max_bounds.ymin;
	bits->width = width = bounds.xmax - bounds.xmin + 1;
	bits->height = height = bounds.ymax - bounds.ymin + 1;
	bits->bpr = Bitmap_bpr(width);
	if ((bits->bits = alloc_from_block(&tcd->scale.ba, height*bits->bpr))
	== NULL)
		return Err_no_memory;
	/* Now set up output data structure for interpreter and draw it. */
	output.data = bits;
	if ((err = fill_interpret(tcd
	, tcd->ascii_defs[letter], -bounds.xmin, -bounds.ymin, &output)) >= Success)
		{
		tcd->scale.bits[letter] = *pbits = bits;
		}
	return err;
}

Errcode vfont_gftext(Raster *rast,
			Vfont *v,
			register unsigned char *s,
			int x,int y,
			Pixel color,Text_mode tmode,
			Pixel bcolor)
/*****************************************************************************
 * Draw a text string in the font.  
 * For each character this guy checks to see if 
 * it's already been rendered as a bitmap.  If not vfont_gftext calls the 
 * PS Type II interpreter to make a bitmap.  Then he draws the bitmap.
 ****************************************************************************/
{
	Type1_font *tcd = v->font;
	Type1_bitplane *bits;
	unsigned char c;
	unsigned char *def;
	VFUNC blit = blit_for_mode[tmode];
	Errcode err;
	int width, height;


	while ((c = *s++) != EOS)
		{
		if ((def = tcd->ascii_defs[c]) != NULL)
			{
			if ((err = get_bit_image(tcd, c, &bits)) < Success)
				return err;
			(*blit)(bits->bits, bits->bpr, 0, 0
			, rast, x+bits->x, y+bits->y
			, bits->width, bits->height, color, bcolor);
			x += tcd->scale.width[c];
			}
		}
	return Success;
}
#endif /* NEW */

int vfont_char_width(Vfont *v, UBYTE *s)
{
	Type1_font *tcd = v->font;

	return (tcd->scale.width[s[0]] + v->spacing);
}

Boolean vfont_in_font(Vfont *v, int c)
{
	Type1_font *tcd = v->font;

	return ( c >= 0 && c < BYTE_MAX && tcd->ascii_defs[c] != NULL);
}

Errcode vfont_scale_font(Vfont *v, int height)
{
	Type1_font *tcd = v->font;

	set_type1_height(tcd, height);
	attatch_type1_font(v, tcd);
	return Success;
}

/****************************Font_dev functions******************************/

Errcode check_type1_font(char *name)
/* Verify it's a Post-script font by looking for the !% signature in the
 * first 128 bytes, and making sure the file suffix starts with a 'p' */
{
FILE *f;
char *suff = pj_get_path_suffix(name);
Errcode err;

if (!(suff[1] == 'p' || suff[1] == 'P'))
	return Err_suffix;
if ((err = ffopen(name, &f, "rb")) < Success)
	return err;
err = type1_check_signature(f);
ffclose(&f);
return err;
}

static void attatch_type1_font(Vfont *vfont, Type1_font *tcd)
/*----------------------------------------------------------------------*
 * Fill out Vfont structure from relevant fields of Type1_font.
 *----------------------------------------------------------------------*/
{
clear_struct(vfont);
vfont->type = TYPE1FONT;
vfont->font = tcd;
vfont->close_vfont = vfont_free;
vfont->gftext = vfont_gftext;
vfont->char_width = vfont_char_width;
vfont->scale_font = vfont_scale_font;
vfont->in_font = vfont_in_font;
vfont->widest_image = tcd->scale.max_bounds.xmax 
- tcd->scale.max_bounds.xmin + 1;
vfont->widest_char = tcd->scale.widest;
vfont->image_height = tcd->scale.max_bounds.ymax 
- tcd->scale.max_bounds.ymin + 1;
vfont->line_spacing = vfont->image_height;
vfont->tab_width = vfont->widest_char*TABEXP;
if (tcd->scale.max_bounds.xmin < 0)
	vfont->left_overlap = -tcd->scale.max_bounds.xmin;
vfont->right_overlap = tcd->scale.right_overlap;
vfont->flags = VFF_SCALEABLE;
scan_init_vfont(vfont);
}

Errcode load_vfont(char *title, Vfont *vfont, SHORT height)
{
	Type1_font *tcd;
	Errcode err;

	if (height <= 0)
		height = 100;		/* Set default height. */
	if ((err = type1_load_font(title, &tcd)) >= Success)
		{
		set_type1_height(tcd, height);
		attatch_type1_font(vfont, tcd);
		}
	return err;
}

Font_dev type1_font_dev = {
NULL,
"Postscript Type 1",
"*.PF?",
check_type1_font,
load_vfont,
TYPE1FONT,
};

